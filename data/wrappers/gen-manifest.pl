#!/usr/bin/perl
# Â© 2015 Cyril Brulebois <cyril@debamax.com>, for the Tails project.

use strict;
use warnings;
use File::Slurp;
use List::MoreUtils qw(uniq);
use YAML::XS;


# NOTE: For reference, the first one is generated by debootstrap
# (>= 1.0.73), while the other two are generated by the apt-get
# wrapper installed in the chroot during the build.
my %package_type = qw(
    deburis binary
    binuris binary
    srcuris source
);

# NOTE: Keep those in sync with the URIs used in sources.list during
# the build.
my %origin_name = qw(
    http://ftp.us.debian.org        debian
    http://security.debian.org      debian-security
    http://deb.tails.boum.org       tails
    http://deb.torproject.org       torproject
);

### Various usability checks:
sub usage {
    die "Usage: $0 debootstrap-dir manifest-file";
}

my $debootstrap = shift @ARGV
    or usage;
my $manifest = shift @ARGV
    or usage;

if (! -d $debootstrap) {
    print "E: $debootstrap isn't a directory\n";
    usage;
}

### Read (package, version, uri) tuples and generate per-origin
### (package, version) lists:
my $data;
foreach my $type (keys %package_type) {
    my $path = "$debootstrap/$type";
    if (! -f $path ) {
        print "E: $path is missing, wrong debootstrap-dir parameter? (got: $debootstrap)\n";
        usage;
    }
    print "I: processing $path\n";
    foreach my $line (read_file($path)) {
        chomp $line;
        my ($package, $version, $uri) = split / /, $line;
        my $found;
        for my $origin (keys %origin_name) {
            if (substr($uri, 0, length $origin) eq $origin) {
                push @{ $data->{ packages }->{ $package_type{$type} }->{ $origin_name{$origin} } }, { package => $package, version => $version, };
                # XXX: Deduplication is needed. It will be added in
                # the script consuming the generated manifest for now
                # though.
                $found = $origin;
                last;
            }
        }
        if (! $found) {
            print "E: origin cannot be determined for $uri\n";
            use Data::Dumper;
            print "E: known uri to origin mapping follows:\n", Dumper(\%origin_name);
            print "E: sources.list files might have been updated, please update this mapping\n";
            exit 1;
        }
    }
}

### Extract lists of (origin, reference) from the build:
# XXX: Implement this once the infra is set up, and use static data for now:
my %origin_reference = qw(
  debian               2015102601
);

for my $name(values %origin_name) {
    $data->{origin_references}->{ $name }->{reference} = $origin_reference{ $name } || 'unknown';
}

my $yaml = Dump $data;
write_file($manifest, $yaml);
