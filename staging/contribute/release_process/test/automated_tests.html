<!DOCTYPE html>

<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tails - Automated test suite</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="icon" href="../../../favicon.ico" type="image/x-icon" />

<link rel="stylesheet" href="../../../style.css" type="text/css" />

<link rel="stylesheet" href="../../../local.css" type="text/css" />


<script src="../../../lib/js/mirror-dispatcher.js" type="text/javascript"></script>









</head>


<body class="en">


<div class="searchform">



</div>

<div class="banner" role="banner">
  <a class="tails" href="../../../index.en.html">
    <span class="acronym">Tails</span><br/>
    <span class="slogan">The Amnesic Incognito Live System</span>
  </a>
</div>

<div class="page">

<div class="pageheader">
<div class="header">
<span>
<span class="parentlinks">
<ul id="crumbs">
<li><a href="../../../index.en.html"><img src="../../../lib/home.png"></a></li>







<li><a href="../../../contribute.en.html">contribute</a></li>





<li><a href="../../release_process.html">release process</a></li>





<li><a href="../test.html">test</a></li>




<li>Automated test suite</li>

</ul>
</span>
<span class="title">
Automated test suite
</span>
</span>
</div>










</div>



<div class="sidebar" role="navigation">
<div class="download button">
  <a href="../../../install.en.html"><span class="download">Install</span>
    <span class="tails">Tails 
3.9
</span>
    <span class="date">
2018-09-05</span></a>
</div>




<div class="links">
  <ul>
    <li><a href="../../../about.en.html">About</a></li>
    <li><a href="../../../getting_started.en.html">Getting startedâ€¦</a></li>
    <li><a href="../../../doc.en.html">Documentation</a></li>
    <li><a href="../../../support.en.html">Help &amp; Support</a></li>
    <li><a href="../../../contribute.en.html">Contribute</a></li>
    <li><a href="../../../news.en.html">News</a></li>
  </ul>
</div>




<div class="donate button">
    <a href="https://tails.boum.org/donate?r=sidebar">Donate</a>
</div>


</div>



<div id="pagebody">

<div id="content" role="main">


<div class="toc">
<ol>
	<li class="L1"><a href="#index1h1">Introduction</a>
	<ol>
		<li class="L2"><a href="#index1h2">Setup and usage</a>
		</li>
		<li class="L2"><a href="#index2h2">Features</a>
		</li>
		<li class="L2"><a href="#index3h2">source vs. product cucumber features</a>
		</li>
	</ol>
	</li>
	<li class="L1"><a href="#index2h1">Implementation</a>
	<ol>
		<li class="L2"><a href="#index4h2">Running cucumber in the right environment</a>
		</li>
		<li class="L2"><a href="#index5h2">Remote shell</a>
		</li>
	</ol>
	</li>
	<li class="L1"><a href="#index3h1">The art of writing new product test cases</a>
	<ol>
		<li class="L2"><a href="#index6h2">Resources</a>
		</li>
		<li class="L2"><a href="#index7h2">Writing new features and scenarios</a>
		<ol>
			<li class="L3"><a href="#index1h3">Common steps example</a>
			</li>
			<li class="L3"><a href="#index2h3">Snapshots</a>
			</li>
			<li class="L3"><a href="#index3h3">Scenarios involving the Internet</a>
			</li>
		</ol>
		</li>
		<li class="L2"><a href="#index8h2">Writing new steps</a>
		<ol>
			<li class="L3"><a href="#index4h3">The tools and some guidelines for their usage</a>
			</li>
		</ol>
		</li>
	</ol>
	</li>
	<li class="L1"><a href="#index4h1">Limitations and issues</a>
	<ol>
		<li class="L2"><a href="#index9h2">The remote shell</a>
		<ol>
			<li class="L3"><a href="#index5h3">Different behaviour compared to "real" shell</a>
			</li>
			<li class="L3"><a href="#index6h3">Remote shell instability</a>
			</li>
		</ol>
		</li>
		<li class="L2"><a href="#index10h2">Plugging SATA drives</a>
		</li>
		<li class="L2"><a href="#index11h2">Passing state between steps in snapshots</a>
		</li>
		<li class="L2"><a href="#index12h2">Disabling scenarios that are known to fail</a>
		</li>
	</ol>
	</li>
</ol>
</div>


<h1><a name="index1h1"></a>Introduction</h1>

<p>The automated test suite is essentially a glue between:</p>

<ul>
<li><a href="http://www.sikuli.org/">Sikuli</a> and
<a href="https://fedorahosted.org/dogtail/">dogtail</a>, used for simulating
user interaction,</li>
<li><a href="http://libvirt.org/">libvirt</a>, used for running a specific build of
Tails in a virtual machine, and</li>
<li><a href="http://cukes.info/">cucumber</a>, for defining features and scenarios
testing them using the above two components.</li>
</ul>


<p>Its goal is to automate the development and release testing processes
with a Continuous Integration server.</p>

<p>A <a href="https://git-tails.immerda.ch/tails/plain/features/support/helpers/sikuli_helper.rb">custom thin Ruby wrapper</a>, using the
<a href="http://rjb.rubyforge.org/">rjb</a> Ruby-Java bridge, gives us access to
the Sikuli programmatic interface from our step definitions.</p>

<h2><a name="index1h2"></a>Setup and usage</h2>

<p>See <a href="./setup.html">setup</a> and <a href="./usage.html">usage</a>.</p>

<p>For particularities of automated tests run on our Jenkins
infrastructure, see
<a href="../../working_together/roles/sysadmins/automated_tests_in_Jenkins.html">automated tests in Jenkins</a>.</p>

<h2><a name="index2h2"></a>Features</h2>

<p>With this tool, it is possible to:</p>

<ul>
<li>Create, modify and destroy virtual machines that can run Tails from
a variety of media (primarily DVD and USB drives).</li>
<li>Create different kinds of virtual storage (IDE, USB, DVD...),
and either cold or hot plug/unplug them into/from the
virtual machine.</li>
<li>Modify the virtual machine's hardware, e.g. its amount of RAM,
its processor features (PAE), etc.</li>
<li>Simulate user interaction with the system under testing and check
its state.</li>
<li>Run arbitrary shell commands inside the virtual machine.</li>
<li>Take screenshots from the display of the virtual machine, at
particular events, like when a scenario fails. Complete test
sessions can also be captured into a video.</li>
<li>Capture and analyze the network traffic of the system under testing.</li>
</ul>


<h2><a name="index3h2"></a>source vs. product cucumber features</h2>

<p>Fundamentally speaking there are two types of tests:</p>

<ul>
<li>Tests that make sure that the Tails <em>sources</em> behave correctly <em>at
build time</em> (example: <code>features/build.feature</code>); these ones are
aptly tagged <code>@source</code>; and,</li>
<li>Tests that make sure that the product built from Tails sources, i.e.
a Tails ISO image, behaves correctly <em>at run time</em>; these ones are
tagged <code>@product</code>.</li>
</ul>


<p>The requirement of these are quite different; for instance, a
<code>@product</code> test must have access to a Tails ISO image to test, whereas a
<code>@source</code> test doesn't. Therefore their environments are setup
separately using our custom <code>BeforeFeature</code> hook, with the respective
tag.</p>

<h1><a name="index2h1"></a>Implementation</h1>

<h2><a name="index4h2"></a>Running cucumber in the right environment</h2>

<p>The <code>run_test_suite</code> script is a wrapper on top of <code>cucumber</code>, that
sets the correct environment up:</p>

<ul>
<li>It uses <code>Xvfb</code> so that the <code>DISPLAY</code> environment variable points to
an unused X display (tip: use <code>Xvfb</code>) with screen size and color
depth matching what the Sikuli images are optimized for (that is,
1024x768 / 24-bit).</li>
<li>It sets the <code>SIKULI_HOME</code> environment variable to the directory
where sikuli script is installed for Java (<code>/usr/share/java</code> in
Debian).</li>
<li>It runs <code>unclutter</code> on <code>$DISPLAY</code> to prevent the mouse
pointer from masking GUI elements looked for by Sikuli.</li>
<li>It passes <code>--format ExtraHooks::Pretty</code> to <code>cucumber</code> calls, to get
access to our custom <code>{After,Before}Feature</code> hooks.</li>
</ul>


<h2><a name="index5h2"></a>Remote shell</h2>

<p>This started out as a hack, and while it has evolved it largely
remains so. A proper, reliable, established replacement would be
welcome, but seems unlikely given the requirements:</p>

<p>Requirements on the host (the remote shell client):</p>

<ul>
<li>can execute a command with blocking until command completion on the
server, and get back return code, stdout and stderr separately.</li>
<li>can spawn a command without blocking (except an ACK that the server
has run the command, perhaps).</li>
<li>usable by an unprivileged user</li>
</ul>


<p>Requirements on the guest (the remote shell server):</p>

<ul>
<li>has to work without a network connection.</li>
<li>should interfere minimally with the surrounding system (e.g. no
firewall exceptions; actually we don't want any network traffic at
all from it, but this kind of follows from the previous requirement
any way)</li>
<li>must start before Tails Greeter. Since that's the first point of
user interaction in a Tails system (if we ignore the boot menu), it
seems like a good place to be able to assume that the remote shell
is running.</li>
</ul>


<p>Scripts:</p>

<ul>
<li><a href="https://git-tails.immerda.ch/tails/plain/config/chroot_local-includes/usr/local/lib/tails-autotest-remote-shell">config/chroot local-includes/usr/local/lib/tails-autotest-remote-shell</a></li>
<li><a href="https://git-tails.immerda.ch/tails/plain/config/chroot_local-includes/lib/systemd/system/tails-autotest-remote-shell.service">config/chroot local-includes/lib/systemd/system/tails-autotest-remote-shell.service</a></li>
</ul>


<h1><a name="index3h1"></a>The art of writing new product test cases</h1>

<p>Writing new <code>@source</code> features, scenarios or steps should be pretty
straightforward for anyone with experience with <code>cucumber</code>, but the
same can't be said about <code>@product</code> tests, so below we give some
pointers for the latter.</p>

<h2><a name="index6h2"></a>Resources</h2>

<p>In addition to the Sikuli, libvirt and Cucumber documentation linked
to in the introduction:</p>

<ul>
<li><a href="http://libvirt.org/ruby/api/index.html">ruby-libvirt API</a></li>
<li><a href="http://doc.sikuli.org/toc.html">sikuli API</a></li>
<li>The <code>sniff</code> application, which is installed in Tails, is quite
useful to navigate the GUI element hierarchy. However, <code>accerciser</code>
(not installed) is even better, due to its ability to highlight
elements. Another useful tool is <code>ipython</code> (not installed) with its
TAB-completion.</li>
</ul>


<h2><a name="index7h2"></a>Writing new features and scenarios</h2>

<p>First, one should have a good look at especially
<code>features/step_definitions/common_steps.rb</code> and the other features to
get a general idea of what already is possible. There is a good chance
there's already implementations for many steps necessary for reaching
the desired state right before when the stuff special to the intended
feature begins.</p>

<h3><a name="index1h3"></a>Common steps example</h3>

<p>In order to learn some basic step dependencies, and concepts and
features of the automated test suite used in features and scenarios,
let's walk through a few typical steps, in order:</p>

<pre><code>Given a computer
</code></pre>

<p>This is how each scenario (or background) should start. This step
destroys any residual VM from a previous scenario, and sets up a
completely fresh one, with all defaults. The defaults are defined in
<code>features/domains/default.xml</code>, but some highlights are:</p>

<ul>
<li>One virtual <code>x86_64</code> CPU with one core</li>
<li>A reasonable amount of RAM</li>
<li>ACPI, APIC and PAE enabled</li>
<li>UTC harware clock</li>
<li>A DVD drive loaded with the Tails from the ISO</li>
<li>No other storage plugged</li>
<li>USB 2.0 controller</li>
<li>Ethernet interface, plugged into a network bridged with the host</li>
</ul>


<p>However, most of the time we do not set up a computer from scratch
using this step, but restore from a snapshot (also called checkpoint)
using the one of the <code>Given Tails has booted ...</code> steps generated in
<code>features/step_definitions/snapshots.rb</code>. An example of such a step,
and indeed one of the most common ones, is:</p>

<pre><code>Given Tails has booted from DVD and logged in and the network is connected
</code></pre>

<p>These steps will actually run multiple steps, saving one or more
snapshots along the way. See the next section for details about this.</p>

<p>Returning back to what we'd do after the <code>Given a computer</code> step,
there's a number of steps that reconfigures the computer...</p>

<pre><code>And I create a 10 GiB disk named "some_disk"
</code></pre>

<p>The identifier (<code>some_disk</code>) is later used if we want to plug it or
otherwise act on it. Note that all media created this way are backed
by <a href="https://en.wikipedia.org/wiki/qcow2">qcow2</a> images, which grow only as they consume
capacity. All such media are destroyed after the feature ends.</p>

<p>This step does not necessarily have to be run this early, but it does
if we want to plug it as a non-removable drive...</p>

<pre><code>And I plug ide drive "some_disk"
</code></pre>

<p>Note that we can decide which type of drive <code>some_disk</code> is here. If we
pick a non-removable media, like in this case, it has to be done
before we start the virtual machine. Removable media, such as USB
drives, can be plugged into a live system at any later point.</p>

<pre><code>And the network is plugged
</code></pre>

<p>This plugs the network interface to the host-bridged network (which is
the default). There's also the "unplugged" version, which generally is
preferred for features that don't rely on the network (mostly so we
won't hammer the Tor network unnecessarily). These steps can also be
performed on a already running system under test.</p>

<pre><code>And I start the computer
</code></pre>

<p>This is where we actually boot the virtual machine.</p>

<pre><code>And the computer boots Tails
</code></pre>

<p>This step:</p>

<ul>
<li>verifies that we see the boot menu</li>
<li>adds any boot options added via <code>I set Tails to boot with options ...</code></li>
<li>makes sure that Tails Greeter starts</li>
<li>makes sure that the remote shell is up and running</li>
</ul>


<p>Note that the "I set sudo password ..." step has to be run before the
other Tails Greeter option steps as it relies on keyboard navigation.</p>

<pre><code>And I set sudo password "asdf"
</code></pre>

<p>Beyond the obvious, after this step all steps requiring the
administrative password have access to it.</p>

<pre><code>And I log in to a new session
And the Tails desktop is ready
And I have a network connection
And Tor is ready
</code></pre>

<p>All these should be pretty obvious. It could be mentioned that the
last two steps, like many others, depend on the remote shell to
be working.</p>

<pre><code>And all notifications have disappeared
</code></pre>

<p>The notifications can block GUI elements that we're looking for later
with Sikuli, so it's important that they are gone in essentially all
tests of GUI applications. If we have a network connection, so the
time syncing starts and shows its notifications, then this step should be
run after the previous step. Otherwise it always depends on the <code>GNOME
has started</code> step.</p>

<pre><code>And available upgrades have been checked
</code></pre>

<p>Since Tor is working, the check for upgrades will be run. We have to
wait for it to complete because that generally will break later if we
use snapshots.</p>

<h3><a name="index2h3"></a>Snapshots</h3>

<p>To speed up the test suite and get consistent results when setting up
state, we make heavy use of virtual machine snapshots. We encourage
contributors to read the snapshot definitions in
<code>features/step_definitions/snapshots.rb</code> carefully. We generate steps
from these descriptions, and they are created lazily on first use (and
then reused in subsequent instances, across features). Some things to
make note of:</p>

<ul>
<li><p>Snapshots may have parents, which means that they start by running
the parent's step, generating its snapshot, recursively to a "root"
snapshot without parent.</p></li>
<li><p>Snapshots can be made "temporary". If the snapshot description's
<code>:temporary</code> field is set to <code>true</code>, then the snapshot
will be cleared after the feature it was created in finishes. This
is a way to reduce the disk space needed for running the test suite,
and is encouraged to use for features where a very perticular state
is set up, that isn't reused in any other feature.</p></li>
<li><p>Debugging snapshot creation is made a lot easier by enabling the
<code>debug</code> formatter, which will print the steps as they are run.</p></li>
</ul>


<h3><a name="index3h3"></a>Scenarios involving the Internet</h3>

<p>Each such new scenario should sniff network traffic, and check that
all Internet traffic has only flowed through Tor. See the <code>apt</code>
feature for a simple example of how to do it.</p>

<h2><a name="index8h2"></a>Writing new steps</h2>

<h3><a name="index4h3"></a>The tools and some guidelines for their usage</h3>

<p>In essense, the tools we have for interacting with the Tails instance
are:</p>

<ul>
<li>the VM helper class,</li>
<li>Sikuli and dogtail, and</li>
<li>the remote shell.</li>
</ul>


<p>It should be fairly obvious when to use the VM helper class (stuff
relating to the virtual hardware), but there is some overlap between
Sikuli, dogtail and the remote shell.</p>

<p>Sikuli and dogtail:</p>

<ul>
<li>They should be used in all instances where we want to simulate user
interaction with the Tails system. For instance, when we start an
application we usually want to click our way through the GNOME
applications menu to stay true to what an actual user would do.</li>
<li>They come in handy when we want to verify some state pertaining
to the GUI.</li>
<li>In general we prefer dogtail, since it is more precise given its
direct access to GUI elements and their state, and Sikuli's images
carry a quite heavy maintenance burden. However, Dogtail is not
possible to use before GNOME has started, so we rely on Sikuli for
anything before or after that. Also, for some applications it's
simply hard to "navigate" to the right element in the hierarchy of
elements of some GUI, due to ambiguity and/or lack of labels.</li>
</ul>


<p>The remote shell:</p>

<ul>
<li>Useful for testing non-GUI state.</li>
<li>Useful for reaching some state required before we test stuff
depending on user interaction (which should use Sikuli!).</li>
<li>It is acceptable (but not encouraged) to use the remote shell for
simulating user terminal interaction when we need to analyze the
commands output. This is because of Sikuli's OCR capabilities are
poor, and cannot be depended on.</li>
</ul>


<h1><a name="index4h1"></a>Limitations and issues</h1>

<p>These things are good to know when developing new features, scenarios
or steps.</p>

<h2><a name="index9h2"></a>The remote shell</h2>

<h3><a name="index5h3"></a>Different behaviour compared to "real" shell</h3>

<p>The remote shells have a few surprises in store:</p>

<ul>
<li><code>pgrep -f</code> detects itself, which can have potentially serious
consequences if not dealt with.</li>
<li>Minor groups are not set, so e.g. the <code>groups</code> command may not do
what you expect, but <code>groups $USER</code> does.</li>
</ul>


<p>These are the currently known oddities of the remote shell, but there
may be more, so beware, and make sure to verify that any commands sent
through it does what you want them to do.</p>

<h3><a name="index6h3"></a>Remote shell instability</h3>

<p>Although very rare, the remote shell can get into a state where it
stops responding, resulting in the test suite waiting for a response
forever.</p>

<h2><a name="index10h2"></a>Plugging SATA drives</h2>

<p>When creating a disk (at least when backed by a <code>raw</code> image) via the
storage helper, and then plugging it to a Tails instance as SATA
drive, GNOME will report that the drive is failing when inside Tails,
and indeed several SMART tests fail. For now, plug hard disks as IDE
only (or USB, of course).</p>

<h2><a name="index11h2"></a>Passing state between steps in snapshots</h2>

<p>When creating snapshots, anything stored in a variable in any of those
steps will only be available in subsequent steps in that scenario, not
in other scenarios restoring from that snapshot. The exception is when
global variables are used, which is an acceptable workaround, but it
requires minute control to get right, and is hard to follow. Please
try to avoid this until <a href="https://labs.riseup.net/code/issues/5847">#5847</a> is solved.</p>

<h2><a name="index12h2"></a>Disabling scenarios that are known to fail</h2>

<p>When a scenario is broken for an extended period of time (e.g. when
rebasing Tails on a new Debian version, which usually breaks tons of
stuff) the current method of temporarily disabling affected tests is
simply to remove them in Tails' Git, making sure that we won't forget
about them.</p>

<p>Note that such removals should be isolated per commit so that they are
easy to revert when whatever was broken is fixed. Hence, such a commit
could either:</p>

<ul>
<li><p>remove a single scenario if something unique to that scenario is
broken;</p></li>
<li><p>remove multiple scenarios possibly spanning multiple features, if
they're broken for the same reason, e.g. a step they all use is
broken;</p></li>
<li><p>remove a complete feature, if the complete feature is broken for the
same reason.</p></li>
</ul>


<p>Each such commit <em>must</em> have a ticket created, referencing the commit
to revert, have an assignee and an appropriate milestone set so they
are not forgotten. Bonus point: push a branch that reverts the commit,
and then set it as the ticket's <em>Feature Branch</em>.</p>

<p>(Once <a href="https://labs.riseup.net/code/issues/10198">#10198</a> has hit Cucumber we can solve this,
i.e. <a href="https://labs.riseup.net/code/issues/7233">#7233</a>, in a much better way.)</p>

</div>







</div>

<div id="footer" class="pagefooter" role="contentinfo">

<div id="pageinfo">







<div id="backlinks">
Pages linking to this one:

<a href="../../../contribute.en.html">contribute</a>

<a href="../../../contribute.ar.html">contribute.ar</a>

<a href="../../../contribute.ca.html">contribute.ca</a>

<a href="../../../contribute.de.html">contribute.de</a>

<a href="../../../contribute.es.html">contribute.es</a>

<a href="../../../contribute.fa.html">contribute.fa</a>

<a href="../../../contribute.fr.html">contribute.fr</a>

<a href="../../../contribute.it.html">contribute.it</a>

<a href="../../../contribute.pl.html">contribute.pl</a>

<a href="../../../contribute.pt.html">contribute.pt</a>


<span class="popup">...
<span class="balloon">

<a href="../../../contribute.ru.html">contribute.ru</a>

<a href="../../../contribute.sr_Latn.html">contribute.sr Latn</a>

<a href="../../../contribute.tr.html">contribute.tr</a>

<a href="../../../contribute.zh.html">contribute.zh</a>

<a href="../../../contribute.zh_TW.html">contribute.zh TW</a>

<a href="../../derivatives.html">derivatives</a>

<a href="../../design.html">design</a>

<a href="../test.html">test</a>

</span>
</span>

</div>






</div>
<div id="mirrorlist">Mirror: <a href="https://tails.boum.org/ikiwiki.cgi?do=goto&page=contribute/release_process/test/automated_tests">tails.boum.org</a></div>

<!-- from The Amnesic Incognito Live System -->
</div>

</div>

<script type="text/javascript">
  var linkelements = document.querySelectorAll('.use-mirror-pool');
  if(linkelements.length > 0) {
    replaceUrlPrefixWithRandomMirror(linkelements);
  }
</script>

</body>
</html>
