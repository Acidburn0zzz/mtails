[[!meta title="Memory erasure"]]

In order to protect against memory recovery such as cold boot attack,
most of the system RAM is overwritten when Tails is being shutdown or when the
boot medium is physically removed.

#### The big picture

The initial implementation of the Tails memory erasure feature
suffered from flaws that were demonstrated by [[external
audit|security/audits/Blackhat_De-Anonymizing_Live_CDs]]. In short, it
only erased free memory and let data in the aufs read-write branch in
recoverable state.

Then, in order to erase the biggest possible part of the system memory,
a new implementation, shipped from Tails 0.7 to 2.12, runs in a
fresh environment provided by a newly started Linux kernel. This way,
a given part of the memory either is *used* by the memory erasure
process itself or it is considered as free and thus *erased* by this
process; in any case, it is at least overwritten once.

Sadly, this approach suffered from severe usability and reliability
problems (e.g. [[!tails_ticket 12354]], [[!tails_ticket 11786]]).
So it was removed in Tails 3.0, and Tails now relies on the Linux
kernel's freed memory poisoning feature.

#### Triggers

Different kinds of events trigger the memory erasure process. All lead
to run the `tails-kexec` shutdown script.

**First, most memory is erased at the end of a normal shutdown/reboot
sequence.** This is implemented by the [[Linux kernel's freed memory
poisoning feature|design/kernel_hardening]], more specifically:

* `page_poison`
* passing "P" to `slub_debug`

[[!tails_gitweb features/erase_memory.feature desc="Automated tests"]]
ensure that the most important parts of memory are erased this way.

**Second, the memory erasure process is triggered when the boot medium
is physically removed during runtime (USB boot medium is unplugged or
boot DVD is ejected).** This is implemented by a custom `udev-watchdog`
program monitors the boot medium; it's run by a wrapper, started at
boot time, that brutally invokes the memory erasure process, bypassing
other system shutdown scripts, when this medium happens to be
physically removed.

- [[!tails_gitweb config/chroot_local-includes/usr/local/lib/udev-watchdog-wrapper]]
- [[!tails_gitweb config/chroot_local-includes/usr/src/udev-watchdog.c]]
- [[!tails_gitweb config/chroot_local-hooks/52-udev-watchdog]]
- [[!tails_gitweb config/chroot_local-includes/lib/systemd/system/tails-shutdown-on-media-removal.service]]
- [[!tails_gitweb config/chroot_local-hooks/52-update-rc.d]]
- [[!tails_gitweb config/chroot_local-includes/lib/systemd/system/gdm.service.d/restart.conf]]

#### Making sure needed files are available

The `memlockd` daemon, appropriately configured, ensures every file
needed by the memory erasure process is locked into memory from boot
to memory erasure time.

- [[!debpts memlockd]]
- [[!tails_gitweb config/chroot_local-includes/etc/memlockd.cfg]]
- [[!tails_gitweb config/chroot_local-patches/keep_memlockd_on_shutdown.diff]]
- [[!tails_gitweb config/chroot_local-includes/lib/systemd/system/memlockd.service.d/oom.conf]]
- [[!tails_gitweb config/chroot_local-includes/lib/systemd/system/tails-reconfigure-memlockd.service]]
- [[!tails_gitweb config/chroot_local-includes/usr/local/sbin/tails-reconfigure-memlockd]]
