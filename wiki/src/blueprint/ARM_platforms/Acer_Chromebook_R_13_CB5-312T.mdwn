[[!meta title="Attempting to install Debian on a USB drive and boot it on an Acer Chromebook R 13 CB5-312T"]]

[[!toc levels=2]]

# Models

This was initially tested on CB5-312T K7SP. Further work may happen
with a CB5-312T K2L7.

# Resources

* <http://forums.debian.net/viewtopic.php?t=103468>
* <https://wiki.debian.org/InstallingDebianOn/Asus/C201>
* <https://wiki.debian.org/InstallingDebianOn/Acer/Chromebook_13_CB5-311-T8BT>
* <https://wiki.debian.org/InstallingDebianOn/Samsung/ARMChromebook>
* <https://www.chromium.org/chromium-os/developer-information-for-chrome-os-devices/custom-firmware>
* Interesting Debian packages: `vboot-utils vboot-kernel-utils u-boot-tools`

# Current status

Both with the Chrome OS kernel and the Debian kernel approaches I end
up with something that fails in the exact same way: at the developer
mode start screen I press Ctrl+U, and then the display shuts down but
the computer remains running indefinitely. So it seems that an attempt
at booting actually happens; if the signing is messed up, or the
partitions don't look right, I should just get an error beep when
pressing Ctrl+U.

This might be fixed by enabling the `DRM_MEDIATEK` Kconfig option,
that's not enabled in Debian currently:

* <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2e726dc4b4e2dd3ae3fe675f9d3af88a2d593ee1>
* <https://lists.freedesktop.org/archives/dri-devel/2016-May/108049.html>

We should try enabling it in a custom kernel before requesting for
these modules to be shipped in the Debian one.

<https://wiki.debian.org/InstallingDebianOn/Asus/C201> says:  "If you
are running a newer ChromeOS, CONFIG_VT may be disabled in the kernel.
this prevents the creation of consoles and the starting of Xorg from
current stable. You need to install a tool that uses the framebuffer
directly to interact with your new operating system. A patch is
available and tested, but has yet to make it to the point of being
submittable to the Xorg development team. See:
<http://demo1.faikvm.com/trac/wiki/C201>". Might this explain why
the ChromeOS kernel doesn't display anything, even if it has
`DRM_MEDIATEK` enabled?

# On a Debian machine

<div class="note">This Debian machine does not have to be ARM.</div>

Set some variables:

	DEV=/dev/sdb
	ROOT_PART=${DEV}2
	MNT=/mnt/debian
	mkdir -p ${MNT}

Partitioning the device:

	parted --script ${DEV} mklabel gpt
	cgpt create ${DEV}

Below is for a 4 GiB USB drive, adjust if needed.

	# Too small for Debian's kernel + initrd:
	#cgpt add -t kernel -l kernel -b 34 -s 32768 ${DEV}
	#cgpt add -t data -l / -b 32802 -s 15325151 ${DEV}
	# so let's double it:
	cgpt add -t kernel -l kernel -b 34 -s 65536 ${DEV}
	cgpt add -t data -l / -b 65570 -s 15292383 ${DEV}
	blockdev --rereadpt ${DEV}
	mkfs.ext4 ${ROOT_PART}
	mount ${ROOT_PART} ${MNT}
	debootstrap --arch=arm64 --foreign stretch ${MNT} http://ftp.de.debian.org/debian

Unmount the filesystems

	umount ${MNT}

# From now on, everything happens on the Chromebook

	DEV=/dev/sda
	ROOT_PART=${DEV}2
	KERNEL_PART=${DEV}1
	MNT=/mnt/debian
	mkdir -p ${MNT}

Unmount from wherever ChromeOS decided to auto-mount the device,
remount where we want it:

	umount ${ROOT_PART}
	mount ${ROOT_PART} ${MNT}

Complete the bootstrap:

	chroot ${MNT} /debootstrap/debootstrap --second-stage

Configure the system:

	cat > ${MNT}/etc/fstab <<EOF
	${ROOT_PART} / ext4 errors=remount-ro 0 1
	EOF
	echo "chromian" > ${MNT}/etc/hostname
	cp /etc/resolv.conf ${MNT}/etc/resolv.conf
	chroot ${MNT} apt-get update
	chroot ${MNT} apt-get install -y cgpt vboot-utils \
	        vboot-kernel-utils
	chroot ${MNT} passwd -d root


## Kernel approach 1 - try the Chrome OS kernel

Guess which kernel partition is the latest.  Run cgpt show and see
which one (KERN-A or KERN-B) has the highest priority.

	cgpt show /dev/mmcblk0

Copy the ChromeOS kernel to the root filesystem,
In this example we'll assume it was KERN-B:

	dd if=/dev/mmcblk0p4 of=${MNT}/boot/chromeos.kernel.signed

Declare the kernel flags:

	cat > ${MNT}/boot/kernel.flags <<EOF
	console=tty1 printk.time=1 nosplash rootwait root=${ROOT_PART} ro rootfstype=ext4 lsm.module_locking=0
	EOF

Sign the kernel:

	cat > ${MNT}/boot/sign-kernel.sh <<EOF
	vbutil_kernel --repack /boot/vmlinuz.signed --keyblock \
	  /usr/share/vboot/devkeys/kernel.keyblock --version 1 \
	  --signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk \
	  --config /boot/kernel.flags --oldblob /boot/chromeos.kernel.signed \
	  --arch arm
	EOF
	chroot ${MNT} sh /boot/sign-kernel.sh

Write the signed kernel to the kernel partition:

	dd if=${MNT}/boot/vmlinuz.signed of=${KERNEL_PART}

Mark the newly written kernel partition as good and set the
priority:

	cgpt add -i 1 -S 1 -T 5 -P 12 ${DEV}

Copy the ChromeOS kernel modules into the root filesystem:

	mkdir -p ${MNT}/lib/modules
	cp -r /lib/modules/* ${MNT}/lib/modules

Copy the non-free firmware for the wifi device:

	mkdir -p ${MNT}/lib/firmware/
	cp -r /lib/firmware/* ${MNT}/lib/firmware

Umount the filesystems:

	umount ${MNT}

## Kernel approach 2 - Debian's kernel

	chroot ${MNT} apt install linux-image-arm64

We need `mt8173-evb.dtb` but it's not present in Debian's kernel possibly due to:
[[!debbug 833561]] so I got it from ubuntu xenial's (although I probably should
compile myself): `linux-image-4.8.0-34-generic_4.8.0-34.36-16.04.1_arm64.deb`.
Put it in `${MNT}/boot`.

chroot into `${MNT}`, then:

	cd /boot

	cat > kernel-initrd.its <<EOF
	/dts-v1/;

	/ {
	    description = "Linux kernel image with one or more FDT blobs";
	    #address-cells = <1>;
	    images {
	        kernel@1{
	            description = "vmlinuz";
	            data = /incbin/("vmlinuz-4.9.0-2-arm64");
	            type = "kernel_noload";
	            arch = "arm";
	            os = "linux";
	            compression = "none";
	            hash@1{
	                algo = "sha1";
	            };
	        };
	        fdt@1{
	            description = "dtb";
	            data = /incbin/("mt8173-evb.dtb");
	            type = "flat_dt";
	            arch = "arm";
	            compression = "none";
	            hash@1{
	                algo = "sha1";
	            };
	        };
	        ramdisk@1{
	            description = "initrd.img";
	            data = /incbin/("initrd.img-4.9.0-2-arm64");
	            type = "ramdisk";
	            arch = "arm";
	            os = "linux";
	            compression = "none";
	            hash@1{
	                algo = "sha1";
	            };
	        };
	    };
	    configurations {
	        default = "conf@1";
	        conf@1{
	            kernel = "kernel@1";
	            fdt = "fdt@1";
	                ramdisk = "ramdisk@1";
	        };
	    };
	};
	EOF

	mkimage -f kernel-initrd.its kernel-initrd.itb

	echo "console=tty1 debug root=/dev/sda2 rw rootwait printk.time=1 nosplash lsm.module_locking=0" > cmdline

	vbutil_kernel --pack vmlinuz.signed \
	      --keyblock /usr/share/vboot/devkeys/kernel.keyblock \
	      --version 1 \
	      --signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk \
	      --config cmdline \
	      --bootloader cmdline \
	      --vmlinuz kernel-initrd.itb \
	      --arch arm

**Just for the record**, here's a supposed alternative to above
`vbutil_kernel` command but it seems to work worse (Ctrl+U at the
Chrome OS developer mode boot screen behaves just as if it's not a
valid device to boot from):

	futility --debug vbutil_kernel \
	    --arch arm \
	    --version 1 \
	    --keyblock /usr/share/vboot/devkeys/kernel.keyblock \
	    --signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk \
	    --bootloader cmdline \
	    --config cmdline \
	    --vmlinuz kernel-initrd.itb \
	    --pack vmlinuz.signed \

Install the kernel:

	dd if=vmlinuz.signed of=${DEV}

Mark the newly written kernel partition as good and set the
priority:

	cgpt add -i 1 -S 1 -T 5 -P 12 ${DEV}
