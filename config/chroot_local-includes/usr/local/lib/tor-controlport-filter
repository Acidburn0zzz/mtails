#!/usr/bin/python3

# Tor control port filter proxy, only white-listing SIGNAL NEWNYM,
# ADD_ONION, and DEL_ONION.

# This filter proxy should allow Torbutton to request a
# new Tor circuit, without exposing dangerous control requests
# like "GETINFO address" to applications running as a local user.

# If something goes wrong, an error code is returned, and
# Torbutton will display a warning dialog that New Identity failed.

# This filter proxy also allows software like OnionShare or Ricochet
# to add and delete ephermeral hidden services.

import glob
import psutil
import re
import socketserver
import subprocess
import stem
import stem.control
import yaml

# Limit the length of a line, to prevent DoS attacks trying to
# crash this filter proxy by sending infinitely long lines.
MAX_LINESIZE = 128

class UnexpectedAnswer(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return "[UnexpectedAnswer] " + self.msg

def exe_path_of_pid(pid):
    # Here we leverage AppArmor's in-kernel solution for determining
    # the exact executable invoked. Looking at /proc/pid/exe when an
    # interpreted script is running will just point to the
    # interpreter's binary, which is not fine-grained enough, but
    # AppArmor will be aware of which script is running for processes
    # using one of its profiles.
    p = subprocess.Popen(['/usr/sbin/aa-status', '--verbose'],
                         stdout = subprocess.PIPE,
                         stderr = subprocess.PIPE,
                         shell = False)
    stdout, _ = p.communicate()
    returncode = p.returncode
    assert(returncode == 0)
    STATE_LOOKING_FOR_PROCS_SECTION = 0
    STATE_FOUND_PROCS_SECTION = 1
    parser_state = STATE_LOOKING_FOR_PROCS_SECTION
    for line in str(stdout, 'UTF+8').split("\n"):
        if parser_state == STATE_LOOKING_FOR_PROCS_SECTION:
            if re.match(r'^\d+ processes ', line):
                parser_state = STATE_FOUND_PROCS_SECTION
        elif parser_state == STATE_FOUND_PROCS_SECTION:
            match = re.match(r'^\s*(/.+)\s+\((\d+)\)\s*$', line)
            if match:
                proc_exe_path = match.group(1)
                proc_pid = int(match.group(2))
                if proc_pid == pid:
                    return proc_exe_path
            else:
                parser_state = STATE_LOOKING_FOR_PROCS_SECTION
    # If no AppArmor profile was found for the PID, we fallback to the
    # executable according to procfs, which will be good enough for
    # binaries but not interpreted scripts.
    return psutil.Process(pid).exe()


def handle_controlport_session(controller, readh, writeh, allowed_commands, allowed_events):
    def respond(line, raw = False):
        writeh.write(bytes(line, 'ascii'))
        if not raw: writeh.write(bytes("\r\n", 'ascii'))
        writeh.flush()

    subscribed_event_listeners = []

    while True:
        line = str(readh.readline(MAX_LINESIZE), 'ascii').strip()

        if not line: break

        def line_matches_command(cmd):
            # The control port language does not care about case for
            # commands.
            return re.match(r"^%s\b" % cmd, line, re.IGNORECASE)

        # Check what it is
        if line_matches_command("PROTOCOLINFO"):
            # Stem call PROTOCOLINFO before authenticating. Tell the
            # client that there is no authentication.
            respond("250-PROTOCOLINFO 1")
            respond("250-AUTH METHODS=NULL")
            respond("250-VERSION Tor=\"{}\"".format(controller.get_version()))
            respond("250 OK")

        elif line_matches_command("AUTHENTICATE"):
            # We have already authenticated, and the filtered port is
            # access-restricted to the allowed users via the firewall.
            respond("250 OK")

        elif line_matches_command("QUIT"):
            respond("250 closing connection")
            break

        # The client will be fooled that it is subscribing to all
        # events it requested, but we will only let through allowed
        # events.
        elif line_matches_command("SETEVENTS"):
            events = line.split(' ')[1:]
            if len(events) > 0:
                for event in events:
                    # The control language doesn't care about case for
                    # the event type.
                    event = event.upper()
                    if event in allowed_events:
                        def event_cb(event):
                            respond(event.raw_content(), raw = True)
                        controller.add_event_listener(event_cb, getattr(stem.control.EventType, event))
                        subscribed_event_listeners.append(event_cb)
                respond("250 OK")
            else:
                for listener in subscribed_event_listeners:
                    controller.remove_event_listener(listener)
                subscribed_event_listeners = []
                respond("250 OK")

        else:
            cmd, _, args = line.partition(' ')
            cmd = cmd.upper()
            allowed_args = allowed_commands.get(cmd, [])
            if any(re.match(regex + "$", args) for regex in allowed_args):
                response = controller.msg(line)
                respond(response.raw_content(), raw = True)
            else:
                print("Command filtered: " + line)
                respond("510 Command filtered")


class FilteredControlPortProxyHandler(socketserver.StreamRequestHandler):

    def setup(self):
        super(type(self), self).setup()
        self.filters = []
        for filter_file in glob.glob('/etc/tor-controlport-filter.d/*.yml'):
            with open(filter_file, "rb") as fh:
                self.filters += yaml.load(fh.read())

    def connect_to_real_control_port(self):
        # Read authentication cookie
        with open("/var/run/tor/control.authcookie", "rb") as f:
            cookie = f.read(32)

        # Connect to the real control port
        controller = stem.control.Controller.from_socket_file("/var/run/tor/control")
        try:
            controller.authenticate(cookie)
        except stem.SocketError:
            raise UnexpectedAnswer("AUTHENTICATE failed")

        return controller

    def handle(self):
        client_conn = next(conn for conn in psutil.net_connections() if conn.laddr == self.client_address)
        client_exe_path = exe_path_of_pid(client_conn.pid)
        client_filter = next(filter for filter in self.filters if any(exe_path for exe_path in filter['match-exe-paths'] if client_exe_path == exe_path))
        allowed_commands = client_filter.get('commands', {})
        allowed_events = client_filter.get('events', [])
        controller = self.connect_to_real_control_port()
        try:
            handle_controlport_session(controller, self.rfile, self.wfile, allowed_commands, allowed_events)
        finally:
            controller.close()


def main():
    listen_port = 9052
    server = socketserver.ThreadingTCPServer(("localhost", listen_port),
                                             FilteredControlPortProxyHandler)
    print("Tor control port filter started, listening on %d" % listen_port)
    server.serve_forever()


if __name__ == "__main__":
    main()
