#!/usr/bin/python3

# This filter proxy allows fine-grained access whitelists of commands
# (and their argunents) and events on a per-application basis, stored
# in:
#
#     /etc/tor-controlport-filter.d/
#
# who are pretty self-explanatory as long as you understand the Tor
# ControlPort language. The format is based on YAML where the
# top-level is supposed to be a list, where each element looks like
# this:
#
#     - match-exe-paths:
#         - path_to_executable1
#         - path_to_executable2
#         ...
#       match-users:
#         - user1
#         - user2
#         ...
#       commands:
#         command1:
#           - command1_arg1
#           - command1_arg2
#           ...
#         command2:
#           - command2_arg1
#           - command2_arg2
#           ...
#         ...
#       events:
#         - event1
#         - event2
#         ...
#
# `match-exe-paths` and `match-users` are both obligatory, and clients
# must match some element in both of their lists to get the access
# rights defined in the filter. In both lists, `*` will match
# anything. A client can match several filters, resulting in the union
# of the access rights of all matched filters.
#
# `commands` and `events` are both optional. To be able to run a
# command without arguments the empty string must be explicitly
# listed. An empty argument list does not allow any use of the
# command.
#
# `restrict-stream-events` is optional, and if set any STREAM events
# sent to the client (after it has subscribed to them) will be
# restricted to those originating from the client itself.

import argparse
import glob
import os.path
import psutil
import re
import socketserver
import stem
import stem.control
import sys
import yaml

DEFAULT_LISTEN_PORT = 9051
DEFAULT_COOKIE_PATH = '/var/run/tor/control.authcookie'
DEFAULT_CONTROL_SOCKET_PATH = '/var/run/tor/control'

# This will store the arguments from argparse. We put it in the global
# scope since it's awkward to extend socketserver so additional data
# can be sent to the request handler, where we need access to the
# arguments.
global_args = None

# Limit the length of a line, to prevent DoS attacks trying to
# crash this filter proxy by sending infinitely long lines.
MAX_LINESIZE = 1024


def log(msg):
    print(msg, file=sys.stderr)
    sys.stderr.flush()


def pid_of_laddr(address):
    try:
        return next(conn for conn in psutil.net_connections() \
                    if conn.laddr == address).pid
    except StopIteration:
        return None


def exe_path_of_pid(pid):
    # Here we leverage AppArmor's in-kernel solution for determining
    # the exact executable invoked. Looking at /proc/pid/exe when an
    # interpreted script is running will just point to the
    # interpreter's binary, which is not fine-grained enough, but
    # AppArmor will be aware of which script is running for processes
    # using one of its profiles. However, we fallback to /proc/pid/exe
    # in case there is no AppArmor profile, so the only unsupported
    # mode here is unconfined scripts.
    enabled_aa_profile_re = r'^(/.+) \((?:complain|enforce)\)$'
    with open('/proc/{}/attr/current'.format(str(pid)), "rb") as fh:
        aa_profile_status = str(fh.read().strip(), 'UTF-8')
        exe_path_match = re.match(enabled_aa_profile_re, aa_profile_status)
        if exe_path_match:
            return exe_path_match.group(1)
        else:
            return psutil.Process(pid).exe()


def handle_controlport_session(controller, readh, writeh, allowed_commands, allowed_events, client_pid, restrict_stream_events = False):
    def respond(line, raw=False):
        writeh.write(bytes(line, 'ascii'))
        if not raw: writeh.write(bytes("\r\n", 'ascii'))
        writeh.flush()

    def is_line_allowed(line):
        if global_args.complain: return True
        cmd, _, args = line.partition(' ')
        cmd = cmd.upper()
        allowed_args = allowed_commands.get(cmd, [])
        return any(re.match(regex + "$", args) for regex in allowed_args)

    def proxy_line(line):
        if global_args.complain: log("-> {}".format(line))
        response = controller.msg(line)
        respond(response.raw_content(), raw=True)

    def filter_line(line):
        log("Command filtered: {}".format(line))
        respond("510 Command filtered")

    def event_cb(event):
        if restrict_stream_events and \
           isinstance(event, stem.response.events.StreamEvent) and \
           not global_args.complain:
            if event.id not in client_streams:
                if event.status in [stem.StreamStatus.NEW,
                                    stem.StreamStatus.NEWRESOLVE] and \
                   client_pid == pid_of_laddr((event.source_address,
                                               event.source_port)):
                    client_streams.add(event.id)
                else:
                    return
            elif event.status in [stem.StreamStatus.FAILED,
                                  stem.StreamStatus.CLOSED]:
                client_streams.remove(event.id)
        respond(event.raw_content(), raw=True)

    subscribed_event_listeners = []
    client_streams = set()

    while True:
        line = str(readh.readline(MAX_LINESIZE), 'ascii').strip()

        if not line: break

        # This regex makes us split on unquoted whitespaces.
        cmd, *args = re.findall(r'(?:[^\s,"]|"(?:\\.|[^"])*")+', line)
        cmd = cmd.upper()

        # Check what it is
        if cmd == "PROTOCOLINFO":
            # Stem call PROTOCOLINFO before authenticating. Tell the
            # client that there is no authentication.
            respond("250-PROTOCOLINFO 1")
            respond("250-AUTH METHODS=NULL")
            respond("250-VERSION Tor=\"{}\"".format(controller.get_version()))
            respond("250 OK")

        elif cmd == "AUTHENTICATE":
            # We have already authenticated, and the filtered port is
            # access-restricted to the allowed users via the firewall.
            respond("250 OK")

        elif cmd == "QUIT":
            respond("250 closing connection")
            break

        # The client will be fooled that it is subscribing to all
        # events it requested, but we will only let through allowed
        # events.
        elif cmd == "SETEVENTS":
            if global_args.complain:
                log('-> SETEVENTS {}'.format(' '.join(args)))
            for listener in subscribed_event_listeners:
                controller.remove_event_listener(listener)
            subscribed_event_listeners = []
            for event in args:
                # The control language doesn't care about case for
                # the event type.
                event = event.upper()
                if event in allowed_events or global_args.complain:
                    controller.add_event_listener(
                        event_cb, getattr(stem.control.EventType, event)
                    )
                    subscribed_event_listeners.append(event_cb)
            respond("250 OK")

        # SETCONF can take multiple assignments, but let's allow
        # listing them individually in the filter file.
        elif cmd == "SETCONF":
            if all(is_line_allowed("SETCONF {}".format(arg)) for arg in args):
                proxy_line(line)
            else:
                filter_line(line)

        else:
            if is_line_allowed(line):
                proxy_line(line)
            else:
                filter_line(line)


class FilteredControlPortProxyHandler(socketserver.StreamRequestHandler):

    def setup(self):
        super(type(self), self).setup()
        self.filters = []
        for filter_file in glob.glob('/etc/tor-controlport-filter.d/*.yml'):
            with open(filter_file, "rb") as fh:
                filters = yaml.load(fh.read())
                name = re.sub(r'\.yml$', '', os.path.basename(filter_file))
                for filter_ in filters:
                    filter_['name'] = name
                self.filters += filters

    def connect_to_real_control_port(self):
        # Read authentication cookie
        with open(global_args.control_cookie_path, "rb") as f:
            cookie = f.read(32)

        # Connect to the real control port
        controller = stem.control.Controller.from_socket_file(
            global_args.control_socket_path
        )
        controller.authenticate(cookie)

        return controller

    def handle(self):
        client_pid = pid_of_laddr(self.client_address)
        # Deal with the race between looking up the PID, and the
        # client being killed before we find the PID.
        if not client_pid: return
        client_exe_path = exe_path_of_pid(client_pid)
        client_user = psutil.Process(client_pid).username()
        restrict_stream_events = False
        matched_filters = []
        allowed_commands = {}
        allowed_events = []
        for filter_ in self.filters:
            is_ok = True
            matchers = [
                ('match-exe-paths', client_exe_path),
                ('match-users', client_user),
            ]
            for key, expected_val in matchers:
                if not key in filter_:
                    is_ok = False
                    log("Filter '{}' lacks obligatory key '{}': skipping"
                        .format(filter_['name'], key)
                    )
                    break
                if not any(val for val in filter_[key] \
                           if expected_val == val or val == '*'):
                    is_ok = False
                    break
            if is_ok:
                if 'commands' in filter_:
                    # Instead of a simple dict.update(), which would
                    # overwrite existing values (i.e. the argument
                    # list from a previous filter) we merge the values
                    # in place, to combine multiple matched filters
                    # without loss.
                    for key in filter_['commands']:
                        old = allowed_commands.get(key, [])
                        new = filter_['commands'][key]
                        allowed_commands[key] = old + new
                allowed_events += filter_.get('events', [])
                matched_filters.append(filter_['name'])
                if filter_.get('restrict-stream-events', False):
                    restrict_stream_events = True
        if matched_filters == []:
            status = 'no matching filter found, using an empty one'
        else:
            status = 'loaded filter(s): {}'.format(", ".join(matched_filters))
        log('{} (PID: {}, user: {}) connected: {}'
            .format(client_exe_path, client_pid, client_user, status)
        )
        controller = self.connect_to_real_control_port()
        disconnect_reason = "client quit"
        try:
            handle_controlport_session(controller, self.rfile, self.wfile,
                                       allowed_commands, allowed_events,
                                       client_pid, restrict_stream_events
            )
        except (ConnectionResetError, BrokenPipeError) as err:
            # Handle clients disconnecting abruptly
            disconnect_reason = str(err)
        finally:
            controller.close()
            log('{} (PID: {}, user: {}) disconnected: {}'
                .format(client_exe_path, client_pid, client_user,
                        disconnect_reason)
            )


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p", "--listen-port",
        type=int, metavar='PORT', default=DEFAULT_LISTEN_PORT,
        help="specifies the port on which the server listens " +
             "(default: {})".format(DEFAULT_LISTEN_PORT))
    parser.add_argument(
        "-c", "--control-cookie-path",
        type=str, metavar='PATH', default=DEFAULT_COOKIE_PATH,
        help="specifies the path to Tor's control authentication cookie " +
             "(default: {})".format(DEFAULT_COOKIE_PATH))
    parser.add_argument(
        "-s", "--control-socket-path",
        type=str, metavar='PATH', default=DEFAULT_CONTROL_SOCKET_PATH,
        help="specifies the path to Tor's control socket " +
             "(default: {})".format(DEFAULT_CONTROL_SOCKET_PATH))
    parser.add_argument(
        "--complain",
        action='store_true', default=False,
        help="disables all filtering and just prints the commands sent " +
             "by the client")
    global global_args
    global_args = parser.parse_args()
    server = socketserver.ThreadingTCPServer(
        ("localhost", global_args.listen_port),
        FilteredControlPortProxyHandler
    )
    log("Tor control port filter started, listening on {}"
        .format(global_args.listen_port))
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    main()
