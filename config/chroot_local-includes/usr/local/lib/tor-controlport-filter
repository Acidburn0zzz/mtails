#!/usr/bin/python3

# Tor control port filter proxy, only white-listing SIGNAL NEWNYM,
# ADD_ONION, and DEL_ONION.

# This filter proxy should allow Torbutton to request a
# new Tor circuit, without exposing dangerous control requests
# like "GETINFO address" to applications running as a local user.

# If something goes wrong, an error code is returned, and
# Torbutton will display a warning dialog that New Identity failed.

# This filter proxy also allows software like OnionShare or Ricochet
# to add and delete ephermeral hidden services.

import socketserver
import re

from stem.control import Controller, EventType
from stem import SocketError

# Limit the length of a line, to prevent DoS attacks trying to
# crash this filter proxy by sending infinitely long lines.
MAX_LINESIZE = 128

ALLOWED_COMMANDS = {
    'GETINFO': ['version', 'onions/current'],
    'SIGNAL': ['NEWNYM'],
    'ADD_ONION': ['NEW:BEST Port=80,176\d\d'],
    'DEL_ONION': ['.+'],
}

ALLOWED_EVENTS = {
    'HS_DESC': EventType.HS_DESC,
    'SIGNAL': EventType.SIGNAL,
    'CONF_CHANGED': EventType.CONF_CHANGED,
}


class UnexpectedAnswer(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return "[UnexpectedAnswer] " + self.msg

def handle_controlport_session(controller, readh, writeh):
    def respond(line):
        writeh.write(bytes(line, 'ascii'))
        writeh.flush()

    subscribed_event_listeners = []

    while True:
        line = str(readh.readline(MAX_LINESIZE), 'ascii')

        if not line: break

        def line_matches_command(cmd):
            # The control port language does not care about case for
            # commands.
            return re.match(r"^%s\b" % cmd, line, re.IGNORECASE)

        # Check what it is
        if line_matches_command("PROTOCOLINFO"):
            # Stem call PROTOCOLINFO before authenticating. Tell the
            # client that there is no authentication.
            respond("250-PROTOCOLINFO 1\r\n")
            respond("250-AUTH METHODS=NULL\r\n")
            respond("250-VERSION Tor=\"{}\"\r\n".format(controller.get_version()))
            respond("250 OK\r\n")

        elif line_matches_command("AUTHENTICATE"):
            # We have already authenticated, and the filtered port is
            # access-restricted to the allowed users via the firewall.
            respond("250 OK\r\n")

        # The client will be fooled that it is subscribing to all
        # events it requested, but we will only let through allowed
        # events.
        elif line_matches_command("SETEVENTS"):
            events = line.strip().split(' ')[1:]
            if len(events) > 0:
                for event in events:
                    if event in ALLOWED_EVENTS:
                        def event_cb(event):
                            respond(event.raw_content())
                        controller.add_event_listener(event_cb, ALLOWED_EVENTS[event])
                        subscribed_event_listeners.append(event_cb)
                respond("250 OK\r\n")
            else:
                for listener in subscribed_event_listeners:
                    controller.remove_event_listener(listener)
                subscribed_event_listeners = []
                respond("250 OK\r\n")

        else:
            cmd_allowed = False
            cmd, _, args = line.strip().partition(' ')
            cmd = cmd.upper()
            if cmd in ALLOWED_COMMANDS:
                allowed_args = ALLOWED_COMMANDS[cmd]
                if args == "":
                    if None in allowed_args:
                        cmd_allowed = True
                else:
                    cmd_allowed = any([re.match(args_regex + "$", args) for args_regex in allowed_args])
            if cmd_allowed:
                response = controller.msg(line.strip())
                respond(response.raw_content())
            else:
                respond("510 Command filtered\r\n")


class FilteredControlPortProxyHandler(socketserver.StreamRequestHandler):

    def connect_to_real_control_port(self):
        # Read authentication cookie
        with open("/var/run/tor/control.authcookie", "rb") as f:
            cookie = f.read(32)

        # Connect to the real control port
        controller = Controller.from_socket_file("/var/run/tor/control")
        try:
            controller.authenticate(cookie)
        except SocketError:
            raise UnexpectedAnswer("AUTHENTICATE failed")

        return controller

    def handle(self):
        controller = self.connect_to_real_control_port()
        try:
            handle_controlport_session(controller, self.rfile, self.wfile)
        finally:
            controller.close()


def main():
    listen_port = 9052
    server = socketserver.ThreadingTCPServer(("localhost", listen_port),
                                             FilteredControlPortProxyHandler)
    print("Tor control port filter started, listening on %d" % listen_port)
    try:
        server.serve_forever()
    finally:
        server.server_close()


if __name__ == "__main__":
    main()
