#!/usr/bin/python3

# ATTENTION: Yes, this can be used as a backdoor, but only for an
# adversary with access to you *physical* serial port, which means
# that you are screwed any way.

import base64
import fcntl
import json
import os
import pwd
import signal
import subprocess
import sys
import systemd.daemon
import traceback

REMOTE_SHELL_DEV = '/dev/virtio-ports/org.tails.remote_shell.0'


def mk_switch_user_fn(uid, gid):
    def switch_user():
        os.setgid(gid)
        os.setuid(uid)
    return switch_user


def run_cmd_as_user(cmd, user):
    pwd_user = pwd.getpwnam(user)
    switch_user_fn = mk_switch_user_fn(pwd_user.pw_uid,
                                       pwd_user.pw_gid)
    # We try to create an environment identical to what's expected
    # inside Tails for the user by logging in (via `su`) as the user,
    # setting up the GNOME shell environment, and extracting the
    # environment via `env`; not that we will run `env` unconditionally
    # since the former command could fail, e.g. if GNOME is not running.
    env_cmd = '. /usr/local/lib/tails-shell-library/gnome.sh && ' + \
              'export_gnome_env ; ' + \
              'env'
    wrapped_env_cmd = "su -c '{}' {}".format(env_cmd, user)
    pipe = subprocess.Popen(wrapped_env_cmd, stdout=subprocess.PIPE, shell=True)
    env_data = pipe.communicate()[0].decode('utf-8')
    env = dict((line.split('=', 1) for line in env_data.splitlines()))
    cwd = env['HOME']
    return subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        shell=True, env=env, cwd=cwd, preexec_fn=switch_user_fn
    )


def main():
    fd = os.open(REMOTE_SHELL_DEV, os.O_RDWR)
    port = open(fd, 'wb+', buffering=0)
    # In order to avoid busy-waiting when polling the above character
    # device for new data sent from clients, we borrow the approach used
    # by python-negotiator (https://github.com/xolox/python-negotiator):
    # We add O_ASYNC so a SIGIO signal is sent to us whenever data is
    # ready to be read from the device.
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_ASYNC)
    fcntl.fcntl(fd, fcntl.F_SETOWN, os.getpid())
    # By default receiving a SIGIO terminates the process so we override
    # it to do nothing instead.
    signal.signal(signal.SIGIO, lambda *args: None)

    # Notify systemd that we're ready
    systemd.daemon.notify('READY=1')
    systemd.daemon.notify('STATUS=Processing requests...\n')

    while True:
        # We can avoid an unnecessary delay of up to one second during the
        # first iteration of this loop; if a client sends a request
        # before we run SETOWN above, the expected signal never
        # reaches us, and we enter the loop and pass through the
        # conditional doomed to a full second of mournful waiting
        # for this lost signal. :_( By trying to read before we do a
        # timed wait for the signal, this delay is avoided.
        print("Reading...", file=sys.stderr)
        line = port.readline().decode('utf-8')
        if line == "":
            # In case the SIGIO gets lost for whatever reason
            # (e.g. the one mentioned above), let's always poll at
            # least once every second.
            signal.sigtimedwait([signal.SIGIO], 1)
            continue
        print("Got line", file=sys.stderr)
        try:
            id, cmd_type, *rest = json.loads(line)
            print("Line has id " + str(id), file=sys.stderr)
            print("Processing...", file=sys.stderr)
            ret = ""
            if cmd_type in ['call', 'spawn']:
                user, cmd = rest
                p = run_cmd_as_user(cmd, user)
                if cmd_type == "spawn":
                    returncode, stdout, stderr = 0, "", ""
                else:
                    stdout_b, stderr_b = p.communicate()
                    stdout = stdout_b.decode('utf-8')
                    stderr = stderr_b.decode('utf-8')
                    returncode = p.returncode
                ret = json.dumps([id, 'success', returncode, stdout, stderr])
            elif cmd_type in ['read', 'write', 'append']:
                path, *rest = rest
                open_mode = cmd_type[0] + 'b'
                with open(path, open_mode) as f:
                    if cmd_type == 'read':
                        assert(rest == [])
                        ret = str(base64.b64encode(f.read()), 'utf-8')
                    elif cmd_type in ['write', 'append']:
                        assert(len(rest) == 1)
                        data = base64.b64decode(rest[0])
                        ret = f.write(data)
                        if ret != len(data):
                            raise IOError("we only wrote {} bytes out of {}"
                                          .format(ret, len(data)))
                ret = json.dumps([id, 'success'] + [ret])
            else:
                raise ValueError("unknown command type")
            print("Done processing", file=sys.stderr)
            response = (ret + "\n").encode('utf-8')
            # We can only write 2**15 bytes at a time to the virtio channel
            # (seems to only affect the guest -> host direction).
            chunk_size = 2**15
            chunks = (response[0+i:chunk_size+i] for i in \
                      range(0, len(response), chunk_size))
            print("Sending response...", file=sys.stderr)
            for chunk in chunks:
                port.write(chunk)
            port.flush()
            print("Done sending response!", file=sys.stderr)
        except Exception as e:
            print("Error caught while processing line:", file=sys.stderr)
            print("    " + line, file=sys.stderr)
            print("The error was:", file=sys.stderr)
            traceback.print_exc(file=sys.stdout)
            print("-----", file=sys.stderr)
            sys.stderr.flush()
            exc_str = '{}: {}'.format(type(e).__name__, str(e))
            port.write(json.dumps([id, 'error', exc_str]).encode('utf-8') + b"\n")
            port.flush()
            continue

if __name__ == "__main__":
    main()
