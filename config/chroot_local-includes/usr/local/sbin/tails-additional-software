#!/usr/bin/env python3

import gettext
import json
import os
import os.path
import shutil
import subprocess
import sys
import syslog

import apt.cache
import atomicwrites

_ = gettext.gettext

LIVE_USERNAME = "amnesia"
PERSISTENCE_PARTITION = "/dev/disk/by-partlabel/TailsData"
PERSISTENCE_DIR = "/live/persistence/TailsData_unlocked"
PACKAGES_LIST_FILE = os.path.join(
    PERSISTENCE_DIR, "live-additional-software.conf")
ASP_STATE_DIR = "/run/live-additional-software"
ASP_STATE_PACKAGES = os.path.join(ASP_STATE_DIR, "packages")
ASP_STATE_INSTALLER_ASKED = os.path.join(ASP_STATE_DIR, "installer-asked")
OLD_APT_LISTS_DIR = os.path.join(PERSISTENCE_DIR, 'apt', 'lists.old')
APT_ARCHIVES_DIR = "/var/cache/apt/archives"
APT_LISTS_DIR = "/var/lib/apt/lists"


def _exit_if_in_live_build():
    """Exits with success if running inside live-build."""
    if "SOURCE_DATE_EPOCH" in os.environ:
        sys.exit(0)


def _launch_apt_get(specific_args):
    """Launch apt-get with given arguments.

    Launch apt-get with given arguments list, log its standard and error output
    and return its returncode."""
    apt_get_env = os.environ.copy()
    # The environnment provided in GDM PostLogin hooks doesn't contain /sbin/
    # which is required by dpkg. Let's use the default path for root in Tails.
    apt_get_env['PATH'] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:" \
                          "/usr/bin:/sbin:/bin"
    # We will log the output and want it in English when included in bug
    # reports
    apt_get_env['LANG'] = "C"
    apt_get_env['DEBIAN_PRIORITY'] = "critical"
    args = ["apt-get", "--quiet", "--yes"]
    args.extend(specific_args)
    apt_get = subprocess.Popen(args,
                               env=apt_get_env,
                               universal_newlines=True,
                               stderr=subprocess.STDOUT,
                               stdout=subprocess.PIPE)
    for line in iter(apt_get.stdout.readline, ''):
        if not line.startswith('('):
            syslog.syslog(line.rstrip())
    apt_get.wait()
    if apt_get.returncode:
        syslog.syslog(syslog.LOG_WARNING,
                      "apt-get exited with returncode %i" % apt_get.returncode)
    return apt_get.returncode


def _launch_persistence_setup(*args):
    """Launch tails-persistence-setup and wait for its completion."""
    display = os.environ["DISPLAY"]
    commandline = ["sudo",
                   "-u", "tails-persistence-setup",
                   "DISPLAY=" + display,
                   "tails-persistence-setup"
                   ]
    commandline.extend(args)
    subprocess.run(commandline, check=True)


def _notify(title, body="", accept_label="", deny_label="",
            documentation_target="", urgent=False, return_id=False):
    """Display a notification to the user of the live system.

    The notification will show title and body.

    If accept_label or deny_label are set, they will be shown on action buttons
    and the method will wait for user input and return 1 if the button with
    accept_label was clicked or 0 if the button with deny_label was
    clicked.

    If documentation_target is set, a "Documentation" action button will open
    corresponding tails documentation when clicked.

    If return_id is true, returns the notification ID, which may be used to
    close the notification.

    Else, return None.
    """

    cmd = "/usr/local/bin/tails-additional-software-notify"
    if urgent:
        urgent = "urgent"
    else:
        urgent = ""

    try:
        completed_process = subprocess.run(["sudo", "-u", LIVE_USERNAME, cmd,
                                            title, body, accept_label,
                                            deny_label, documentation_target,
                                            urgent],
                                           stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE,
                                           universal_newlines=True)
        if completed_process.returncode == 1:
            # sudo failed to execute the command
            raise OSError(completed_process.stderr)
    except OSError as e:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: unable to notify the user. %s" % e)
        syslog.syslog(syslog.LOG_WARNING,
                      "The notification was: %s %s" % (title, body))
        return None

    if return_id:
        for line in completed_process.stdout.splitlines():
            if line.startswith("id="):
                return line[3:]
    else:
        if completed_process.returncode == 0:
            return 1
        elif completed_process.returncode == 3:
            return 0
        else:
            return None


def _notify_failure(summary, details):
    """Display a failure notification to the user of the live system.

    The user has the option to edit the configuration of to view the system
    log.
    """
    action_clicked = _notify(summary, details, _("Show log"), _("Configure"),
                             urgent=True)
    if action_clicked == 1:
        show_configuration_window()
    elif action_clicked == 0:
        show_system_log()


def _close_notification(notification_id):
    """Close a notification shown to the user of the live system."""

    # XXX: hardcoded uid of amnesia user
    subprocess.run(
            ["sudo", "-u", LIVE_USERNAME,
             "DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus",
             "gdbus", "call",
             "--session",
             "--dest", "org.freedesktop.Notifications",
             "--object-path", "/org/freedesktop/Notifications",
             "--method", "org.freedesktop.Notifications.CloseNotification",
             str(notification_id)],
            stdout=subprocess.DEVNULL)


def has_persistence():
    """Return true iff PERSISTENCE_PARTITION exists."""
    return os.path.exists(PERSISTENCE_PARTITION)


def has_unlocked_persistence():
    """Return true iff PERSISTENCE_DIR exists."""
    return os.path.exists(PERSISTENCE_DIR)


def tails_media_is_writable():
    """Return true iff tails is started from a writable media."""
    # XXX: test if media is RW
    raise NotImplementedError


def has_additional_packages_list():
    """Return true iff PACKAGES_LIST_FILE exists."""
    return os.path.isfile(PACKAGES_LIST_FILE)


def get_additional_packages():
    """Return the list of all additional packages configured."""
    packages = set()
    if has_additional_packages_list():
        with open(PACKAGES_LIST_FILE) as f:
            for line in f:
                line = line.strip()
                if line:
                    packages.add(line)
    return packages


def delete_old_apt_lists(old_apt_lists_dir=OLD_APT_LISTS_DIR):
    """Delete the copy of the old APT lists, if any."""
    shutil.rmtree(old_apt_lists_dir)


def save_old_apt_lists(srcdir=APT_LISTS_DIR, destdir=OLD_APT_LISTS_DIR):
    """Save a copy of the APT lists"""
    if os.path.exists(destdir):
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: a copy of the APT lists already exists, "
                      "which should never happen. Removing it.")
        delete_old_apt_lists(destdir)
    shutil.copytree(srcdir, destdir, symlinks=True)


# Note: we can't do nicer delete + move operations because the directory
# we want to replace is bind-mounted. So we have to delete the content
# we want to replace, and then move the content we want to restore.
def restore_old_apt_lists(srcdir=OLD_APT_LISTS_DIR, dstdir=APT_LISTS_DIR):
    """Restore the copy of the old APT lists."""
    # Empty dstdir
    for basename in os.listdir(dstdir):
        path = os.path.join(dstdir, basename)
        if os.path.isfile(path):
            os.remove(path)
        elif os.path.isdir(path):
            shutil.rmtree(path)
    # Move the content of srcdir to dstdir
    for basename in os.listdir(srcdir):
        path = os.path.join(srcdir, basename)
        shutil.move(path, dstdir)


def handle_installed_packages(packages):
    """Configure packages as additional software packages if the user wants to.

    Ask the user if packages should be added to additional software, and
    actually add them if requested.
    """
    syslog.syslog("New packages manually installed: %s" % packages)
    if has_unlocked_persistence():
        if _notify(_("Add {packages} to your additional software?").format(
                    packages=" ".join(packages)),
                   _("To install it automatically from your persistent "
                     "storage every time you start Tails"),
                   _("Add to Persistent Storage"),
                   _("Install only once"),
                   urgent=True):
            setup_additional_packages()
            add_additional_packages(packages)
    elif has_persistence():
        # When a package is installed with a persistent storage locked, don't
        # show any notification.
        #
        # People who have a persistent storage but don't unlock it, probably do
        # this only sometimes and for a reason. They probably otherwise unlock
        # their persistent storage most of the time.
        #
        # If they install packages with their persistent storage locked, they
        # probably do it with their persistent storage unlock as well and would
        # learn about this feature when it's most relevant for them.
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: persistence storage is locked, can't add "
                      "additional software.")
    elif tails_media_is_writable():
        if _notify(_("Add {packages} to your additional software?").format(
                    packages=" ".join(packages)),
                   _("To install it automatically when starting Tails, you "
                     "can create a persistent storage and activate the "
                     "<b>Additional Software</b> feature"),
                   _("Create Persistent Storage"),
                   _("Install only once"),
                   urgent=True):
            create_persistence_and_setup_additional_packages(packages)
    else:   # It's impossible to have a persistent storage
        if not os.path.isfile(ASP_STATE_INSTALLER_ASKED):
            open(ASP_STATE_INSTALLER_ASKED, 'a').close()
            _notify(_("You could install {packages} automatically when "
                      "starting Tails").format(packages=" ".join(packages)),
                    _("To do so, you need to run Tails from a USB stick "
                      "installed using <i>Tails Installer</i>"),
                    urgent=True,
                    documentation_target="install/clone/")


def handle_removed_packages(packages):
    """Removes packages from additional software packages if the user wants to.

    Ask the user if packages should be removed from additional software, and
    actually remove them if requested.
    """
    syslog.syslog("Additional packages removed: %s" % packages)
    if _notify(_("Remove {packages} from your additional software?").format(
                 packages=" ".join(packages)),
               "",
               _("Remove"),
               _("Cancel"),
               urgent=True):
        remove_additional_packages(packages)


def add_additional_packages(new_packages):
    """Add packages to additional packages configuration.

    Add the packages to additional packages configuration.

    new_packages should be a list of packages names.
    """
    syslog.syslog("Adding to additional packages list: %s" % new_packages)
    packages = get_additional_packages()
    # The list of packages was initially provided by apt after installing them,
    # so we don't check the names.
    packages += new_packages

    with atomicwrites.atomic_write(PACKAGES_LIST_FILE, overwrite=True) as f:
        for package in sorted(packages):
            f.write(package + '\n')


def remove_additional_packages(old_packages):
    """Remove packages from additional packages configuration.

    Removes the packages from additional packages configuration.

    packages should be a list of packages names.
    """
    syslog.syslog("Removing from additional packages list: %s" % old_packages)
    packages = get_additional_packages()
    # The list of packages was initially provided by apt after removing them,
    # so we don't check the names.
    packages -= old_packages

    with atomicwrites.atomic_write(PACKAGES_LIST_FILE, overwrite=True) as f:
        for package in sorted(packages):
            f.write(package + '\n')


def setup_additional_packages():
    """Enable additional software in persistence."""
    _launch_persistence_setup("--no-gui",
                              "--no-display-finished-message",
                              "--force-enable-preset", "APT Packages",
                              "--force-enable-preset", "APT Lists")


def create_persistence_and_setup_additional_packages(packages):
    """Create persistence and add packages to its configuration.

    Create a new persistence with additional packages enabled.
    Then add the packages to additional packages configuration.

    packages should be a list of packages names.
    """
    # create persistence
    _launch_persistence_setup("--no-gui",
                              "--no-display-finished-message",
                              "--force-enable-preset", "APT Packages",
                              "--force-enable-preset", "APT Lists")
    add_additional_packages(packages)
    # show persistence configuration
    _launch_persistence_setup()


def show_configuration_window():
    """Show additional packages configuration window."""
    raise NotImplementedError


def show_system_log():
    """Show additional packages configuration window."""
    raise NotImplementedError


def apt_hook_pre():
    """Subcommand to handle Dpkg::Pre-Install-Pkgs."""
    _exit_if_in_live_build()

    syslog.syslog("Saving package changes")

    installed_packages = []
    removed_packages = []

    line = sys.stdin.readline()
    assert line.startswith("VERSION 3")
    line = sys.stdin.readline()
    # Ignore configuration space, which ends with an empty line
    while line != "\n":
        line = sys.stdin.readline()
    # Package action lines
    for line in sys.stdin:
        # Package action lines consist of five fields in Version 2: package
        # name (without architecture qualification even if foreign), old
        # version, direction of version change (< for upgrades, > for
        # downgrades, = for no change), new version, action. The version
        # fields are "-" for no version at all (for example when installing
        # a package for the first time; no version is treated as earlier
        # than any real version, so that is an upgrade, indicated as - <
        # 1.23.4). The action field is "**CONFIGURE**" if the package is
        # being configured, "**REMOVE**" if it is being removed, or the
        # filename of a .deb file if it is being unpacked.
        #
        # In Version 3 after each version field follows the architecture of
        # this version, which is "-" if there is no version, and a field
        # showing the MultiArch type "same", "foreign", "allowed" or "none".
        # Note that "none" is an incorrect typename which is just kept to
        # remain compatible, it should be read as "no" and users are
        # encouraged to support both.
        #
        # Example:
        #
        # colordif - - none < 1.0.16-1 all none **CONFIGURE**
        package_name, old_version, old_arch, old_multiarch, direction, \
                new_version, new_arch, new_multiarch, action = line.split()
        if action.endswith(".deb"):
            installed_packages.append(package_name)
        elif action.endswith("**REMOVE**"):
            removed_packages.append(package_name)

    result = {"installed": installed_packages, "removed": removed_packages}
    with open(ASP_STATE_PACKAGES, 'w') as f:
        json.dump(result, f)


def apt_hook_post():
    """Subcommand to handle Dpkg::Post-Invoke.

    Retrieve the list of packages saved by apt_hook_pre, filter packages not
    interesting and pass the resulting list to the appropriate method.
    """
    _exit_if_in_live_build()

    syslog.syslog("Examining package changes")

    with open(ASP_STATE_PACKAGES) as f:
        packages = json.load(f)
    os.remove(ASP_STATE_PACKAGES)

    apt_cache = apt.cache.Cache()
    # Filter automatically installed packages and packages already configured
    # as additional software
    new_manually_installed_packages = set(filter(
        lambda pkg: not apt_cache[pkg].is_auto_installed
                    and pkg not in get_additional_packages(),   # NOQA: E131
        set(packages["installed"])))
    if new_manually_installed_packages:
        handle_installed_packages(new_manually_installed_packages)

    # Filter non-additional software packages
    additional_packages_removed = set(packages["removed"]).intersection(
        get_additional_packages())
    if additional_packages_removed:
        handle_removed_packages(additional_packages_removed)


def install_additional_packages(ignore_old_apt_lists=False):
    """Subcommand which activates and installs all additional packages."""
    syslog.syslog("Starting to install additional software...")

    if has_additional_packages_list():
        syslog.syslog("Found additional packages list")
    else:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: no configuration file found, exiting")
        return True

    # If a copy of old APT lists is found, then the previous upgrade
    # attempt has not completed successfully (it may have failed e.g.
    # due to network problems, or it may have been interrupted).
    # In many of these cases, the APT package cache lacks some
    # packages the new APT lists reference, so the (offline)
    # installation step below in this function will fail. To avoid
    # that, we restore the old APT lists: there are greater chances
    # that the APT packages cache still has the corresponding packages.
    if os.path.isdir(OLD_APT_LISTS_DIR) and not ignore_old_apt_lists:
        syslog.syslog(syslog.LOG_WARNING,
                      "Found a copy of old APT lists, restoring it.")
        try:
            restore_old_apt_lists()
        except Exception as e:
            syslog.syslog(syslog.LOG_WARNING,
                          "Restoring old APT lists failed with %r, "
                          "deleting them and proceeding anyway." % e)
        # In all cases, delete the old APT lists: if they could be
        # restored we don't need them anymore (and we don't want to
        # restore them again next time); if they could not be
        # restored, chances are restoration will fail next time
        # as well.
        delete_old_apt_lists()

    packages = get_additional_packages()
    if not packages:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: no packages to install, exiting")
        return True
    installing_notification_id = _notify(
            _("Installing your additional software from persistent storage…"),
            _("This can take several minutes…"),
            return_id=True)
    syslog.syslog("Will install the following packages: %s"
                  % " ".join(packages))
    apt_get_returncode = _launch_apt_get(
        ["--no-remove",
         "--option", "DPkg::Options::=--force-confold",
         "install"] + list(packages))
    if apt_get_returncode:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: installation of %s failed"
                      % " ".join(packages))
        _notify_failure(_("The installation of your additional software "
                          "failed"),
                        _("Please check your list of additional software "
                          "packages or read the system log to understand "
                          "the problem."))
        return False
    else:
        syslog.syslog("Installation completed successfully.")
        _close_notification(installing_notification_id)
        # XXX: there should be a "Configure" button in this notification.
        # However, the easy way to implement it makes this process not return
        # until the notification is clicked. The notification process could be
        # detached, and handle the "configure" action itself.
        #  if _notify(_("Additional software installed successfully"),
        #             accept_label=_("Configure")):
        #      show_configuration_window()
        _notify(_("Additional software installed successfully"))
        return True


def upgrade_additional_packages():
    """Subcommand which upgrades all additional packages."""
    # Save a copy of APT lists that we'll delete only once the upgrade
    # has succeeded, to ensure that the APT packages cache is up-to-date
    # wrt. the APT lists.
    syslog.syslog("Saving old APT lists...")
    save_old_apt_lists()

    syslog.syslog("Starting to upgrade additional software...")
    apt_get_returncode = _launch_apt_get(["update"])
    if apt_get_returncode:
        syslog.syslog(syslog.LOG_WARNING, "Warning: the update failed.")
        _notify_failure(_("The upgrade of your additional software failed"),
                        _("The check for upgrades failed. Please check your "
                          "network connection, restart Tails, or read the "
                          "system log to understand the problem."))
        return False
    if install_additional_packages(ignore_old_apt_lists=True):
        syslog.syslog("The upgrade was successful.")
    else:
        _notify_failure(_("The upgrade of your additional software failed"),
                        _("The upgrade failed. Please check your network "
                          "connection, restart Tails, or read the system "
                          "log to understand the problem."))
        return False

    # We now know that the APT packages cache is up-to-date wrt. the APT lists,
    # so we can delete the copy of the old lists
    delete_old_apt_lists()

    # Remove outdated packages from the local package cache. This is needed as
    # we disable apt-daily.timer, which would else take care of this cleanup.
    # We do this after the upgrade has succeeded so that the old packages
    # remain available in the cache in case we have to restore the old lists.
    # In the past we did this before upgrading in order to remove the
    # i386 packages from the cache before downloading amd64 ones, but
    # this does not matter anymore now that all persistent volumes
    # must have been upgraded already.
    apt_get_returncode = _launch_apt_get(["autoclean"])
    if apt_get_returncode:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: autoclean failed.")
    return True


def print_help():
    """Subcommand which displays help."""
    sys.stderr.write("Usage: %s <subcommand>\n" % program_name)
    sys.stderr.write("""Subcommands:
    install: install additional software
    upgrade: upgrade additional software\n""")


if __name__ == "__main__":
    program_name = os.path.basename(sys.argv[0])

    syslog.openlog("%s[%i]" % (program_name, os.getpid()))
    gettext.install("tails")

    if len(sys.argv) < 2:
        print_help()
        sys.exit(2)

    if sys.argv[1] == "install":
        if not install_additional_packages():
            sys.exit(150)
    elif sys.argv[1] == "upgrade":
        if not upgrade_additional_packages():
            sys.exit(151)
    elif sys.argv[1] == "apt-pre":
        apt_hook_pre()
    elif sys.argv[1] == "apt-post":
        apt_hook_post()
    else:
        print_help()
        sys.exit(2)
