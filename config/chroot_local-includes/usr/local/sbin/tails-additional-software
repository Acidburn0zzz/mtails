#!/usr/bin/env python3

import gettext
import json
import os
import os.path
import shutil
import stat
import subprocess
import sys
import syslog

import apt.cache

_ = gettext.gettext

LIVE_USERNAME = "amnesia"
PERSISTENCE_PARTITION = "/dev/disk/by-partlabel/TailsData"
PERSISTENCE_DIR = "/live/persistence/TailsData_unlocked"
PACKAGES_LIST_FILE = os.path.join(
    PERSISTENCE_DIR, "live-additional-software.conf")
ASP_STATE_DIR = "/var/run/live-additional-software"
ASP_STATE_PACKAGES = os.path.join(ASP_STATE_DIR, "packages")
ASP_STATE_INSTALLER_ASKED = os.path.join(ASP_STATE_DIR, "installer-asked")
OLD_APT_LISTS_DIR = os.path.join(PERSISTENCE_DIR, 'apt', 'lists.old')
APT_ARCHIVES_DIR = "/var/cache/apt/archives"
APT_LISTS_DIR = "/var/lib/apt/lists"


def _launch_apt_get(specific_args):
    """Launch apt-get with given arguments.

    Launch apt-get with given arguments list, log its standard and error output
    and return its returncode."""
    apt_get_env = os.environ.copy()
    # The environnment provided in GDM PostLogin hooks doesn't contain /sbin/
    # which is required by dpkg. Let's use the default path for root in Tails.
    apt_get_env['PATH'] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:" \
                          "/usr/bin:/sbin:/bin"
    # We will log the output and want it in English when included in bug
    # reports
    apt_get_env['LANG'] = "C"
    apt_get_env['DEBIAN_PRIORITY'] = "critical"
    args = ["apt-get", "--quiet", "--yes"]
    args.extend(specific_args)
    apt_get = subprocess.Popen(args,
                               env=apt_get_env,
                               universal_newlines=True,
                               stderr=subprocess.STDOUT,
                               stdout=subprocess.PIPE)
    for line in iter(apt_get.stdout.readline, ''):
        if not line.startswith('('):
            syslog.syslog(line.rstrip())
    apt_get.wait()
    if apt_get.returncode:
        syslog.syslog(syslog.LOG_WARNING,
                      "apt-get exited with returncode %i" % apt_get.returncode)
    return apt_get.returncode


def _notify(title, body, accept_label="", deny_label="", urgent=False,
            return_id=False):
    """Display a notification to the user of the live system."""

    cmd = "/usr/local/bin/tails-additional-software-notify"
    if urgent:
        urgent = "urgent"
    else:
        urgent = ""

    try:
        completed_process = subprocess.run(["sudo", "-u", LIVE_USERNAME, cmd,
                                            title, body, accept_label,
                                            deny_label, urgent],
                                           stdout=subprocess.PIPE)

    except OSError as e:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: unable to notify the user. %s" % e)
        syslog.syslog(syslog.LOG_WARNING,
                      "The notification was: %s %s" % (title, body))
        raise

    if return_id:
        for line in completed_process.stdout.decode().splitlines():
            if line.startswith("id="):
                return line[3:]
    else:
        if completed_process.returncode == 0:
            return True
        elif completed_process.returncode == 1:
            return False
        elif completed_process.returncode == 3:
            return None
        else:
            raise OSError()


def _notify_failure(summary, details):
    """Display a failure notification to the user of the live system.

    The user has the option to edit the configuration of to view the system
    log.
    """
    if _notify(summary, details, _("Show log"), _("Configure"), urgent=True):
        show_configuration_window()
    else:
        show_system_log()


def _close_notification(notification_id):
    """Close a notification shown to the user of the live system."""

    # XXX: hardcoded uid of amnesia user
    subprocess.run(
            ["sudo", "-u", LIVE_USERNAME,
             "DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus",
             "gdbus", "call",
             "--session",
             "--dest", "org.freedesktop.Notifications",
             "--object-path", "/org/freedesktop/Notifications",
             "--method", "org.freedesktop.Notifications.CloseNotification",
             str(notification_id)],
            stdout=subprocess.DEVNULL)


def _has_permissions(directory, mode, uid, gid):
    """Return true iff file has mode and belongs to uid and gid."""
    stat_result = os.stat(directory)
    return (stat.S_IMODE(stat_result.st_mode) == mode
            and stat_result.st_uid == uid
            and stat_result.st_gid == gid)


def _create_or_fix_dir(directory, mode, uid, gid):
    """Create directory if needed or fixes its mode, uid and gid."""
    try:
        os.mkdir(directory, mode=mode)
    except FileExistsError:
        pass
    os.chown(directory, uid, gid)
    os.chmod(directory, mode)


def has_persistence():
    """Return true iff PERSISTENCE_PARTITION exists."""
    return os.path.exists(PERSISTENCE_PARTITION)


def has_unlocked_persistence():
    """Return true iff PERSISTENCE_DIR exists."""
    return os.path.exists(PERSISTENCE_DIR)


def tails_media_is_writable():
    """Return true iff tails is started from a writable media."""
    # XXX: test if media is RW
    raise NotImplementedError


def has_additional_packages_list():
    """Return true iff PACKAGES_LIST_FILE exists."""
    return os.path.isfile(PACKAGES_LIST_FILE)


def get_additional_packages():
    """Return the list of all additional packages configured."""
    packages = []
    if has_additional_packages_list():
        with open(PACKAGES_LIST_FILE) as f:
            for line in f:
                line = line.strip()
                if line:
                    packages.append(line)
    return packages


def delete_old_apt_lists(old_apt_lists_dir=OLD_APT_LISTS_DIR):
    """Delete the copy of the old APT lists, if any."""
    shutil.rmtree(old_apt_lists_dir)


def save_old_apt_lists(srcdir=APT_LISTS_DIR, destdir=OLD_APT_LISTS_DIR):
    """Save a copy of the APT lists"""
    if os.path.exists(destdir):
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: a copy of the APT lists already exists, "
                      "which should never happen. Removing it.")
        delete_old_apt_lists(destdir)
    shutil.copytree(srcdir, destdir, symlinks=True)


# Note: we can't do nicer delete + move operations because the directory
# we want to replace is bind-mounted. So we have to delete the content
# we want to replace, and then move the content we want to restore.
def restore_old_apt_lists(srcdir=OLD_APT_LISTS_DIR, dstdir=APT_LISTS_DIR):
    """Restore the copy of the old APT lists."""
    # Empty dstdir
    for basename in os.listdir(dstdir):
        path = os.path.join(dstdir, basename)
        if os.path.isfile(path):
            os.remove(path)
        elif os.path.isdir(path):
            shutil.rmtree(path)
    # Move the content of srcdir to dstdir
    for basename in os.listdir(srcdir):
        path = os.path.join(srcdir, basename)
        shutil.move(path, dstdir)


def handle_installed_packages(packages):
    """Configure packages as additional software packages if the user wants to.

    Ask the user if packages should be added to additional software, and
    actually add them if requested.
    """
    syslog.syslog("New packages manually installed: %s" % packages)
    if has_unlocked_persistence():
        if _notify(_("Add {packages} to your additional software?").format(
                    packages=" ".join(packages)),
                   _("To install it automatically from your persistent "
                     "storage every time you start Tails"),
                   _("Add to Persistent Storage"),
                   _("Install only once"),
                   urgent=True):
            if has_additional_packages_list():
                add_additional_packages(packages)
            else:
                setup_additional_packages()
                add_additional_packages(packages)
    elif has_persistence():
        # When a package is installed with a persistent storage locked, don't
        # show any notification.
        #
        # People who have a persistent storage but don't unlock it, probably do
        # this only sometimes and for a reason. They probably otherwise unlock
        # their persistent storage most of the time.
        #
        # If they install packages with their persistent storage locked, they
        # probably do it with their persistent storage unlock as well and would
        # learn about this feature when it's most relevant for them.
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: persistence storage is locked, can't add "
                      "additional software.")
    elif tails_media_is_writable():
        if _notify(_("Add {packages} to your additional software?").format(
                    packages=" ".join(packages)),
                   _("To install it automatically when starting Tails, you "
                     "can create a persistent storage and activate the "
                     "<b>Additional Software</b> feature"),
                   _("Create Persistent Storage"),
                   _("Install only once"),
                   urgent=True):
            create_persistence_and_setup_additional_packages(packages)
    else:   # It's impossible to have a persistent storage
        if not os.path.isfile(ASP_STATE_INSTALLER_ASKED):
            _create_or_fix_dir(ASP_STATE_DIR, 0o750, 0, 0)
            open(ASP_STATE_INSTALLER_ASKED, 'a').close()
            if _notify(_("You could install {packages} automatically when "
                         "starting Tails").format(packages=" ".join(packages)),
                       _("To do so, you need to run Tails from a USB stick "
                         "installed using <i>Tails Installer</i>"),
                       _("Documentation"),
                       urgent=True):
                # XXX: open the right documentation
                raise NotImplementedError


def handle_removed_packages(packages):
    """Removes packages from additional software packages if the user wants to.

    Ask the user if packages should be removed from additional software, and
    actually remove them if requested.
    """
    syslog.syslog("Additional packages removed: %s" % packages)
    if _notify(_("Remove {packages} from your additional software?").format(
                 packages=" ".join(packages)),
               "",
               _("Remove"),
               _("Cancel"),
               urgent=True):
        remove_additional_packages(packages)


def add_additional_packages(new_packages):
    """Add packages to additional packages configuration.

    Add the packages to additional packages configuration.

    new_packages should be a list of packages names.
    """
    syslog.syslog("Adding to additional packages list: %s" % new_packages)
    packages = get_additional_packages()
    # The list of packages was initially provided by apt after installing them,
    # so we don't check the names.
    if packages:
        packages += new_packages
    else:
        packages = list(new_packages)
    packages.sort()
    with open(PACKAGES_LIST_FILE, 'w') as f:
        for package in packages:
            f.write(package + '\n')


def setup_additional_packages():
    """Enable additional software in persistence."""
    raise NotImplementedError


def create_persistence_and_setup_additional_packages(packages):
    """Create persistence and add packages to its configuration.

    Create a new persistence with additional packages enabled.
    Then add the packages to additional packages configuration.

    packages should be a list of packages names.
    """
    raise NotImplementedError


def remove_additional_packages(packages):
    """Remove packages from additional packages configuration.

    Removes the packages from additional packages configuration.

    packages should be a list of packages names.
    """
    raise NotImplementedError


def show_configuration_window():
    """Show additional packages configuration window."""
    raise NotImplementedError


def show_system_log():
    """Show additional packages configuration window."""
    raise NotImplementedError


def apt_hook_pre():
    """Subcommand to handle Dpkg::Pre-Install-Pkgs."""
    syslog.syslog("Saving package changes")

    installed_packages = []
    removed_packages = []

    line = sys.stdin.readline()
    assert line.startswith("VERSION 3")
    line = sys.stdin.readline()
    # Ignore configuration space, which ends with an empty line
    while line != "\n":
        line = sys.stdin.readline()
    # Package action lines
    for line in sys.stdin:
        # Package action lines consist of five fields in Version 2: package
        # name (without architecture qualification even if foreign), old
        # version, direction of version change (< for upgrades, > for
        # downgrades, = for no change), new version, action. The version
        # fields are "-" for no version at all (for example when installing
        # a package for the first time; no version is treated as earlier
        # than any real version, so that is an upgrade, indicated as - <
        # 1.23.4). The action field is "**CONFIGURE**" if the package is
        # being configured, "**REMOVE**" if it is being removed, or the
        # filename of a .deb file if it is being unpacked.
        #
        # In Version 3 after each version field follows the architecture of
        # this version, which is "-" if there is no version, and a field
        # showing the MultiArch type "same", "foreign", "allowed" or "none".
        # Note that "none" is an incorrect typename which is just kept to
        # remain compatible, it should be read as "no" and users are
        # encouraged to support both.
        #
        # Example:
        #
        # colordif - - none < 1.0.16-1 all none **CONFIGURE**
        package_name, old_version, old_arch, old_multiarch, direction, \
                new_version, new_arch, new_multiarch, action = line.split()
        if action.endswith(".deb"):
            installed_packages.append(package_name)
        elif action.endswith("**REMOVE**"):
            removed_packages.append(package_name)

    result = {"installed": installed_packages, "removed": removed_packages}
    _create_or_fix_dir(ASP_STATE_DIR, 0o750, 0, 0)
    with open(ASP_STATE_PACKAGES, 'w') as f:
        json.dump(result, f)


def apt_hook_post():
    """Subcommand to handle Dpkg::Post-Invoke.

    Retrieve the list of packages saved by apt_hook_pre, filter packages not
    interesting and pass the resulting list to the appropriate method.
    """
    syslog.syslog("Examining package changes")

    # XXX: TOCTOU?
    if not _has_permissions(ASP_STATE_DIR, 0o750, 0, 0):
        syslog.syslog(syslog.LOG_ERR,
                      "Wrong permissions for {}, ignoring "
                      "it.".format(ASP_STATE_DIR))
        sys.exit(1)
    with open(ASP_STATE_PACKAGES) as f:
        packages = json.load(f)
    os.remove(ASP_STATE_PACKAGES)

    apt_cache = apt.cache.Cache()
    # Filter automatically installed packages and packages already configured
    # as additional software
    new_manually_installed_packages = set(filter(
        lambda pkg: not apt_cache[pkg].is_auto_installed
                    and pkg not in get_additional_packages(),   # NOQA: E131
        set(packages["installed"])))
    if new_manually_installed_packages:
        handle_installed_packages(new_manually_installed_packages)

    # Filter non-additional software packages
    additional_packages_removed = set(packages["removed"]).intersection(
        get_additional_packages())
    if additional_packages_removed:
        handle_removed_packages(additional_packages_removed)


def install_additional_packages(ignore_old_apt_lists=False):
    """Subcommand which activates and installs all additional packages."""
    syslog.syslog("Starting to install additional software...")

    if has_additional_packages_list():
        syslog.syslog("Found additional packages list")
    else:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: no configuration file found, exiting")
        return True

    # If a copy of old APT lists is found, then the previous upgrade
    # attempt has not completed successfully (it may have failed e.g.
    # due to network problems, or it may have been interrupted).
    # In many of these cases, the APT package cache lacks some
    # packages the new APT lists reference, so the (offline)
    # installation step below in this function will fail. To avoid
    # that, we restore the old APT lists: there are greater chances
    # that the APT packages cache still has the corresponding packages.
    if os.path.isdir(OLD_APT_LISTS_DIR) and not ignore_old_apt_lists:
        syslog.syslog(syslog.LOG_WARNING,
                      "Found a copy of old APT lists, restoring it.")
        try:
            restore_old_apt_lists()
        except Exception as e:
            syslog.syslog(syslog.LOG_WARNING,
                          "Restoring old APT lists failed with %r, "
                          "deleting them and proceeding anyway." % e)
        # In all cases, delete the old APT lists: if they could be
        # restored we don't need them anymore (and we don't want to
        # restore them again next time); if they could not be
        # restored, chances are restoration will fail next time
        # as well.
        delete_old_apt_lists()

    packages = get_additional_packages()
    if not packages:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: no packages to install, exiting")
        return True
    installing_notification_id = _notify(
            _("Installing your additional software from persistent storage…"),
            _("This can take several minutes…"),
            return_id=True)
    syslog.syslog("Will install the following packages: %s"
                  % " ".join(packages))
    apt_get_returncode = _launch_apt_get(
        ["--no-remove",
         "--option", "DPkg::Options::=--force-confold",
         "install"] + packages)
    if apt_get_returncode:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: installation of %s failed"
                      % " ".join(packages))
        _notify_failure(_("The installation of your additional software "
                          "failed"),
                        _("Please check your list of additional software "
                          "packages or read the system log to understand "
                          "the problem."))
        return False
    else:
        syslog.syslog("Installation completed successfully.")
        _close_notification(installing_notification_id)
        if _notify(_("Additional software installed successfully"),
                   "",
                   _("Configure")):
            show_configuration_window()
        return True


def upgrade_additional_packages():
    """Subcommand which upgrades all additional packages."""
    # Save a copy of APT lists that we'll delete only once the upgrade
    # has succeeded, to ensure that the APT packages cache is up-to-date
    # wrt. the APT lists.
    syslog.syslog("Saving old APT lists...")
    save_old_apt_lists()

    syslog.syslog("Starting to upgrade additional software...")
    apt_get_returncode = _launch_apt_get(["update"])
    if apt_get_returncode:
        syslog.syslog(syslog.LOG_WARNING, "Warning: the update failed.")
        _notify_failure(_("The upgrade of your additional software failed"),
                        _("The check for upgrades failed. Please check your "
                          "network connection, restart Tails, or read the "
                          "system log to understand the problem."))
        return False
    if install_additional_packages(ignore_old_apt_lists=True):
        syslog.syslog("The upgrade was successful.")
    else:
        _notify_failure(_("The upgrade of your additional software failed"),
                        _("The upgrade failed. Please check your network "
                          "connection, restart Tails, or read the system "
                          "log to understand the problem."))
        return False

    # We now know that the APT packages cache is up-to-date wrt. the APT lists,
    # so we can delete the copy of the old lists
    delete_old_apt_lists()

    # Remove outdated packages from the local package cache. This is needed as
    # we disable apt-daily.timer, which would else take care of this cleanup.
    # We do this after the upgrade has succeeded so that the old packages
    # remain available in the cache in case we have to restore the old lists.
    # In the past we did this before upgrading in order to remove the
    # i386 packages from the cache before downloading amd64 ones, but
    # this does not matter anymore now that all persistent volumes
    # must have been upgraded already.
    apt_get_returncode = _launch_apt_get(["autoclean"])
    if apt_get_returncode:
        syslog.syslog(syslog.LOG_WARNING,
                      "Warning: autoclean failed.")
    return True


def print_help():
    """Subcommand which displays help."""
    sys.stderr.write("Usage: %s <subcommand>\n" % program_name)
    sys.stderr.write("""Subcommands:
    install: install additional software
    upgrade: upgrade additional software\n""")


if __name__ == "__main__":
    program_name = os.path.basename(sys.argv[0])

    syslog.openlog("%s[%i]" % (program_name, os.getpid()))
    gettext.install("tails")

    if len(sys.argv) < 2:
        print_help()
        sys.exit(2)

    if sys.argv[1] == "install":
        if not install_additional_packages():
            sys.exit(150)
    elif sys.argv[1] == "upgrade":
        if not upgrade_additional_packages():
            sys.exit(151)
    elif sys.argv[1] == "apt-pre":
        apt_hook_pre()
    elif sys.argv[1] == "apt-post":
        apt_hook_post()
    else:
        print_help()
        sys.exit(2)
