#! /usr/bin/env python3
"""
Debug Tails.

Test with "python3 tails-debugging-info.py doctest" as root.

goodcrypto.com converted from bash to python and added basic tests.

*** WARNING about debug_file and debug_directory *********************

Great attention must be given to the ownership situation of these
files and their parent directories in order to avoid a symlink-based
attack that could read the contents of any file and make it
accessible to the user running this script (typically the live
user). Therefore, when adding a new file, give as the first argument
'root' only if the complete path to it (including the file itself)
is owned by root and already exists before the system is connected to
the network (that is, before GDM's PostLogin script is run).
If not, the following rules must be followed strictly:

* only one non-root user is involved in the ownership situation (the
  file, its dir and the parent dirs). From now on let's assume it is
  the case and call it $USER.

* if any non-root group has write access, it must not have any
  members.

If any of these rules does not apply, the file cannot be added here
safely and something is probably quite wrong and should be
investigated carefully.

>>> # run script
>>> import sh
>>> this_command = sh.Command(sys.argv[0])
>>> this_command()
<BLANKLINE>
...
"""

import json
import os
import sys
import subprocess
from collections import OrderedDict
from pwd import getpwuid


# AppArmor Ux rules don't sanitize PATH, which can lead to an
# exploited application (that's allowed to run this script unconfined)
# having this script run arbitrary code, violating that application's
# confinement. Let's prevent that by setting PATH to a list of
# directories where only root can write.
os.environ['PATH'] = '/usr/local/bin:/usr/bin:/bin'


def main():
    """Print debug information serialized as json.

    >>> main()
    <BLANKLINE>
    ...
    """

    info = []
    info.append(debug_file('root', '/proc/cmdline'))

    # General hardware and filesystems information
    info.append(debug_command('/usr/sbin/dmidecode', '-s', 'system-manufacturer'))
    info.append(debug_command('/usr/sbin/dmidecode', '-s', 'system-product-name'))
    info.append(debug_command('/usr/sbin/dmidecode', '-s', 'system-version'))
    info.append(debug_command('/usr/bin/lspci', '-nn'))
    info.append(debug_command('/bin/df', '--human-readable', '--print-type'))
    info.append(debug_command('/bin/mount', '--show-labels'))
    info.append(debug_command('/bin/lsmod'))
    info.append(debug_file('root', '/proc/asound/cards'))
    info.append(debug_file('root', '/proc/asound/devices'))
    info.append(debug_file('root', '/proc/asound/modules'))

    # Miscellaneous configuration and log files
    info.append(debug_file('root', '/etc/X11/xorg.conf'))
    info.append(debug_file('Debian-gdm', '/var/log/gdm3/tails-greeter.errors'))
    info.append(debug_file('root', '/var/log/live/boot.log'))
    info.append(debug_file('root', '/var/log/live/config.log'))
    info.append(debug_file('root', '/var/lib/live/config/tails.physical_security'))

    # Persistence
    info.append(debug_file('root', '/var/lib/gdm3/tails.persistence'))
    info.append(debug_file('tails-persistence-setup',
                           '/live/persistence/TailsData_unlocked/persistence.conf'))
    info.append(debug_file('tails-persistence-setup',
                           '/live/persistence/TailsData_unlocked/live-additional-software.conf'))
    info.append(debug_directory('root',
                                '/live/persistence/TailsData_unlocked/apt-sources.list.d'))
    info.append(debug_file('root', '/var/log/live-persist'))

    # The Journal
    info.append(debug_command('/bin/journalctl', '--catalog', '--no-pager'))

    print()
    print(json.dumps(info))


def debug_command(command, *args):
    """Return the command and it's standard input as dict.

    >>> debug_command('echo', 'foo')
    {'echo foo': ['foo']}
    """
    command_output = subprocess.check_output([command, *args])
    command_output = command_output.decode('UTF-8').strip().split('\n')
    return {'{}'.format(' '.join((command,) + args)): command_output}


def debug_file(user, filename):
    """Return the filename and the file content as dict.

    >>> import tempfile, getpass
    >>> with tempfile.NamedTemporaryFile('w') as f:
    ...     _ = f.write("foo\\nbar")
    ...     _ = f.seek(0)
    ...     debug_file(getpass.getuser(), f.name)
    {...: ['foo', 'bar']}
    """
    if not os.path.isfile(filename):
        return {filename: 'Not found'}

    # This check is not sufficient, see the comment at the top of the file
    # for the complete requirements required for security
    owner = getpwuid(os.stat(filename).st_uid).pw_name
    if owner != user:
        return {filename: '''WARNING: not opening file {}, because it is '''
                          '''owned by {} instead of {}'''.format(filename, owner, user)}

    file_content = []
    with open(filename) as f:
        for l in f:
            file_content.append(l.replace('\n', ''))
    return {filename: file_content}


def debug_directory(user, dir_name):
    """Return a dict with the dir_name and dicts with
    the content of all contained files (non-recursively).

    >>> import os, getpass
    >>> tmpdir = '/tmp/mytempdir'
    >>> os.makedirs(tmpdir)
    >>> with open(os.path.join(tmpdir, 'foo'), 'w') as f:
    ...     _ = f.write("foobar\\nbar")
    ...     _ = f.seek(0)
    ...     result = debug_directory(getpass.getuser(), tmpdir)
    >>> os.remove(os.path.join(tmpdir, 'foo'))
    >>> os.rmdir(tmpdir)
    >>> result
    {'/tmp/mytempdir': [{'/tmp/mytempdir/foo': ['foobar', 'bar']}]}
    """
    if not os.path.isdir(dir_name):
        return {dir_name: 'Not found'}

    # This check is not sufficient, see the comment at the top of the file
    # for the complete requirements required for security
    owner = getpwuid(os.stat(dir_name).st_uid).pw_name
    if owner != user:
        return {dir_name: '''WARNING: not opening directory {}, because it is '''
                          '''owned by {} instead of {}'''.format(dir_name, owner, user)}

    files = os.listdir(dir_name)

    listing = []

    for f in files:
        listing.append(debug_file(user, os.path.join(dir_name, f)))
    return {dir_name: listing}


if __name__ == '__main__':
    if sys.argv and len(sys.argv) > 1:
        if sys.argv[1] == 'doctest':
            import doctest
            doctest.testmod(optionflags=doctest.ELLIPSIS)
        else:
            main()
    else:
        main()
