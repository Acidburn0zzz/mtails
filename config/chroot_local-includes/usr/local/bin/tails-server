#!/usr/bin/env python3

import os
import logging
import collections
import argparse
import sh
import abc

from tails_server import dbus_interface
from tails_server import config
from tails_server import util
import tails_server.services

from gi.repository import Gtk, GLib, Gdk, GObject

DATA_DIR = config.DATA_DIR
ICON_DIR = os.path.join(DATA_DIR, "icons")
MAIN_UI_FILE = os.path.join(DATA_DIR, "gui", "tails_server.ui")
CONFIG_UI_FILE = os.path.join(DATA_DIR, "gui", "service_config.ui")
SERVICE_CHOOSER_UI_FILE = os.path.join(DATA_DIR, "gui", "service_chooser.ui")
LOADING_WINDOW_UI_FILE = os.path.join(DATA_DIR, "gui", "loading_window.ui")
STATUS_UI_FILE = os.path.join(DATA_DIR, "gui", "status.ui")
SERVICE_LIST_UI_FILE = os.path.join(DATA_DIR, "gui", "service_list.ui")

sh.ErrorReturnCode.truncate_cap = 5000

service_modules_dict = tails_server.services.import_service_modules()


class ServiceDecorator(object):

    status_row = None
    _config_panel = None

    @property
    def config_panel(self):
        if not self._config_panel:
            logging.debug("Instantiating config panel for service %r", self.service.name)
            try:
                self._config_panel = ServiceConfigPanel(self.gui, self)
            except AttributeError as e:
                # XXX: This is a workaround for a bug in Python which blames all AttributeErrors on
                # __getattr__, if a custom __getattr__ was defined.
                raise Exception(e)
        return self._config_panel

    def __init__(self, gui, service):
        self.gui = gui
        self.service = service
        self.status = ServiceStatus(self)

    def __getattr__(self, item):
        return getattr(self.service, item)

    def install(self):
        self.status.emit("update", ServiceStatus.STATUS_INSTALLING)
        self.service.install()
        self.status.emit("update", ServiceStatus.STATUS_OFFLINE)
        GLib.idle_add(self.config_panel.populate_option_rows)

    def uninstall(self):
        if self.service.is_running:
            self.service.disable()
        self.status.emit("update", ServiceStatus.STATUS_UNINSTALLING)
        self._config_panel = None
        self.stop_status_monitor()
        self.service.uninstall()

    def enable(self):
        self.status.emit("update", ServiceStatus.STATUS_STARTING)
        self.service.enable(skip_add_onion=True)
        self.add_onion()

    def add_onion(self):
        self.status.emit("update", ServiceStatus.STATUS_PUBLISHING)
        self.service.add_onion()
        self.status.emit("update", ServiceStatus.STATUS_ONLINE)

    def activate_status_monitor(self):
        self.status.dbus_monitor.run()

    def stop_status_monitor(self):
        self.status.dbus_monitor.stop()


class OptionRow(object, metaclass=abc.ABCMeta):
    known_options_widgets = {
        "persistence": ("label_persistence", "box_persistence", "checkbutton_persistence"),
        "autostart": ("label_autostart", "box_autostart", "checkbutton_autostart"),
        # "allow-lan": ("label_allow_lan", "box_allow_lan", "checkbutton_allow_lan"),
    }

    @property
    def sensitive(self):
        return self.box.get_sensitive()

    @sensitive.setter
    def sensitive(self, value):
        self.box.set_sensitive(value)

    @property
    def value(self):
        if self.option.type == str:
            return self.value_widget.get_text()
        elif self.option.type == int:
            return int(self.value_widget.get_text())
        elif self.option.type == bool:
            return self.value_widget.get_active()

    @classmethod
    def create(cls, config_panel, option):
        if option.name in cls.known_options_widgets:
            return KnownOptionRow(config_panel, option)
        if option.type in [str, int]:
            return EditableOptionRow(config_panel, option)
        if option.type == bool:
            return BooleanOptionRow(config_panel, option)
        raise TypeError("Can't display option %r of type %r", option.name, option.type)

    def __init__(self, config_panel, option):
        self.config_panel = config_panel
        self.option = option
        logging.debug("Adding option %r to GUI", option.name)
        self.value_widget = None
        self.label = None
        self.box = None

    def show(self):
        self.label.show_all()
        self.box.show_all()


class KnownOptionRow(OptionRow):
    def __init__(self, config_panel, option):
        super().__init__(config_panel, option)
        label, box, value_widget = self.known_options_widgets[option.name]
        self.label = self.config_panel.builder.get_object(label)
        self.label.unparent()
        self.box = self.config_panel.builder.get_object(box)
        self.box.unparent()
        self.value_widget = self.config_panel.builder.get_object(value_widget)
        self.config_panel.builder.connect_signals(self.config_panel)


class UnknownOptionRow(OptionRow):
    def __init__(self, config_panel, option):
        super().__init__(config_panel, option)
        self.box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        self.label = Gtk.Label(option.name_in_gui)
        self.label.set_alignment(xalign=1, yalign=0.5)
        self.label.set_sensitive(False)


class BooleanOptionRow(UnknownOptionRow):
    @property
    def value(self):
        return self.value_widget.get_active()

    def __init__(self, config_panel, option):
        super().__init__(config_panel, option)
        self.value_widget = Gtk.CheckButton()
        self.value_widget.set_active(option.value)
        self.box.pack_end(self.value_widget, expand=True, fill=True, padding=0)


class EditableOptionRow(UnknownOptionRow):
    def __init__(self, config_panel, option):
        super().__init__(config_panel, option)
        self.value_widget = Gtk.Entry(text=option.value)
        self.value_widget.set_text(str(option.value))
        self.box.pack_end(self.value_widget, expand=True, fill=True, padding=0)


class ServiceStatus(Gtk.Widget):

    @classmethod
    def register_signal(cls):
        GObject.signal_new(
            "update",          # signal name
            ServiceStatus,  # object type
            GObject.SIGNAL_RUN_FIRST | GObject.SIGNAL_ACTION,  # flags
            None,           # return type
            (str,),             # argument types
        )

    STATUS_STARTING = "Starting"
    STATUS_STOPPING = "Stopping"
    STATUS_INSTALLING = "Installing"
    STATUS_UNINSTALLING = "Uninstalling"
    STATUS_OFFLINE = "Offline"
    STATUS_STOPPED = "Stopped"
    STATUS_ONLINE = "Online"
    STATUS_PUBLISHING = "Connecting to Tor"
    STATUS_ERROR = "An error occurred. See the log for details."

    def __init__(self, service):
        super().__init__()
        self.service = service
        self.connect("update", self.on_update)
        self.dbus_monitor = dbus_interface.StatusMonitor(self.service.systemd_service,
                                                         self.dbus_receiver)

    def on_update(self, object, status):
        logging.debug("New status: %r", status)
        GLib.idle_add(self.update, status)

    def update(self, status):
        self.update_config_panel(status)
        self.update_service_list(status)

    def update_config_panel(self, status):
        builder = self.service.config_panel.builder
        box = builder.get_object("box_status")
        label = builder.get_object("label_status_value")
        visual_widget = self.get_visual_widget(status)

        for child in box.get_children():
            box.remove(child)

        label.set_label(status)

        box.pack_start(visual_widget, expand=False, fill=False, padding=0)
        box.pack_start(label, expand=False, fill=False, padding=0)
        # XXX: Find out why the status only refreshs after config_panel.show() and do something
        # more lightweight
        if self.service.config_panel.is_active:
            self.service.config_panel.show()

    def update_service_list(self, status):
        service_row = self.service.gui.service_list.service_row_dict[self.service]
        builder = service_row.builder
        box = builder.get_object("box_status_inner")
        label = builder.get_object("label_status_value")

        for child in box.get_children():
            box.remove(child)

        visual_widget = self.get_visual_widget(status)
        label_value = None
        if status in (self.STATUS_OFFLINE, self.STATUS_STOPPED):
            label_value = "Off"
        if status in (self.STATUS_ONLINE,):
            label_value = "On"

        if visual_widget:
            box.pack_start(visual_widget, expand=False, fill=False, padding=0)
        if label_value:
            label.set_label(label_value)
            box.pack_start(label, expand=False, fill=False, padding=0)

    def get_visual_widget(self, status):
        new_builder = Gtk.Builder()
        new_builder.add_from_file(STATUS_UI_FILE)
        if status in (self.STATUS_STARTING, self.STATUS_STOPPING, self.STATUS_INSTALLING,
                      self.STATUS_UNINSTALLING, self.STATUS_PUBLISHING):
            return new_builder.get_object("spinner")
        if status in (self.STATUS_OFFLINE, self.STATUS_STOPPED):
            return new_builder.get_object("image_off")
        if status == self.STATUS_ONLINE:
            return new_builder.get_object("image_on")
        if status == self.STATUS_ERROR:
            return new_builder.get_object("image_error")

    def dbus_receiver(self, dbus_status):
        """Receives systemd status value from dbus and sets the status accordingly.
        valid status values: "active", "activating", "inactive", "deactivating"""
        if dbus_status == "active":
            self.update(self.STATUS_ONLINE)
        if dbus_status == "inactive":
            self.update(self.STATUS_OFFLINE)
        if dbus_status == "activating":
            self.update(self.STATUS_STARTING)
        if dbus_status == "deactivating":
            self.update(self.STATUS_STOPPING)

    def guess_status(self):
        if not self.service.is_installed:
            return
        if self.service.is_running and self.service.address:
            self.update(self.STATUS_ONLINE)
            self.service.config_panel.set_switch_status(True)
        else:
            self.update(self.STATUS_OFFLINE)
            self.service.config_panel.set_switch_status(False)


class ServiceConfigPanel(object):

    def __init__(self, gui, service):
        assert isinstance(gui, TailsServerGUI)
        self.gui = gui
        self.service = service
        self.builder = Gtk.Builder()
        self.builder.add_from_file(CONFIG_UI_FILE)
        self.builder.connect_signals(self)
        self.new_onion_address_button = self.builder.get_object("button_new_onion_address")
        self.onion_address_label = self.builder.get_object("label_onion_address")
        self.connection_string_label = self.builder.get_object("label_connection_string")
        self.onion_address_box = self.builder.get_object("box_onion_address")
        self.connection_string_box = self.builder.get_object("box_connection_string")
        self.options_grid = self.builder.get_object("grid_options")
        self.option_rows = list()
        self.option_groups = set()
        self.group_separators = dict()
        if self.service.is_installed:
            self.populate_option_rows()

    @property
    def is_active(self):
        return self.gui.current_service == self.service

    def populate_option_rows(self):
        for widget in (self.onion_address_label,
                       self.connection_string_label,
                       self.onion_address_box,
                       self.connection_string_box):
            widget.set_visible(True)
        self.option_groups = {"connection"} | {
            option.group for option in self.service.options_dict.values() if option.group
            }
        logging.debug("Option groups: %r", self.option_groups)
        for group in self.option_groups:
            self.add_separator(group)
        for option in self.service.options_dict.values():
            self.add_option(option)

    def add_separator(self, group):
        logging.debug("Inserting separator for group %r", group)
        # self.group_separators[group] = Gtk.Separator()
        self.group_separators[group] = Gtk.Box()
        if group == "connection":
            self.options_grid.insert_next_to(
                self.onion_address_label,
                Gtk.PositionType.BOTTOM
            )
            self.options_grid.attach_next_to(
                self.group_separators[group],
                self.onion_address_label,
                Gtk.PositionType.BOTTOM,
                width=2, height=1
            )
        else:
            self.options_grid.attach_next_to(
                self.group_separators[group],
                None,
                Gtk.PositionType.BOTTOM,
                width=2, height=1
            )

    def show(self):
        icon = self.builder.get_object("image_service_icon")
        _, size = icon.get_icon_name()
        icon.set_from_icon_name(self.service.icon_name, size)

        self.builder.get_object("label_service_name").set_text(self.service.name_in_gui)
        self.builder.get_object("label_service_description").set_text(self.service.description)
        self.builder.get_object("label_onion_address_value").set_text(str(self.service.address))
        self.builder.get_object("label_connection_string_value").set_text(
            str(self.service.connection_string_in_gui))

        self.set_new_onion_address_button_sensitivity()
        self.set_autorun_sensitivity()

        config_panel_container = self.gui.builder.get_object("scrolledwindow_service_config")
        for child in config_panel_container.get_children():
            config_panel_container.remove(child)
        config_panel_container.add(self.builder.get_object("viewport_service_config"))
        self.gui.current_service = self.service

    def set_new_onion_address_button_sensitivity(self):
        self.new_onion_address_button.set_sensitive(not self.service.is_running and
                                                    self.service.address is not None)

    def set_autorun_sensitivity(self):
        try:
            persistence_row = [r for r in self.option_rows if r.option.name == "persistence"][0]
            autostart_row = [r for r in self.option_rows if r.option.name == "autostart"][0]
        except IndexError:
            return
        if not persistence_row.value:
            autostart_row.sensitive = False

    def add_option(self, option):
        try:
            option_row = OptionRow.create(self, option)
        except TypeError as e:
            logging.error(e)
            return
        option_row.show()
        self.option_rows.append(option_row)
        # if not option_row.known_option:
        # self.options_grid.insert_row(-1)
        # self.options_grid.attach(option_row.label, -1, -1, 1, 1)
        if option.group:
            self.add_row_to_group(option_row, option.group)
        else:
            self.options_grid.add(option_row.label)
        self.options_grid.attach_next_to(option_row.box, option_row.label,
                                         Gtk.PositionType.RIGHT, width=1, height=1)

    def add_row_to_group(self, option_row, group):
        logging.debug("Inserting option_row %r above separator of group %r",
                      option_row.option.name, group)
        self.options_grid.insert_next_to(
            self.group_separators[group],
            Gtk.PositionType.TOP
        )
        self.options_grid.attach_next_to(
            option_row.label,
            self.group_separators[group],
            Gtk.PositionType.TOP,
            width=1, height=1
        )

    def set_switch_status(self, status):
        switch = self.builder.get_object("switch_service_start_stop")
        # XXX: Use only either set_active or set_status here?
        switch.set_active(status)
        switch.set_state(status)

    def apply_options(self):
        logging.debug("Applying options")
        for option_row in self.option_rows:
            logging.debug("Setting option %r to %r", option_row.option.name, option_row.value)
            option_row.option.value = option_row.value

    def on_copy_entry_clicked(self, entry, icon, event):
        entry.select_region(0, -1)
        entry.copy_clipboard()

    def on_switch_service_start_stop_state_set(self, switch, status):
        logging.debug("on_switch_service_start_stop_state_set. status: %r", status)
        util.run_threaded_when_idle(self.service, self.on_switch_state_set, status)

    def on_switch_state_set(self, status):
        for option_row in self.option_rows:
            option_row.sensitive = not status
        self.set_new_onion_address_button_sensitivity()
        self.set_autorun_sensitivity()

        is_running = self.service.is_running
        logging.debug("is running: %r", is_running)
        if status and not is_running:
            self.apply_options()
            util.run_threaded(self.service, self.service.enable)
            self.show()
        if not status and is_running:
            util.run_threaded(self.service, self.service.disable)

    def on_checkbutton_persistence_toggled(self, checkbutton):
        state = checkbutton.get_active()
        try:
            autostart_row = [row for row in self.option_rows if row.option.name == "autostart"][0]
        except IndexError:
            return
        autostart_row.sensitive = state
        if not state:
            autostart_row.value_widget.set_active(False)

    def on_button_copy_connection_string_clicked(self, button):
        text = self.service.connection_string
        self.gui.clipboard.set_text(text, len(text))

    def on_button_new_onion_address_clicked(self, button):
        confirmed = self.gui.obtain_confirmation(
            title="Generate new onion address",
            text="This will irrevocably change this service's onion address. Are you sure you "
                 "want to proceed?",
            ok_label="Generate new address"
        )
        if not confirmed:
            return
        self.service.remove_onion_address()
        self.show()


class ServiceList(object):

    service_row_dict = collections.OrderedDict()

    def __init__(self, gui):
        self.gui = gui
        self.builder = gui.builder
        self.listbox = self.builder.get_object("listbox_service_status")

    def __len__(self):
        return len(self.service_row_dict)

    def __getitem__(self, item):
        return list(self.service_row_dict.keys())[item]

    def listboxrow_to_service(self, listboxrow):
        for service, service_row in self.service_row_dict.items():
            if service_row.listboxrow == listboxrow:
                return service
        raise KeyError(listboxrow)

    def get_selected_service(self):
        listboxrow = self.listbox.get_selected_row()
        return self.listboxrow_to_service(listboxrow)

    def add_service(self, service):
        logging.debug("Adding service %r to service list", service.name)
        service_list_row = ServiceListRow(service)
        self.service_row_dict[service] = service_list_row
        self.listbox.add(service_list_row.listboxrow)

        service.status.guess_status()
        service.activate_status_monitor()

    def remove_service(self, service):
        service_row = self.service_row_dict[service]
        del self.service_row_dict[service]
        self.listbox.remove(service_row.listboxrow)
        if len(self) > 0:
            self.select_service(self[0])
        else:
            self.gui.show_config_panel_placeholder()

    def row_selected(self, listboxrow):
        service = self.listboxrow_to_service(listboxrow)
        self.service_selected(service)

    def select_service(self, service):
        self.listbox.select_row(self.service_row_dict[service].listboxrow)
        self.service_selected(service)

    def service_selected(self, service):
        service.config_panel.show()


class ServiceListRow(object):
    def __init__(self, service):
        self.builder = Gtk.Builder()
        self.builder.add_from_file(SERVICE_LIST_UI_FILE)
        self.listboxrow = self.builder.get_object("listboxrow_service_status")
        label = self.builder.get_object("label_status_title")
        label.set_label(service.name_in_gui)
        icon = self.builder.get_object("image_status_service_icon")
        _, size = icon.get_icon_name()
        icon.set_from_icon_name(service.icon_name, size)


class ServiceChooser(object):

    row_to_service_dict = dict()

    def __init__(self, gui):
        self.gui = gui
        self.builder = Gtk.Builder()
        self.builder.add_from_file(SERVICE_CHOOSER_UI_FILE)
        self.builder.connect_signals(self)
        self.listbox = self.builder.get_object("listbox_add_service")
        self.window = self.builder.get_object("service_chooser_dialog")
        self.window.set_transient_for(gui.window)
        self.window.set_title("Add Service")
        self.load_services()
        self.disable_other_windows = DisableOtherWindows(self.window)

    def show(self):
        self.window.show_all()
        self.listbox.unselect_all()
        self.disable_other_windows.disable_other_windows()

    def on_service_chooser_dialog_destroy(self, window):
        logging.debug("on_service_chooser_dialog_destroy")
        self.disable_other_windows.reenable_other_windows()

    def on_listbox_add_service_row_activated(self, window, listboxrow):
        self.row_selected(listboxrow)

    def load_services(self):
        for service in self.gui.services:
            self.add_service(service)

    def add_service(self, service):
        new_builder = Gtk.Builder()
        new_builder.add_from_file(SERVICE_CHOOSER_UI_FILE)
        title_label = new_builder.get_object("label_add_service_title")
        title_label.set_text(service.name_in_gui)
        description_label = new_builder.get_object("label_add_service_description")
        description_label.set_text(service.description)
        icon = new_builder.get_object("image_add_service_icon")
        _, size = icon.get_icon_name()
        icon.set_from_icon_name(service.icon_name, size)
        row = new_builder.get_object("listboxrow_add_service")
        self.row_to_service_dict[row] = service
        if service.is_installed:
            row.set_sensitive(False)
        self.listbox.add(row)

    def row_selected(self, listboxrow):
        service = self.row_to_service_dict[listboxrow]
        self.disable_other_windows.reenable_other_windows()
        self.window.hide()
        self.gui.service_list.add_service(service)
        self.gui.service_list.select_service(service)

        util.run_threaded(service, service.install)

        # self.gui.loading_window.display_while_calling(
        #     service.install,
        #     label="Installing service %s" % service.name_in_gui,
        # )


class DisableOtherWindows(object):
    def __init__(self, window):
        assert(isinstance(window, Gtk.Window))
        self.window = window
        self.other_windows = [window for window in Gtk.Window.list_toplevels()
                              if window != self.window]
        self.other_window_sensitivities = list()

    def __enter__(self):
        self.disable_other_windows()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.reenable_other_windows()

    def disable_other_windows(self):
        for window in self.other_windows:
            self.other_window_sensitivities.append(window.get_sensitive())
            window.set_sensitive(False)

    def reenable_other_windows(self):
        for i, window in enumerate(self.other_windows):
                window.set_sensitive(self.other_window_sensitivities[i])


class TailsServerGUI(object):

    current_service = None

    def on_window1_destroy(self, obj, data=None):
        for service in self.services:
            service.stop_status_monitor()
        Gtk.main_quit()

    def on_close_clicked(self, button):
        Gtk.main_quit()

    def on_button_add_service_clicked(self, button):
        ServiceChooser(self).show()

    def on_button_remove_service_clicked(self, button):
        service = self.service_list.get_selected_service()
        confirmed = self.obtain_confirmation(
            "Remove service",
            "This will irrevocably delete all configurations and data of this service, "
            "including the onion address. Are you sure you want to proceed?",
            ok_label="Remove"
        )
        if not confirmed:
            return
        util.run_threaded(service, self.uninstall_service, service)

    def uninstall_service(self, service):
        service.uninstall()
        GLib.idle_add(self.service_list.remove_service, service)
        self.reset_service(service)

    def reset_service(self, service):
        i = self.services.index(service)
        new_service = service_modules_dict[service.name].service_class()
        self.services[i] = ServiceDecorator(self, new_service)

    def on_listbox_service_status_row_activated(self, listbox, listboxrow):
        self.service_list.row_selected(listboxrow)

    def obtain_confirmation(self, title, text, ok_label, cancel_label="Cancel"):
        try:
            sh.zenity(
                "--question",
                "--default-cancel",
                "--ok-label", ok_label,
                "--cancel-label", cancel_label,
                "--title", title,
                "--text", text,
            )
        except sh.ErrorReturnCode_1:
            return False
        return True

    def __init__(self):
        self.builder = Gtk.Builder()
        self.builder.add_from_file(MAIN_UI_FILE)
        self.builder.connect_signals(self)

        self.services = [ServiceDecorator(self, module.service_class())
                         for module in service_modules_dict.values()]

        self.service_list = ServiceList(self)
        persistent_services = [service for service in self.services
                               if service.options_dict["persistence"].value]
        for service in persistent_services:
            service.install()
        for service in [service for service in self.services if service.is_installed]:
            self.service_list.add_service(service)
        if self.service_list:
            self.service_list.select_service(self.service_list[0])

        icon_theme = Gtk.IconTheme.get_default()
        icon_theme.prepend_search_path(ICON_DIR)

        self.window = self.builder.get_object("window1")
        self.service_viewport_container = self.builder.get_object("box2")
        self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

        self.window.connect("delete-event", Gtk.main_quit)
        self.window.set_title("Tails Server")
        self.window.show_all()

    def show_config_panel_placeholder(self):
        config_panel_container = self.builder.get_object("scrolledwindow_service_config")
        for child in config_panel_container.get_children():
            config_panel_container.remove(child)
        config_panel_container.add(self.builder.get_object("viewport_service_config_placeholder"))


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", action="store_true")
    return parser.parse_args()


def init(args):
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)
    logging.debug("args: %r", args)


def main():
    args = parse_args()
    init(args)
    ServiceStatus.register_signal()
    TailsServerGUI()
    Gtk.main()

if __name__ == "__main__":
    main()
