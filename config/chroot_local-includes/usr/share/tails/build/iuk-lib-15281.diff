diff --git a/usr/share/perl5/Tails/IUK.pm b/usr/share/perl5/Tails/IUK.pm
index aa94d16..a6e6427 100644
--- a/usr/share/perl5/Tails/IUK.pm
+++ b/usr/share/perl5/Tails/IUK.pm
@@ -6,19 +6,12 @@ Tails::IUK - Incremental Upgrade Kit class
 
 package Tails::IUK;
 
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-
-
-with 'MooseX::Getopt::Dashes';
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
 use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -30,46 +23,82 @@ use Device::Cdio::ISO9660;
 use Device::Cdio::ISO9660::IFS;
 use English qw{-no_match_vars};
 use File::Basename;
-use File::Copy;
 use File::Spec::Functions;
-use File::Temp qw{tempdir tempfile};
-use Path::Class;
-use Tails::IUK::Utils qw{extract_file_from_iso extract_here_file_from_iso run_as_root};
+use Function::Parameters;
+use IPC::Run;
+use Path::Tiny;
+use Tails::IUK::Utils qw{extract_file_from_iso extract_here_file_from_iso run_as_root stdout_as_root};
+use Types::Path::Tiny qw{AbsDir AbsFile AbsPath File};
+use Types::Standard qw(ArrayRef Enum Str);
 use Try::Tiny;
 use YAML::Any;
 
+use namespace::clean;
+
+use MooX::Options;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-foreach (qw{old_iso new_iso}) {
-    has $_ => required ro Str;
-}
-has 'squashfs_diff_name' =>
-    required ro Str,
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => AbsFile,
+    coerce   => AbsFile->coercion,
+    format   => 's',
+) for (qw{old_iso new_iso});
+
+option 'squashfs_diff_name' =>
+    required      => 1,
+    is            => 'ro',
+    isa           => Str,
+    format        => 's',
     documentation => q{Name of the SquashFS diff file that will be installed into the system partition};
-has 'outfile' =>
-    required coerce lazy_build ro 'Path::Class::File',
+
+option 'outfile' =>
+    required      => 1,
+    is            => 'lazy',
+    isa           => AbsPath,
+    coerce        => AbsPath->coercion,
+    format        => 's',
     documentation => q{Location of the created IUK};
-has 'format_version' => lazy_build ro Str, metaclass => 'NoGetopt';
-has 'squashfs_diff'  =>
-    coerce lazy_build ro 'Path::Class::File',
-    documentation => q{Internal, for test suite only};
-has 'delete_files'   => lazy_build ro 'ArrayRef[Str]', metaclass => 'NoGetopt';
-has 'new_kernels' => lazy_build ro 'ArrayRef[Str]', metaclass => 'NoGetopt';
-has 'tarballs' => lazy_build ro 'ArrayRef[Str]', documentation => q{Internal, for test suite only};
-has 'tempdir' => lazy_build ro 'Path::Class::Dir', metaclass => 'NoGetopt';
-has 'tar_options' =>
-    lazy_build ro 'ArrayRef[Str]',
-    traits => ['Array'],
-    metaclass => 'NoGetopt',
-    handles => {
-        list_tar_options => 'elements',
+
+option 'union_type' =>
+    is            => 'lazy',
+    isa           => Enum[qw{aufs overlayfs}],
+    coerce        => Enum->coercion,
+    format        => 's',
+    documentation => q{aufs or overlayfs};
+
+has 'format_version' =>
+    is  => 'lazy',
+    isa => Str;
+
+has "$_" =>
+    is  => 'lazy',
+    isa => ArrayRef
+for (qw{delete_files new_kernels});
+
+has "$_" =>
+    is  => 'lazy',
+    isa => AbsDir
+for (qw{tempdir overlay_dir squashfs_src_dir});
+
+has 'mksquashfs_options' =>
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
+        list_mksquashfs_options => 'elements',
     };
-has 'ignore_if_same_content' =>
-    lazy_build ro 'ArrayRef[Str]',
-    traits => ['Array'],
+
+option 'ignore_if_same_content' =>
+    is            => 'lazy',
+    isa           => ArrayRef,
+    handles_via   => 'Array',
+    format        => 's@',
     documentation => q{Do not include this file in the SquashFS if its content}.
                      q{has not changed. Globs are supported.};
 
@@ -90,15 +119,9 @@ Some was adapted from File::DirCompare:
     under the same terms as Perl itself.
 
 =cut
-sub missing_files_in_isos {
-    my $iso1 = shift;
-    my $iso2 = shift;
-    my $dir  = shift;
-
-    my $read_iso_dir = sub {
-        my $iso = shift;
-        my $dir = shift;
-        my $iso_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso);
+fun missing_files_in_isos ($iso1, $iso2, $dir) {
+    my $read_iso_dir = fun ($iso, $dir) {
+        my $iso_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso->stringify);
         map {
             Device::Cdio::ISO9660::name_translate($_->{filename});
         } $iso_obj->readdir($dir);
@@ -139,22 +162,12 @@ Some was adapted from File::DirCompare:
     under the same terms as Perl itself.
 
 =cut
-sub upgraded_or_new_files_in_isos {
-    my $iso1 = shift;
-    my $iso2 = shift;
-    my $dir  = shift;
-    my $whitelist_patterns = shift;
-
-    assert(-e $iso1);
-    assert(-e $iso2);
-
-    my $iso1_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso1);
-    my $iso2_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso2);
-
-    my $read_iso_dir = sub {
-        my $iso_obj = shift;
-        my $dir = shift;
+fun upgraded_or_new_files_in_isos (
+    AbsFile $iso1, AbsFile $iso2, $dir, $whitelist_patterns) {
+    my $iso1_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso1->stringify);
+    my $iso2_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso2->stringify);
 
+    my $read_iso_dir = fun ($iso_obj, $dir) {
         assert(defined($iso_obj));
         my @wanted_files;
         my @files_in_dir;
@@ -205,12 +218,12 @@ sub upgraded_or_new_files_in_isos {
         croak "File $f in $iso2 is a directory." if $stat2->{is_dir};
 
         push @res, $f if
-            extract_file_from_iso(catfile($dir, $f), $iso1)
+            extract_file_from_iso(path($dir, $f), path($iso1))
                 ne
-            extract_file_from_iso(catfile($dir, $f), $iso2);
+            extract_file_from_iso(path($dir, $f), path($iso2));
     }
 
-    return map { file($dir, $_)->basename } @res;
+    return map { path($dir, $_)->basename } @res;
 }
 
 
@@ -218,219 +231,224 @@ sub upgraded_or_new_files_in_isos {
 
 =cut
 
-method _build_ignore_if_same_content { []; }
-method _build_tempdir { dir(tempdir()); }
-method _build_format_version { "1"; }
-method _build_tar_options { [
-    qw{--numeric-owner --owner=root --group=root},
-    qw{--sort=name --clamp-mtime}, "--mtime=\@$ENV{SOURCE_DATE_EPOCH}",
-]; }
-method _build_squashfs_diff  {
-    my $tempdir = $self->tempdir;
+method _build_ignore_if_same_content () { []; }
+method _build_tempdir () { Path::Tiny->tempdir; }
+method _build_squashfs_src_dir () {
+    my $squashfs_src_dir = $self->tempdir->child('squashfs_src');
+    $squashfs_src_dir->mkpath;
+    return $squashfs_src_dir;
+}
+method _build_overlay_dir () {
+    my $overlay_dir = $self->squashfs_src_dir->child('overlay');
+    $overlay_dir->mkpath;
+    return $overlay_dir;
+}
+method _build_format_version () { "2"; }
+method _build_mksquashfs_options () { [
+    qw{-no-progress -noappend},
+    qw{-all-root},
+    qw{-comp xz -Xbcj x86 -b 1024K -Xdict-size 1024K},
+]}
+method _build_union_type () { "aufs"; }
+
+method _build_delete_files () {
+    my $old_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->old_iso->stringify);
+    my $new_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->new_iso->stringify);
+    my @delete_files;
+    for (qw{EFI isolinux live syslinux tails utils}) {
+        push @delete_files,
+            missing_files_in_isos($self->old_iso, $self->new_iso, $_);
+    }
+    return \@delete_files;
+}
+
+method _build_new_kernels () {
+    my @new_kernels =
+        upgraded_or_new_files_in_isos(
+            $self->old_iso,
+            $self->new_iso,
+            'live',
+            [
+                qr{^ vmlinuz [[:digit:]]* $}xms,
+                qr{^ initrd  [[:digit:]]* [.] img $}xms,
+            ],
+        );
+    return \@new_kernels;
+}
 
-    my $old_iso_mount      = dir($tempdir, 'old_iso');
-    my $new_iso_mount      = dir($tempdir, 'new_iso');
-    my $old_squashfs_mount = dir($tempdir, 'old_squashfs');
-    my $new_squashfs_mount = dir($tempdir, 'new_squashfs');
-    my $tmpfs              = dir($tempdir, 'tmpfs');
-    my $union              = dir($tempdir, 'union');
+method create_squashfs_diff () {
+    my $tempdir = $self->tempdir;
 
-    for my $dir ($old_iso_mount, $new_iso_mount, $old_squashfs_mount, $new_squashfs_mount, $tmpfs, $union) {
-        mkdir $dir;
+    my $old_iso_mount      = $tempdir->child('old_iso');
+    my $new_iso_mount      = $tempdir->child('new_iso');
+    my $old_squashfs_mount = $tempdir->child('old_squashfs');
+    my $new_squashfs_mount = $tempdir->child('new_squashfs');
+    my $tmpfs;
+    # overlayfs requires:
+    # + a workdir to become mounted
+    # + workdir and upperdir to reside under the same mount
+    # + workdir and upperdir to be in separate directories
+    my $union_basedir      = $tempdir->child('union');
+    my $union_mount        = $union_basedir->child('mount');
+    my $union_workdir      = $union_basedir->child('work');
+    my $union_upperdir     = $union_basedir->child('rw');
+
+    for my $dir (
+        $old_iso_mount, $new_iso_mount, $old_squashfs_mount,
+        $new_squashfs_mount, $union_basedir ) {
+        $dir->mkpath;
+    }
+    run_as_root(qw{mount -t tmpfs tmpfs}, $union_basedir);
+    for my $dir ($union_mount, $union_workdir, $union_upperdir) {
+        $dir->mkpath;
     }
 
     run_as_root("mount", "-o", "loop,ro", $self->old_iso, $old_iso_mount);
-    my $old_squashfs = file($old_iso_mount, 'live', 'filesystem.squashfs');
+    my $old_squashfs = path($old_iso_mount, 'live', 'filesystem.squashfs');
     croak "SquashFS '$old_squashfs' not found in '$old_iso_mount'" unless -e $old_squashfs;
     run_as_root(qw{mount -t squashfs -o loop}, $old_squashfs, $old_squashfs_mount);
 
     run_as_root("mount", "-o", "loop,ro", $self->new_iso, $new_iso_mount);
-    my $new_squashfs = file($new_iso_mount, 'live', 'filesystem.squashfs');
+    my $new_squashfs = path($new_iso_mount, 'live', 'filesystem.squashfs');
     croak "SquashFS '$new_squashfs' not found in '$new_iso_mount'" unless -e $new_squashfs;
     run_as_root(qw{mount -t squashfs -o loop}, $new_squashfs, $new_squashfs_mount);
 
-    run_as_root(qw{mount -t tmpfs tmpfs}, $tmpfs);
-
-    run_as_root(
-        qw{mount -t aufs},
-        "-o", sprintf("br=%s=rw:%s=ro", $tmpfs, $old_squashfs_mount),
-        "none", $union
-    );
+    if ($self->union_type eq 'aufs') {
+        run_as_root(
+            qw{mount -t aufs},
+            "-o", sprintf("br=%s=rw:%s=ro", $union_upperdir, $old_squashfs_mount),
+            "none", $union_mount
+        );
+    } else {
+        run_as_root(
+            qw{mount -t overlay},
+            "-o", sprintf("lowerdir=%s,upperdir=%s,workdir=%s",
+                          $old_squashfs_mount, $union_upperdir, $union_workdir),
+            "overlay", $union_mount
+        );
+    }
 
     run_as_root(
         "rsync", "--archive", "--quiet", "--delete-after", "--acls",
-        "--checksum",
-        sprintf("%s/", dir($new_squashfs_mount)),
-        sprintf("%s/", dir($union)),
+        "--xattrs", "--checksum",
+        sprintf("%s/", $new_squashfs_mount),
+        sprintf("%s/", $union_mount),
     );
 
     for my $glob (@{$self->ignore_if_same_content}) {
         my @candidates_for_removal = map {
-            file($_)
-        } grep { -e } glob("$tmpfs/$glob");
+            path($_)
+        } grep { -e } glob("$union_upperdir/$glob");
 
         map {
             unlink $_;
         } grep {
             my $candidate     = $_;
             my $candidate_rel = "$candidate";
-            $candidate_rel    =~ s{^$tmpfs/}{}xms;
-            my $candidate_old = $old_squashfs_mount->file($candidate_rel);
+            $candidate_rel    =~ s{^$union_upperdir/}{}xms;
+            my $candidate_old = $old_squashfs_mount->child($candidate_rel);
             -e $candidate_old && $candidate_old->slurp eq $candidate->slurp;
         } @candidates_for_removal;
     }
 
-    run_as_root('auplink', $union, 'flush');
+    if ($self->union_type eq 'aufs') {
+        run_as_root('auplink', $union_mount, 'flush');
+    }
+
+    run_as_root("umount", $union_mount);
 
-    my ($squashfs_diff_fh, $squashfs_diff_filename) = tempfile(DIR => $tempdir);
+    # Remove trusted.overlay.* xattrs
+    if ($self->union_type eq 'overlayfs') {
+        my @xattrs_dump = stdout_as_root(
+            qw{getfattr --dump --recursive --no-dereference --absolute-names},
+            q{--match=^trusted\.overlay\.},
+            $union_upperdir->stringify,
+        );
+        my %xattrs;
+        my $current_filename;
+        foreach (@xattrs_dump) {
+            defined || last;
+            chomp;
+            if (! length($_)) {
+                $current_filename = undef;
+                next;
+            } elsif (my ($filename) = ($_ =~ m{\A [#] \s+ file: \s+ (.*) \z}xms)) {
+                $current_filename = $filename;
+            } elsif (my ($xattr, $value) = ($_ =~ m{\A(trusted[.]overlay[.][^=]+)=(.*)\z}xms)) {
+                push @{$xattrs{$xattr}}, $current_filename;
+            } else {
+                croak "Unrecognized line, aborting: '$_'";
+            }
+        }
+        while (my ($xattr, $files) = each %xattrs) {
+            my $stdin = join(chr(0), @$files);
+            my ($stdout, $stderr);
+            IPC::Run::run [
+                qw{sudo xargs --null --no-run-if-empty},
+                'setfattr', '--remove=' . $xattr,
+                '--no-dereference',
+                '--'
+            ], \$stdin or croak "xargs failed: $?";
+        }
+    }
 
     run_as_root(
         "SOURCE_DATE_EPOCH=$ENV{SOURCE_DATE_EPOCH}",
         qw{mksquashfs},
-        $tmpfs,
-        $squashfs_diff_filename,
-        qw{-no-progress -noappend -comp xz -Xbcj x86 -b 1024K -Xdict-size 1024K}
+        $union_upperdir,
+        $self->overlay_dir->child('live', $self->squashfs_diff_name),
+        $self->list_mksquashfs_options
     );
 
-    foreach ($union, $tmpfs, $new_squashfs_mount, $new_iso_mount,
+    foreach ($union_basedir,
+             $new_squashfs_mount, $new_iso_mount,
              $old_squashfs_mount, $old_iso_mount) {
         run_as_root("umount", $_);
     }
 
-    return file($squashfs_diff_filename);
+    return;
 }
 
-method _build_delete_files {
-    my $old_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->old_iso);
-    my $new_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->new_iso);
-    my @delete_files;
-    for (qw{EFI isolinux live syslinux tails utils}) {
-        push @delete_files,
-            missing_files_in_isos($self->old_iso, $self->new_iso, $_);
-    }
-    return \@delete_files;
-}
+method prepare_overlay_dir () {
+    $self->overlay_dir->child('live')->mkpath;
 
-method _build_new_kernels {
-    my @new_kernels =
-        upgraded_or_new_files_in_isos(
-            $self->old_iso,
-            $self->new_iso,
-            'live',
-            [
-                qr{^ vmlinuz [[:digit:]]* $}xms,
-                qr{^ initrd  [[:digit:]]* [.] img $}xms,
-            ],
-        );
-    return \@new_kernels;
-}
-
-method write_boot_tarball {
-    my $orig_cwd = getcwd;
-    my $boot_files_tempdir = tempdir(CLEANUP => 1);
+    $self->create_squashfs_diff;
 
-    chdir $boot_files_tempdir;
+    chdir $self->overlay_dir;
+    for my $new_kernel (@{$self->new_kernels}) {
+        extract_here_file_from_iso(path('live', $new_kernel), $self->new_iso);
+    }
     extract_here_file_from_iso('EFI',      $self->new_iso);
     extract_here_file_from_iso('isolinux', $self->new_iso);
     extract_here_file_from_iso('utils',    $self->new_iso);
-
-    chmod(0755, 'isolinux');
-    chmod(0644, glob('isolinux/*'));
+    run_as_root(qw{chmod -R go+rX .});
 
     rename 'isolinux', 'syslinux';
     rename 'syslinux/isolinux.cfg', 'syslinux/syslinux.cfg';
 
     foreach my $file (glob('syslinux/*')) {
-        my $content = file($file)->slurp;
-        $content =~ s{/isolinux/}{/syslinux/}gxms;
-        my ($temp_fh, $temp_filename) = tempfile;
-        print $temp_fh $content;
-        close $temp_fh;
-        rename $temp_filename, $file;
-    }
-
-    system(
-        qw{tar -cj}, $self->list_tar_options,
-        '-f', file($self->tempdir, 'boot.tar.bz2'), 'EFI', 'syslinux', 'utils',
-    );
-
-    chdir $orig_cwd;
-
-    return;
-}
-
-method write_system_tarball {
-    my $tarball = file($self->tempdir, 'system.tar');
-
-    chdir $self->squashfs_diff->dir;
-    my $destname = file('live', $self->squashfs_diff_name);
-    my $destdir  = file($destname)->dir;
-    $destdir->mkpath;
-    -d $destdir or croak(sprintf("Could not make directory '%s': $!"), $destdir);
-    copy($self->squashfs_diff->basename, $destname)
-        or croak(
-            sprintf(
-                "Could not copy '%s' to '%s': $!",
-                $self->squashfs_diff->basename, $destname
-            )
-        );
-    system(qw{tar --create}, $self->list_tar_options, '-f', $tarball, $destname);
-    unlink $destname;
-
-    my $new_kernels_tempdir = tempdir(CLEANUP => 1);
-    chdir $new_kernels_tempdir;
-    for my $new_kernel (@{$self->new_kernels}) {
-        my $new_kernel_rel = file('live', $new_kernel);
-        my $new_kernel_abs = file($new_kernels_tempdir, $new_kernel_rel);
-        $new_kernel_abs->dir->mkpath;
-        extract_here_file_from_iso($new_kernel_rel, $self->new_iso);
-        system(
-            qw{tar --append}, $self->list_tar_options, '-f', $tarball,
-            $new_kernel_rel
-        );
+        path($file)->edit_lines(sub { s{/isolinux/}{/syslinux/}gxms });
     }
 
     chdir $self->tempdir;  # allow temp dirs cleanup
-
-    return;
-}
-
-method _build_tarballs {
-    $self->write_boot_tarball;
-    $self->write_system_tarball;
-    return [ qw{boot.tar.bz2 system.tar} ];
 }
 
 method saveas ($outfile_name) {
-    my $orig_cwd = getcwd;
-    my $fh;
-    chdir $self->tempdir;
+    $self->squashfs_src_dir->child('FORMAT')->spew($self->format_version);
 
-    $fh = file('FORMAT')->openw;
-    print $fh $self->format_version;
-    close $fh;
-
-    $fh = file('control.yml')->openw;
-    print $fh YAML::Any::Dump({
+    $self->squashfs_src_dir->child('control.yml')->spew(YAML::Any::Dump({
         delete_files => $self->delete_files,
-    });
-    close $fh;
-
-    chdir $self->tempdir;
-    system(
-        qw{tar --create}, $self->list_tar_options, '-f', $outfile_name,
-        qw{FORMAT control.yml}
-    );
+    }));
 
-    for (@{$self->tarballs}) {
-        chdir file($_)->dir;
-        system(
-            qw{tar --append}, $self->list_tar_options, '-f', $outfile_name,
-            file($_)->basename
-        );
-    }
+    $self->prepare_overlay_dir;
 
-    chdir $orig_cwd;  # allow temp dirs cleanup
+    run_as_root(
+        "SOURCE_DATE_EPOCH=$ENV{SOURCE_DATE_EPOCH}",
+        qw{mksquashfs},
+        $self->squashfs_src_dir,
+        $outfile_name,
+        $self->list_mksquashfs_options
+    );
 
     return;
 }
@@ -449,5 +467,5 @@ method run () {
     $self->save;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/Archive/Tar.pm b/usr/share/perl5/Tails/IUK/Archive/Tar.pm
deleted file mode 100644
index 9c0f880..0000000
--- a/usr/share/perl5/Tails/IUK/Archive/Tar.pm
+++ /dev/null
@@ -1,103 +0,0 @@
-=head1 NAME
-
-Tails::IUK::Archive::Tar - wrap, and add to Archive::Tar::Wrapper for Incremental Upgrade Kit files
-
-=cut
-
-package Tails::IUK::Archive::Tar;
-
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class qw{Dir File};
-use MooseX::Has::Sugar::Saccharin;
-
-
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
-
-use autodie qw(:all);
-use Tails::IUK::Archive::Tar::Wrapper;
-use Carp;
-use File::Temp qw{tempdir};
-use File::Which;
-use Path::Class qw{dir file};
-use Tails::IUK::Utils qw{run_as_root};
-
-
-=head1 TYPES
-
-=cut
-
-class_type('Tails::IUK::Archive::Tar::Wrapper');
-
-
-=head1 ATTRIBUTES
-
-=cut
-
-has 'filename' => (
-    is       => 'ro',
-    isa      => File,
-    required => 1,
-    coerce   => 1,
-);
-
-has 'sudo'        => lazy_build ro Bool;
-has 'tar_exe'     => coerce lazy_build ro File;
-has 'tempdir'     => coerce lazy_build ro Dir, predicate 'has_tempdir';
-
-has 'tar_wrapper' => lazy_build ro 'Tails::IUK::Archive::Tar::Wrapper',
-    handles => [ qw{list_all locate} ];
-
-
-=head1 METHODS
-
-=cut
-
-method BUILD {
-    $self->read_from($self->filename);
-}
-
-method _build_sudo    { 0 }
-method _build_tar_exe { $self->sudo ? which('sudo-tar') : which('tar') }
-method _build_tempdir { dir(tempdir(CLEANUP => 1), 'tar') }
-
-method _build_tar_wrapper {
-    my $tar_wrapper = Tails::IUK::Archive::Tar::Wrapper->new(
-        tar                  => $self->tar_exe->stringify,
-        tar_gnu_read_options => [ qw{--no-same-permissions --no-same-owner} ],
-        tmpdir               => $self->tempdir,
-        tmpdir_is_complete   => 1,
-    );
-    return $tar_wrapper;
-}
-
-method read_from ($file) {
-    my $filename = $file->stringify;
-    $self->tar_wrapper->read($filename) or confess("Error reading $filename");
-    run_as_root(qw{chmod -R go+rX}, $self->tempdir);
-}
-
-method files {
-    sort map { $_->[0] } @{$self->list_all()};
-}
-
-method get_content ($filename) {
-    scalar(file($self->locate($filename))->slurp);
-}
-
-method clean {
-    run_as_root(qw{rm --recursive --force --preserve-root}, $self->tempdir)
-        if $self->has_tempdir;
-}
-
-method DEMOLISH {
-    $self->clean;
-}
-
-no Moose;
-1;
diff --git a/usr/share/perl5/Tails/IUK/Archive/Tar/Wrapper.pm b/usr/share/perl5/Tails/IUK/Archive/Tar/Wrapper.pm
deleted file mode 100644
index 27d525e..0000000
--- a/usr/share/perl5/Tails/IUK/Archive/Tar/Wrapper.pm
+++ /dev/null
@@ -1,81 +0,0 @@
-=head1 NAME
-
-Tails::IUK::Archive::Tar::Wrapper - custom subclass of Archive::Tar::Wrapper for Incremental Upgrade Kit files
-
-=cut
-
-package Tails::IUK::Archive::Tar::Wrapper;
-
-use strict;
-use warnings;
-
-use parent 'Archive::Tar::Wrapper';
-
-use File::Temp qw(tempdir);
-use Log::Log4perl qw(:easy);
-use File::Spec::Functions;
-use File::Spec;
-use File::Path;
-use Tails::IUK::Utils qw{run_as_root};
-
-###########################################
-sub new {
-###########################################
-    my($class, %options) = @_;
-
-    my $self = {
-        tar                   => undef,
-        tmpdir                => undef,
-        tmpdir_is_complete    => undef,
-        tar_error_msg         => undef,
-        tar_read_options      => '',
-        tar_write_options     => '',
-        tar_gnu_read_options  => [],
-        tar_gnu_write_options => [],
-        dirs                  => 0,
-        max_cmd_line_args     => 512,
-        ramdisk               => undef,
-        gzip_regex            => qr/\.t? # an optional t for matching tgz
-                                    gz$ # ending with gz, which means compressed by gzip
-                                    /ix,
-        bzip2_regex           => qr/\.bz2$/ix,
-        %options,
-    };
-
-    bless $self, $class;
-
-    $self->{tar} = bin_find("tar") unless defined $self->{tar};
-    $self->{tar} = bin_find("gtar") unless defined $self->{tar};
-
-    if( ! defined $self->{tar} ) {
-        LOGDIE "tar not found in PATH, please specify location";
-    }
-
-    if(defined $self->{ramdisk}) {
-        my $rc = $self->ramdisk_mount( %{ $self->{ramdisk} } );
-        if(!$rc) {
-            LOGDIE "Mounting ramdisk failed";
-        }
-        $self->{tmpdir} = $self->{ramdisk}->{tmpdir};
-    } else {
-        if ($self->{tmpdir}) {
-            if (! $self->{tmpdir_is_complete}) {
-                $self->{tmpdir} = tempdir(DIR => $self->{tmpdir});
-            }
-        }
-        else {
-            $self->{tmpdir} = tempdir();
-        }
-    }
-
-    $self->{tardir} = File::Spec->catfile($self->{tmpdir}, "tar");
-    run_as_root('mkdir', '--parents', $self->{tardir});
-    -d $self->{tardir} or LOGDIE "Cannot make $self->{tardir} ($!)";
-    run_as_root(qw{chmod -R go+rX}, $self->{tardir});
-
-    $self->{objdir} = tempdir();
-
-    return $self;
-}
-
-1;
diff --git a/usr/share/perl5/Tails/IUK/Frontend.pm b/usr/share/perl5/Tails/IUK/Frontend.pm
index 6c8ad15..791370d 100644
--- a/usr/share/perl5/Tails/IUK/Frontend.pm
+++ b/usr/share/perl5/Tails/IUK/Frontend.pm
@@ -6,79 +6,107 @@ Tails::IUK::Frontend - lead Tails user through the process of upgrading the syst
 
 package Tails::IUK::Frontend;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-with 'Tails::Role::HasEncoding';
-with 'MooseX::Getopt::Dashes';
-
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Carp::Assert::More;
-use Data::Dumper;
 use English qw{-no_match_vars};
 use Env;
-use IPC::Run qw{run start};
+use Function::Parameters;
+use IPC::Run;
 use Number::Format qw(:subs);
-use Path::Class;
+use Path::Tiny;
 use String::Errf qw{errf};
 use Tails::RunningSystem;
 use Tails::IUK::UpgradeDescriptionFile;
-use Tails::IUK::Utils;
+use Tails::IUK::Utils qw{space_available_in};
 use Tails::MirrorPool;
 use Try::Tiny;
+use Types::Path::Tiny qw{AbsDir AbsFile};
+use Types::Standard qw(ArrayRef Bool CodeRef Defined HashRef InstanceOf Int Maybe Str);
 
 use Locale::gettext;
 use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-iuk");
 
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
-=head1 TYPES
+with 'Tails::Role::HasEncoding';
 
-=cut
+use namespace::clean;
 
-class_type 'Tails::RunningSystem';
+use MooX::Options;
 
 
 =head1 ATTRIBUTES
 
 =cut
 
-has "override_$_" => lazy_build ro Str
-    for (qw{baseurl build_target dev_dir os_release_file proc_dir run_dir},
-         qw{trusted_gnupg_homedir});
-
-has batch => lazy_build ro Bool;
-
-has 'override_liveos_mountpoint' => coerce lazy_build ro 'Path::Class::Dir';
-
-has 'override_started_from_device_installed_with_tails_installer' =>
-    lazy_build ro Str, documentation => q{Internal, for test suite only};
+option "override_$_" => (
+    is        => 'lazy',
+    isa       => Str,
+    format    => 's',
+    predicate => 1,
+) for (qw{baseurl build_target trusted_gnupg_homedir});
+
+option override_initial_install_os_release_file =>
+    is        => 'lazy',
+    isa       => AbsFile,
+    coerce    => AbsFile->coercion,
+    format    => 's',
+    predicate => 1;
+
+option override_os_release_file =>
+    is        => 'lazy',
+    isa       => AbsFile,
+    coerce    => AbsFile->coercion,
+    format    => 's',
+    predicate => 1;
+
+option "override_$_" => (
+    isa        => AbsDir,
+    is         => 'ro',
+    lazy_build => 1,
+    coerce     => AbsDir->coercion,
+    format     => 's',
+    predicate  => 1,
+) for (qw{dev_dir liveos_mountpoint proc_dir run_dir});
+
+option batch =>
+    is  => 'lazy',
+    isa => Bool;
+
+option 'override_started_from_device_installed_with_tails_installer' =>
+    is            => 'lazy',
+    isa           => Str,
+    format        => 's',
+    predicate     => 1,
+    documentation => q{Internal, for test suite only};
 
 has 'running_system' =>
-    lazy_build ro 'Tails::RunningSystem',
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::RunningSystem'],
     handles => [
         qw{upgrade_description_file_url upgrade_description_sig_url},
-        qw{product_name product_version build_target channel}
+        qw{product_name initial_install_version build_target channel}
     ];
 
 has 'free_space' =>
-    lazy_build ro Int,
-    metaclass     => 'NoGetopt',
+    is            => 'lazy',
+    isa           => Int,
     documentation => q{Free space (in bytes) on the system partition};
 
-has 'override_free_space' =>
-    lazy_build ro Str,
+option 'override_free_space' =>
+    is            => 'lazy',
+    isa           => Int,
+    format        => 'i',
+    predicate     => 1,
     documentation => q{Internal, for test suite only};
 
 
@@ -86,11 +114,12 @@ has 'override_free_space' =>
 
 =cut
 
-method _build_batch { 0; }
+method _build_batch () { 0; }
 
-method _build_running_system {
+method _build_running_system () {
     my @args;
-    for (qw{baseurl build_target dev_dir liveos_mountpoint os_release_file},
+    for (qw{baseurl build_target dev_dir liveos_mountpoint},
+         qw{os_release_file initial_install_os_release_file},
          qw{proc_dir run_dir}) {
         my $attribute = "override_$_";
         my $predicate = "has_$attribute";
@@ -107,10 +136,10 @@ method _build_running_system {
     Tails::RunningSystem->new(@args);
 }
 
-method _build_free_space {
+method _build_free_space () {
     $self->has_override_free_space
         ? $self->override_free_space
-        : space_available($self->running_system->liveos_mountpoint->stringify);
+        : space_available_in($self->running_system->liveos_mountpoint);
 }
 
 
@@ -127,7 +156,7 @@ method info (Str $msg) {
     say $self->encoding->encode($msg);
 }
 
-method fatal_run_cmd (Str :$error_msg!, ArrayRef :$cmd!, Str :$as?, Str :$error_title) {
+method fatal_run_cmd (Str :$error_msg, ArrayRef :$cmd, Maybe[Str] :$as = undef, Str :$error_title) {
     my @cmd       = @{$cmd};
 
     if (defined $as && ! $ENV{HARNESS_ACTIVE}) {
@@ -137,7 +166,7 @@ method fatal_run_cmd (Str :$error_msg!, ArrayRef :$cmd!, Str :$as?, Str :$error_
     my ($stdout, $stderr);
     my $success = 1;
     my $exit_code;
-    run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
+    IPC::Run::run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
     $exit_code = $?;
     $success or $self->fatal(
         errf("<b>%{error_msg}s</b>\n\n%{details}s",
@@ -160,9 +189,8 @@ method fatal_run_cmd (Str :$error_msg!, ArrayRef :$cmd!, Str :$as?, Str :$error_
     return ($stdout, $stderr, $success, $exit_code);
 }
 
-method dialog (Str $question,
-               Str :$type = 'question', Str :$ok_label, Str :$cancel_label,
-               Str :$title) {
+method dialog (Str $question, Str :$type = 'question', Str :$title,
+               Maybe[Str] :$ok_label = undef, Maybe[Str] :$cancel_label = undef) {
     if ($type ne 'question' && $type ne 'info') {
         assert_undefined($ok_label);
     }
@@ -190,26 +218,26 @@ method dialog (Str $question,
 }
 
 method upgrader_run_dir () {
-    dir($self->running_system->run_dir)->subdir('tails-upgrader');
+    $self->running_system->run_dir->child('tails-upgrader');
 }
 
 method checked_upgrades_file () {
-    $self->upgrader_run_dir->file('checked_upgrades');
+    $self->upgrader_run_dir->child('checked_upgrades');
 }
 
 method get_upgrade_description () {
     my @args;
-    for (qw{baseurl build_target os_release_file}) {
+    for (qw{baseurl build_target os_release_file initial_install_os_release_file}) {
         my $attribute = "override_$_";
         my $predicate = "has_$attribute";
         if ($self->$predicate) {
-            my $arg = "--$attribute"; $arg =~ s{_}{-}xmsg;
+            my $arg = "--$attribute";
             push @args, ($arg, $self->$attribute);
         }
     }
     if ($self->has_override_trusted_gnupg_homedir) {
         push @args, (
-            '--trusted-gnupg-homedir', $self->override_trusted_gnupg_homedir
+            '--trusted_gnupg_homedir', $self->override_trusted_gnupg_homedir
         );
     }
     my ($stdout, $stderr, $success, $exit_code) = $self->fatal_run_cmd(
@@ -416,17 +444,11 @@ method run () {
     }
 }
 
-sub target_files {
-    my $upgrade_path = shift;
-    my $destdir     = shift;
-
-    assert_defined($upgrade_path);
-    assert_defined($destdir);
-
+fun target_files (HashRef $upgrade_path, AbsDir $destdir) {
     my @target_files;
     foreach my $target_file (@{$upgrade_path->{'target-files'}}) {
-        my $basename    = file($target_file->{url})->basename;
-        my $output_file = file($destdir, $basename);
+        my $basename    = path($target_file->{url})->basename;
+        my $output_file = path($destdir, $basename);
         push @target_files,
             {
                 %{$target_file},
@@ -444,11 +466,23 @@ the incremental upgrade described in the upgrade path passed
 as argument.
 
 =cut
-sub memory_needed {
-    my $upgrade_path = shift;
-    assert_defined($upgrade_path);
-    my $mem_factor = 2;
-    $mem_factor * $upgrade_path->{'total-size'};
+fun memory_needed (HashRef $upgrade_path) {
+    # We need:
+    #  - The size of the target file, because tails-iuk-get-target-file
+    #    will download in a temporary directory stored in the root filesystem's
+    #    union upper branch, that is in a tmpfs, that is in memory.
+    #  - Enough memory to run the tails-iuk-get-target-file process.
+    #  - Enough memory to run the tails-install-iuk process.
+    #  - Some margin, e.g. for the squashfs kernel module to decompress
+    #    the IUK when we copy its content to the system partition.
+    my $get_target_file_process_memory = 60 * 1024 * 1024;
+    my $install_iuk_process_memory = 90 * 1024 * 1024;
+    my $margin = 64 * 1024 * 1024;
+
+    $upgrade_path->{'total-size'}
+        + $get_target_file_process_memory
+        + $install_iuk_process_memory
+        + $margin;
 }
 
 =head2 space_needed
@@ -458,22 +492,40 @@ partition to download and install the incremental upgrade described in
 the upgrade path passed as argument.
 
 =cut
-sub space_needed {
-    my $upgrade_path = shift;
-    assert_defined($upgrade_path);
-    my $space_factor = 3.0;
-    $space_factor * $upgrade_path->{'total-size'};
+fun space_needed (HashRef $upgrade_path) {
+    # At this point, we only know the size of the target file,
+    # which is an IUK, i.e. a (compressed) SquashFS, whose content
+    # will be copied to the system partition: vmlinuz, initrd; EFI,
+    # isolinux, and utils directories; SquashFS diff.
+    #
+    # So the question basically boils down to: how well is the IUK
+    # compressed?
+    #
+    # In practice, in most cases the total size of the IUK content is
+    # dominated by the size of the SquashFS diff and the initrd, which
+    # are already heavily compressed and won't be compressed further
+    # in the IUK. So in most cases, we only need to leave room for
+    # a tiny bit of margin, hence a $space_factor not much bigger
+    # than 1 should do the job.
+    #
+    # Still, let's give ourselves a bit of margin, in the form or an
+    # additional constant, just in case, for whatever reason, we ever
+    # generate an IUK whose content is mostly uncompressed data,
+    # and our $space_factor is not sufficient in itself.
+    my $space_factor = 1.2;
+    my $space_margin = 64 * 1024;
+    $space_factor * $upgrade_path->{'total-size'} + $space_margin;
 }
 
-method get_target_files ($upgrade_path, $url_transform, $destdir) {
+method get_target_files (HashRef $upgrade_path, CodeRef $url_transform, AbsDir $destdir) {
     my $title = $self->encoding->decode(gettext("Downloading upgrade"));
     my $info = $self->encoding->decode(errf(
         gettext(
             "Downloading the upgrade to %{name}s %{version}s..."
         ),
         {
-            name        => $self->product_name,
-            version     => $upgrade_path->{version},
+            name    => $self->product_name,
+            version => $upgrade_path->{version},
         }
     ));
     $self->info($info);
@@ -482,10 +534,10 @@ method get_target_files ($upgrade_path, $url_transform, $destdir) {
         my @cmd = (
             'tails-iuk-get-target-file',
             '--uri',         $url_transform->($target_file->{url}),
-            '--hash-type',   'sha256',
-            '--hash-value',  $target_file->{sha256},
+            '--hash_type',   'sha256',
+            '--hash_value',  $target_file->{sha256},
             '--size',        $target_file->{size},
-            '--output-file', $target_file->{output_file},
+            '--output_file', $target_file->{output_file},
         );
         if (! $ENV{HARNESS_ACTIVE}) {
             @cmd = ('sudo', '-n', '-u', 'tails-iuk-get-target-file', @cmd);
@@ -494,11 +546,11 @@ method get_target_files ($upgrade_path, $url_transform, $destdir) {
         my $success = 1;
 
         if ($self->batch) {
-            run \@cmd, '2>', \$stderr or $success = 0;
+            IPC::Run::run \@cmd, '2>', \$stderr or $success = 0;
             $exit_code = $?;
         }
         else {
-            run \@cmd, '2>', \$stderr,
+            IPC::Run::run \@cmd, '2>', \$stderr,
                 '|', [qw{zenity --progress --percentage=0 --auto-close
                          --no-cancel}, '--title', $title, '--text', $info]
                 or $success = 0;
@@ -551,7 +603,7 @@ method get_target_files ($upgrade_path, $url_transform, $destdir) {
     }
 }
 
-method do_incremental_upgrade ($upgrade_path) {
+method do_incremental_upgrade (HashRef $upgrade_path) {
     my ($stdout, $stderr, $success, $exit_code);
 
     my ($target_files_tempdir) = $self->fatal_run_cmd(
@@ -598,7 +650,7 @@ method do_incremental_upgrade ($upgrade_path) {
     };
 
     $self->get_target_files(
-        $upgrade_path, $url_transform, $target_files_tempdir
+        $upgrade_path, $url_transform, path($target_files_tempdir)
     );
 
     $self->dialog(
@@ -614,7 +666,7 @@ method do_incremental_upgrade ($upgrade_path) {
         ok_label => $self->encoding->decode(gettext(q{Apply upgrade})),
     );
 
-    $self->install_iuk($upgrade_path, $target_files_tempdir);
+    $self->install_iuk($upgrade_path, path($target_files_tempdir));
 
     $self->dialog(
         $self->encoding->decode(gettext(
@@ -631,7 +683,7 @@ method do_incremental_upgrade ($upgrade_path) {
     exit(0);
 }
 
-method restart_system {
+method restart_system () {
     $self->info("Restarting the system");
     $self->fatal_run_cmd(
         cmd       => ['/sbin/reboot'],
@@ -645,11 +697,11 @@ method restart_system {
     ) unless $ENV{HARNESS_ACTIVE};
 }
 
-method do_full_upgrade ($upgrade_path) {
+method do_full_upgrade (HashRef $upgrade_path) {
     exit(0);
 }
 
-method shutdown_network {
+method shutdown_network () {
     $self->info("Shutting down network connection");
     $self->fatal_run_cmd(
         cmd       => ['tails-shutdown-network'],
@@ -663,10 +715,7 @@ method shutdown_network {
     ) unless $ENV{HARNESS_ACTIVE};
 }
 
-method install_iuk ($upgrade_path, $target_files_tempdir) {
-    assert_defined($upgrade_path);
-    assert_defined($target_files_tempdir);
-
+method install_iuk (HashRef $upgrade_path, AbsDir $target_files_tempdir) {
     my $title = $self->encoding->decode(gettext("Upgrading the system"));
     my $info = $self->encoding->decode(gettext(
         "<b>Your Tails device is being upgraded...</b>\n\n".
@@ -681,7 +730,7 @@ method install_iuk ($upgrade_path, $target_files_tempdir) {
 
     my @args;
     push @args, (
-        '--override-liveos-mountpoint', $self->override_liveos_mountpoint
+        '--override_liveos_mountpoint', $self->override_liveos_mountpoint
     ) if $self->has_override_liveos_mountpoint;
 
     my @cmd = ('tails-install-iuk', @args, $target_files[0]->{output_file});
@@ -692,9 +741,9 @@ method install_iuk ($upgrade_path, $target_files_tempdir) {
     my ($exit_code, $stdout, $stderr, $zenity_h);
     my $success = 1;
 
-    $zenity_h = start [qw{zenity --progress --pulsate --no-cancel},
+    $zenity_h = IPC::Run::start [qw{zenity --progress --pulsate --no-cancel},
                        '--title', $title, '--text', $info] unless $self->batch;
-    run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
+    IPC::Run::run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
     $exit_code = $?;
     $zenity_h->kill_kill unless $self->batch;
 
@@ -723,5 +772,5 @@ method install_iuk ($upgrade_path, $target_files_tempdir) {
     );
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/Install.pm b/usr/share/perl5/Tails/IUK/Install.pm
index 4976530..27e0af5 100644
--- a/usr/share/perl5/Tails/IUK/Install.pm
+++ b/usr/share/perl5/Tails/IUK/Install.pm
@@ -6,20 +6,12 @@ Tails::IUK::Install - install an Incremental Upgrade Kit
 
 package Tails::IUK::Install;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
-
-
-with 'MooseX::Getopt::Dashes';
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -27,21 +19,19 @@ use Carp::Assert::More;
 use Cwd;
 use Data::Dumper;
 use File::Copy;
-use Path::Class;
 use File::Temp qw{tempdir tempfile};
+use Function::Parameters;
+use Path::Tiny;
 use Try::Tiny;
-
 use Tails::IUK::Read;
-use Tails::IUK::Utils qw{run_as_root space_available};
+use Tails::IUK::Utils qw{run_as_root space_available_in};
 use Tails::RunningSystem;
+use Types::Path::Tiny qw{AbsDir AbsFile AbsPath};
+use Types::Standard qw{ArrayRef InstanceOf Str};
 
+use namespace::clean;
 
-=head1 TYPES
-
-=cut
-
-class_type('Tails::IUK::Read');
-class_type('Tails::RunningSystem');
+use MooX::Options;
 
 
 =head1 ATTRIBUTES
@@ -49,27 +39,60 @@ class_type('Tails::RunningSystem');
 =cut
 
 has 'reader' =>
-    lazy_build ro 'Tails::IUK::Read',
-    handles => [ qw{list_archives file delete_files delete_files_count locate space_needed squashfs_in_archive} ];
-
-has 'override_liveos_mountpoint'     => coerce lazy_build ro 'Path::Class::Dir';
-has 'override_system_partition_file' => lazy_build ro 'Str';
-has 'override_boot_device_file'      => lazy_build ro 'Str';
-
-has 'tempdir'       => lazy_build ro 'Path::Class::Dir', predicate 'has_tempdir';
-has 'modules_file'  => lazy_build ro 'Path::Class::File';
-has 'from_file'     => required ro 'Str';
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::IUK::Read'],
+    handles => [
+        qw{file delete_files delete_files_count},
+        qw{space_needed squashfs_in_overlay} ];
+
+option 'override_liveos_mountpoint' =>
+    is        => 'lazy',
+    isa       => AbsDir,
+    coerce    => AbsDir->coercion,
+    format    => 's',
+    predicate => 1;
+
+option 'override_system_partition_file' =>
+    is        => 'lazy',
+    isa       => AbsPath,
+    coerce    => AbsPath->coercion,
+    format    => 's',
+    predicate => 1;
+
+option 'override_boot_device_file' =>
+    is        => 'lazy',
+    isa       => AbsPath,
+    coerce    => AbsPath->coercion,
+    format    => 's',
+    predicate => 1;
+
+has 'tempdir' =>
+    is        => 'lazy',
+    isa       => AbsDir,
+    predicate => 1;
+
+has 'modules_file' =>
+    is  => 'lazy',
+    isa => AbsFile;
+
+has 'from_file' =>
+    required => 1,
+    is       => 'ro',
+    isa      => AbsFile,
+    coerce   => AbsFile->coercion;
 
 has 'installed_squashfs' =>
-    lazy_build ro 'ArrayRef[Str]',
-    traits => [ 'Array' ],
-    handles => {
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         record_installed_squashfs => 'push',
         all_installed_squashfs    => 'elements',
     };
 
 has 'running_system' =>
-    lazy_build ro 'Tails::RunningSystem',
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::RunningSystem'],
     handles => [ qw{boot_device_file system_partition_file liveos_mountpoint} ];
 
 
@@ -77,7 +100,7 @@ has 'running_system' =>
 
 =cut
 
-method _build_tempdir {
+method _build_tempdir () {
     $self->remount_liveos_rw;
 
     my $base_live_tmp_dir = $self->liveos_mountpoint->child('tmp')->stringify;
@@ -93,28 +116,28 @@ method _build_tempdir {
     # This is useless in Tails, but useful for testing.
     run_as_root(qw{chmod -R go+rX}, $base_live_tmp_dir);
 
-    dir($tempdir);
+    path($tempdir);
 }
 
-method _build_installed_squashfs { [] }
+method _build_installed_squashfs () { [] }
 
-method _build_modules_file {
-    file($self->liveos_mountpoint, 'live', 'Tails.module');
+method _build_modules_file () {
+    path($self->liveos_mountpoint, 'live', 'Tails.module');
 }
 
-method _build_reader {
+method _build_reader () {
     Tails::IUK::Read->new_from_file(
         $self->from_file,
         tempdir => $self->tempdir,
     );
 }
 
-method clean {
+method clean () {
     run_as_root(qw{rm --recursive --force --preserve-root}, $self->tempdir)
         if $self->has_tempdir;
 }
 
-method _build_running_system {
+method _build_running_system () {
     my @args;
     for (qw{boot_device_file system_partition_file liveos_mountpoint}) {
         my $attribute = "override_$_";
@@ -126,7 +149,7 @@ method _build_running_system {
     Tails::RunningSystem->new(@args);
 }
 
-method DEMOLISH {
+method DEMOLISH (@args) {
     $self->clean;
 }
 
@@ -143,41 +166,53 @@ method fatal (@msg) {
     );
 }
 
-method space_available {
-    space_available($self->liveos_mountpoint->stringify);
+method space_available () {
+    space_available_in($self->liveos_mountpoint);
 }
 
-method upgrade_modules_file {
-    my @installed_squashfs = $self->all_installed_squashfs;
+method delete_obsolete_squashfs_diffs () {
+    my @keep = (
+        $self->liveos_mountpoint->child('live', 'filesystem.squashfs'),
+        (map {path($self->liveos_mountpoint, 'live', $_)}
+             $self->all_installed_squashfs),
+    );
 
-    my $append_str = join("\n", map { file($_)->basename } @installed_squashfs);
-    if (length($append_str)) {
-        my ($temp_fh, $temp_file) = tempfile;
-        copy($self->modules_file->stringify, $temp_fh)
-            or $self->fatal(sprintf(
-                "Could not copy modules file ('%s') to temporary file ('%s')",
-                $self->modules_file, $temp_file,
-            ));
-        close $temp_fh;
-
-        $temp_fh = file($temp_file)->open('a');
-        say $temp_fh $append_str;
-        close $temp_fh;
-        system('sync');
-
-        run_as_root('nocache', '/bin/cp', '--force', $temp_file, $self->modules_file);
+    for my $candidate ($self->liveos_mountpoint->path('live')->children) {
+        next if "$candidate" !~ m{[.] squashfs\z}xms;
+        next if grep { "$candidate" eq "$_" } @keep;
+        run_as_root('rm', '--force', "$candidate");
     }
 }
 
-method remount_liveos_rw {
+method upgrade_modules_file () {
+    my @installed_squashfs = $self->all_installed_squashfs;
+
+    my $new_squashfs_str = join("\n", map { path($_)->basename } @installed_squashfs);
+    my ($temp_fh, $temp_file) = tempfile;
+    copy($self->modules_file->stringify, $temp_fh)
+        or $self->fatal(sprintf(
+            "Could not copy modules file ('%s') to temporary file ('%s')",
+            $self->modules_file, $temp_file,
+        ));
+    close $temp_fh;
+
+    $temp_fh = path($temp_file)->openw;
+    say $temp_fh 'filesystem.squashfs', "\n", $new_squashfs_str;
+    close $temp_fh;
+    system('sync');
+
+    run_as_root('nocache', '/bin/cp', '--force', $temp_file, $self->modules_file);
+}
+
+method remount_liveos_rw () {
     run_as_root(qw{mount -o}, "remount,rw", $self->liveos_mountpoint);
 }
 
-method remount_liveos_sync {
+method remount_liveos_sync () {
     run_as_root(qw{mount -o}, "remount,sync", $self->liveos_mountpoint);
 }
 
-method run {
+method run () {
     unless ($self->space_available > $self->space_needed) {
         $self->fatal(
             "There is too little available space on Tails system partition, aborting"
@@ -186,25 +221,24 @@ method run {
 
     $self->remount_liveos_rw;
 
-    my $orig_cwd = getcwd;
-    foreach (sort $self->list_archives) {
-        my $archive_filename = $_;
-
-        chdir $self->liveos_mountpoint;
-        # In a real Tails, /lib/live/mount/medium is not writable by non-root.
-        run_as_root('tar', '-x', '--no-same-owner', '--no-same-permissions',
-                    '-f', $self->locate($archive_filename));
+    # In a real Tails, /lib/live/mount/medium is not writable by non-root.
+    run_as_root(
+        'rsync',
+        '--recursive',
+        '--links',
+        '--perms',
+        '--times',
+        '--chown=root:root',
+        $self->reader->overlay_dir . '/',
+        $self->liveos_mountpoint . '/'
+    );
 
-        $self->record_installed_squashfs($self->squashfs_in_archive(
-            $self->locate($archive_filename)
-        ));
-    }
-    chdir $orig_cwd;
+    $self->record_installed_squashfs($self->squashfs_in_overlay);
 
     if ($self->delete_files_count) {
         run_as_root(
             'rm', '--recursive', '--force',
-            map { file($self->liveos_mountpoint, $_) } @{$self->delete_files}
+            map { path($self->liveos_mountpoint, $_) } @{$self->delete_files}
         );
     }
 
@@ -212,15 +246,17 @@ method run {
 
     $self->upgrade_modules_file;
 
+    $self->delete_obsolete_squashfs_diffs;
+
     # upgrade syslinux' ldlinux.sys
-    my $syslinux = file($self->liveos_mountpoint, qw{utils linux syslinux});
+    my $syslinux = path($self->liveos_mountpoint, qw{utils linux syslinux});
     run_as_root($syslinux, qw{-d syslinux}, $self->system_partition_file)
         if -e $syslinux;
 
     # upgrade the MBR
-    my $mbr = file($self->liveos_mountpoint, qw{utils mbr mbr.bin});
+    my $mbr = path($self->liveos_mountpoint, qw{utils mbr mbr.bin});
     run_as_root(
-        'dd', "if=$mbr", 'of='.$self->boot_device_file, 'bs=1', 'count=440',
+        'dd', 'status=none', "if=$mbr", 'of='.$self->boot_device_file, 'bs=1', 'count=440',
     ) if -e $mbr;
 
     system('sync');
@@ -228,5 +264,5 @@ method run {
     $self->clean;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm b/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm
index d6e598a..4da3ddd 100644
--- a/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm
+++ b/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm
@@ -7,8 +7,7 @@ Tails::IUK::LWP::UserAgent::WithProgress - LWP::UserAgent subclass that displays
 package Tails::IUK::LWP::UserAgent::WithProgress;
 
 use 5.10.1;
-use strict;
-use warnings;
+use strictures 2;
 use autodie qw(:all);
 
 use parent 'LWP::UserAgent';
diff --git a/usr/share/perl5/Tails/IUK/Read.pm b/usr/share/perl5/Tails/IUK/Read.pm
index e52e0a8..d134cfb 100644
--- a/usr/share/perl5/Tails/IUK/Read.pm
+++ b/usr/share/perl5/Tails/IUK/Read.pm
@@ -6,38 +6,29 @@ Tails::IUK::Read - read Incremental Upgrade Kit files
 
 package Tails::IUK::Read;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
-
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Cwd;
 use Data::Dumper;
-use File::Temp qw{tempdir tempfile};
+use File::Temp;
+use Function::Parameters;
 use List::Util qw{sum};
-use Path::Class;
+use Path::Tiny;
 use Try::Tiny;
 use YAML::Any;
+use Tails::IUK::Utils qw{directory_size run_as_root};
+use Types::Path::Tiny qw{AbsDir AbsFile Path};
+use Types::Standard qw{ArrayRef ClassName HashRef InstanceOf Str};
 
-use Tails::IUK::Archive::Tar;
-use Tails::IUK::Utils qw{run_as_root unpacked_size};
-
-=head1 TYPES
-
-=cut
-
-class_type('Tails::IUK::Archive::Tar');
+use namespace::clean;
 
 
 =head1 ATTRIBUTES
@@ -45,69 +36,81 @@ class_type('Tails::IUK::Archive::Tar');
 =cut
 
 has 'file' => (
-    isa => 'Path::Class::File',
+    isa      => AbsFile,
     required => 1,
-    is => 'ro',
+    is       => 'ro',
 );
 
-has 'format_version' => lazy_build ro Str;
-has 'control'        => lazy_build ro 'HashRef';
-has 'delete_files'   => lazy_build ro 'ArrayRef[Str]',
-    traits => [ 'Array' ],
-    handles => {
+has 'format_version' =>
+    is  => 'lazy',
+    isa => Str;
+
+has 'control' =>
+    is  => 'lazy',
+    isa => HashRef;
+
+has 'delete_files'   =>
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         delete_files_count => "count",
     };
 
-has 'archive' => (
-    isa => 'Tails::IUK::Archive::Tar',
-    is => 'ro',
-    lazy_build => 1,
-    handles => [ qw{get_content locate} ],
-);
+has 'files' =>
+    is  => 'lazy',
+    isa => ArrayRef;
 
-has 'files' => lazy_build ro 'ArrayRef[Str]';
-has 'archives' => lazy_build ro 'ArrayRef[Path::Class::File]';
-has 'tempdir'  => lazy_build ro 'Path::Class::Dir', predicate 'has_tempdir';
+has 'archives' =>
+    is  => 'lazy',
+    isa => ArrayRef;
 
+has 'tempdir' =>
+    is        => 'lazy',
+    isa       => AbsDir,
+    predicate => 1;
+
+has 'mountpoint' =>
+    is        => 'lazy',
+    isa       => AbsDir,
+    predicate => 1;
 
 =head1 METHODS
 
 =cut
 
-method _build_format_version {
+method _build_mountpoint () {
+    my $mountpoint = path(File::Temp::tempdir(CLEANUP => 0));
+    run_as_root('mount', $self->file, $mountpoint);
+    return $mountpoint;
+}
+
+method _build_format_version () {
     my $format_version;
     try {
-        $format_version = $self->get_content('FORMAT');
+        $format_version = $self->get_content(path('FORMAT'));
     } catch {
         croak "The format version cannot be determined:\n$_";
     };
     return $format_version;
 }
 
-method _build_archive {
-    Tails::IUK::Archive::Tar->new(
-        filename => $self->file->stringify,
-        sudo     => 1,
-        tempdir  => $self->tempdir,
-    );
-}
-
-method _build_delete_files {
+method _build_delete_files () {
     my $delete_files = $self->control->{delete_files};
     $delete_files ||= [];
     return $delete_files;
 }
 
-method _build_control {
-    my $control = YAML::Any::Load($self->get_content('control.yml'));
+method _build_control () {
+    my $control = YAML::Any::Load($self->get_content(path('control.yml')));
     $control = {} unless defined $control;
     return $control;
 }
 
-method _build_files { [ $self->archive->files ] }
+method _build_files () { [ $self->archive->files ] }
 
-method _build_archives {
-    return [ map { file($_) } grep {
+method _build_archives () {
+    return [ map { path($_) } grep {
         $_ =~ m{
                    [.] tar       # literal .tar
                    (?: [.] bz2 )? # possibly followed by literal .bz2
@@ -116,65 +119,69 @@ method _build_archives {
     } $self->list_files ];
 }
 
-method _build_tempdir { dir(tempdir(CLEANUP => 0)) };
+method _build_tempdir () { path(File::Temp::tempdir(CLEANUP => 0)) };
 
-method BUILD {
+method BUILD (@args) {
     my $format_version;
     try {
         $format_version = $self->format_version();
     } catch {
         croak "The format version cannot be determined:\n$_";
     };
-    $format_version eq '1'
+    $format_version eq '2'
         or croak(sprintf("Unsupported format: %s", $format_version));
 }
 
-sub new_from_file {
-    my $class = shift;
-    my $filename = shift;
-
+fun new_from_file (ClassName $class, AbsFile $filename, @rest) {
     return $class->new(
-        file => file($filename),
-        @_,
+        file => path($filename),
+        @rest,
     );
 }
 
-method clean {
+method clean () {
     run_as_root(qw{rm --recursive --force --preserve-root}, $self->tempdir)
         if $self->has_tempdir;
+    run_as_root('umount', $self->mountpoint) if $self->has_mountpoint;
 }
 
-method DEMOLISH {
+method DEMOLISH (@args) {
     $self->clean;
 }
 
-method list_files { @{$self->files} }
-
-method space_needed {
-    sum(0, map { unpacked_size($self->locate($_)) } $self->list_archives);
+method get_content (Path $filename) {
+    $self->mountpoint->child($filename)->slurp;
 }
 
-method contains_file ($filename) {
-    1 == grep { $_ eq $filename } $self->list_files;
+method list_files () {
+    my @files;
+    my $iter = $self->mountpoint->iterator({ recurse => 1 });
+    while (my $path = $iter->()) {
+        push @files, $path->relative($self->mountpoint);
+    }
+    return @files;
 }
 
-method squashfs_in_archive ($archive_filename) {
-    my $tempdir = $self->tempdir->subdir(
-        file($archive_filename)->basename . "_tempdir"
-    );
-    run_as_root('mkdir', '--parents', '--mode=0755', $tempdir);
-    -d $tempdir or croak "Could not make '$tempdir' directory: $!";
+method overlay_dir () {
+    $self->mountpoint->child('overlay');
+}
 
-    my $archive = Tails::IUK::Archive::Tar->new(
-        filename => $archive_filename,
-        tempdir  => $tempdir,
-        sudo     => 1,
-    );
+method space_needed () {
+    $self->overlay_dir->exists ? directory_size($self->overlay_dir) : 0;
+}
 
-    grep { m{[.] squashfs \z}xms } $archive->files;
+method contains_file (Path $filename) {
+    1 == grep { $_ eq $filename } $self->list_files;
 }
 
-method list_archives () { @{$self->archives} }
+method squashfs_in_overlay () {
+    return unless $self->overlay_dir->child('live')->exists;
+    map {
+        $_->basename
+    } grep {
+        -f $_
+    } $self->overlay_dir->child('live')->children(qr/[.]squashfs\z/);
+}
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/TargetFile/Download.pm b/usr/share/perl5/Tails/IUK/TargetFile/Download.pm
index c0068aa..3bd67c9 100644
--- a/usr/share/perl5/Tails/IUK/TargetFile/Download.pm
+++ b/usr/share/perl5/Tails/IUK/TargetFile/Download.pm
@@ -6,56 +6,64 @@ Tails::IUK::TargetFile::Download - download and verify a target file
 
 package Tails::IUK::TargetFile::Download;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{enum};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
 
-
-
-with 'MooseX::Getopt::Dashes';
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Cwd;
-use Data::Dumper;
 use Digest::SHA;
 use File::Temp qw{tempfile};
+use Function::Parameters;
 use HTTP::Request;
-use Path::Class;
+use Path::Tiny;
 use String::Errf qw{errf};
 use Tails::IUK::LWP::UserAgent::WithProgress;
-use Tails::IUK::Utils qw{space_available};
-
-
-=head1 TYPES
+use Tails::IUK::Utils qw{space_available_in};
+use Types::Path::Tiny qw{AbsPath};
+use Types::Standard qw{Enum Int Str};
 
-=cut
+use namespace::clean;
 
-enum 'Tails::IUK::TargetFile::HashType', ['sha256'];
+use MooX::Options;
 
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'uri'         => required ro Str;
-has 'hash_type'   => required ro 'Tails::IUK::TargetFile::HashType';
-has 'hash_value'  => required ro Str;
-has 'output_file' => coerce required ro 'Path::Class::File';
-has 'size'        => required ro Int;
-
-
-=head1 CONSTRUCTORS AND BUILDERS
-
-=cut
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => Str,
+    format   => 's',
+) for (qw{uri hash_value});
+
+option 'hash_type' => (
+    required => 1,
+    is       => 'ro',
+    isa      => Enum[qw{sha256}],
+    format   => 's',
+);
+
+option 'output_file' => (
+    required => 1,
+    is       => 'ro',
+    isa      => AbsPath,
+    coerce   => AbsPath->coercion,
+    format   => 's',
+);
+
+option 'size' => (
+    required => 1,
+    is       => 'ro',
+    isa      => Int,
+    format   => 's',
+);
 
 
 =head1 METHODS
@@ -67,9 +75,9 @@ method fatal (@msg) {
 }
 
 method check_available_space () {
-    my $target_dir      = $self->output_file->parent->stringify;
+    my $target_dir      = $self->output_file->parent;
     my $space_needed    = $self->size;
-    my $space_available = space_available($target_dir);
+    my $space_available = space_available_in($target_dir);
     $space_available >= $space_needed or $self->fatal(errf(
         "Downloading this incremental upgrade requires %{space_needed}s ".
         "of free space in %{target_dir}s, but only %{space_available}s is available.",
@@ -84,7 +92,7 @@ method check_available_space () {
 method run () {
     $self->check_available_space;
 
-    my $ua  = Tails::IUK::LWP::UserAgent::WithProgress->new(ssl_opts => {
+    my $ua = Tails::IUK::LWP::UserAgent::WithProgress->new(ssl_opts => {
         verify_hostname => 0,
         SSL_verify_mode => 0,
     });
@@ -131,10 +139,15 @@ method run () {
 
     my $sha = Digest::SHA->new(256);
     $sha->addfile($temp_filename);
-    $sha->hexdigest eq $self->hash_value or clean_fatal(
+    my $actual_hash = $sha->hexdigest;
+    $actual_hash eq $self->hash_value or clean_fatal(
         $self, $temp_filename, sprintf(
-            "The file '%s' was downloaded but its hash is not correct",
-        $self->uri,
+            "The file '%s' was downloaded but its hash is not correct:\n"
+                . "  - expected: %s\n"
+                . "  - actual:   %s",
+            $self->uri,
+            $self->hash_value,
+            $actual_hash,
     ));
 
     rename($temp_filename, $self->output_file);
@@ -147,5 +160,5 @@ method run () {
     return 1;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm
index 0139fc1..11aa604 100644
--- a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm
+++ b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm
@@ -6,15 +6,12 @@ Tails::IUK::UpgradeDescriptionFile - describe and manipulate a Tails upgrade-des
 
 package Tails::IUK::UpgradeDescriptionFile;
 
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -23,33 +20,44 @@ use Carp::Assert::More;
 use Data::Dumper;
 use Dpkg::Version qw{version_compare};
 use English qw{-no_match_vars};
+use Function::Parameters;
 use List::MoreUtils qw{any};
 use List::Util qw{sum};
-use Path::Class;
+use Path::Tiny;
+use Types::Standard qw{ArrayRef Str};
 use YAML::Any;
 
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has "$_"    => required ro Str, predicate => "has_$_"
-    for (qw{product_name product_version build_target channel});
+has "$_" => (
+    required  => 1,
+    is        => 'ro',
+    isa       => Str,
+    predicate => 1,
+) for (qw{product_name initial_install_version build_target channel});
 
 has upgrades =>
-    lazy_build ro ArrayRef,
-    traits => [ 'Array' ],
-    handles => {
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         count_upgrades => 'count',
         all_upgrades   => 'elements',
         add_upgrade    => 'push',
         empty_upgrades => 'clear',
-    };
+    },
+    predicate   => 1;
 
 has upgrade_paths =>
-    lazy_build ro ArrayRef,
-    traits => [ 'Array' ],
-    handles => {
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         count_upgrade_paths => 'count',
         all_upgrade_paths   => 'elements',
     };
@@ -59,9 +67,9 @@ has upgrade_paths =>
 
 =cut
 
-method _build_upgrades { return [] }
+method _build_upgrades () { return [] }
 
-method _build_upgrade_paths {
+method _build_upgrade_paths () {
     my @upgrade_paths;
     foreach my $upgrade ($self->all_upgrades) {
         exists $upgrade->{'upgrade-paths'} or $upgrade->{'upgrade-paths'} = [];
@@ -87,7 +95,7 @@ sub new_from_text {
     my $data = YAML::Any::Load($text);
 
     my %args;
-    foreach my $key (qw{product-name product-version channel build-target upgrades}) {
+    foreach my $key (qw{product-name initial-install-version channel build-target upgrades}) {
         next unless exists $data->{$key};
         my $attribute = $key; $attribute =~ s{-}{_}xmsg;
         $args{$attribute} = $data->{$key};
@@ -100,7 +108,7 @@ sub new_from_file {
     my $class    = shift;
     my $filename = shift;
 
-    my $content = file($filename)->slurp;
+    my $content = path($filename)->slurp;
     assert_nonblank($content);
 
     $class->new_from_text($content);
@@ -142,7 +150,7 @@ method full_upgrade_path () {
 method stringify () {
     my %data;
 
-    foreach my $attribute (qw{product_name product_version channel build_target upgrades}) {
+    foreach my $attribute (qw{product_name initial_install_version channel build_target upgrades}) {
         my $predicate = "has_$attribute";
         next unless $self->$predicate;
         my $key = $attribute; $key =~ s{_}{-}xmsg;
@@ -157,8 +165,7 @@ method stringify () {
 
 =cut
 
-sub path_to_newest_version {
-    my @paths = @_;
+fun path_to_newest_version (@paths) {
     assert(@paths);
 
     my $current_best_path = { version => '0' };
@@ -171,5 +178,5 @@ sub path_to_newest_version {
     return $current_best_path;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm
index 2459f6a..80fb52d 100644
--- a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm
+++ b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm
@@ -6,17 +6,12 @@ Tails::IUK::UpgradeDescriptionFile::Download - download and verify an upgrade de
 
 package Tails::IUK::UpgradeDescriptionFile::Download;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
-with 'MooseX::Getopt::Dashes';
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 extends 'Tails::Download::HTTPS';
 
@@ -24,47 +19,61 @@ use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Carp::Assert::More;
-use English qw{-no_match_vars};
+use Function::Parameters;
+use Path::Tiny;
 use Tails::RunningSystem;
 use Tails::IUK::Utils;
+use Types::Standard qw{InstanceOf Str};
+use Types::Path::Tiny qw{AbsDir};
 use YAML::Any;
 
+use namespace::clean;
 
-=head1 TYPES
-
-=cut
-
-class_type 'Tails::RunningSystem';
-
+use MooX::Options;
 
 =head1 ATTRIBUTES
 
 =cut
 
-has "$_" => lazy_build ro Str
-    for (qw{override_baseurl override_build_target override_os_release_file
-            trusted_gnupg_homedir});
-has 'running_system' =>
-    lazy_build ro 'Tails::RunningSystem',
+option "$_" => (
+    is         => 'ro',
+    format     => 's',
+    isa        => Str,
+    predicate  => 1,
+) for (qw{override_baseurl override_build_target override_os_release_file
+          override_initial_install_os_release_file});
+
+option trusted_gnupg_homedir => (
+    is         => 'lazy',
+    format     => 's',
+    isa        => AbsDir,
+    coerce     => AbsDir->coercion,
+    predicate  => 1,
+);
+
+has 'running_system' => (
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::RunningSystem'],
     handles => [
         qw{upgrade_description_file_url upgrade_description_sig_url},
-        qw{product_name product_version build_target channel}
-    ];
+        qw{product_name initial_install_version build_target channel}
+    ],
+);
 
 
 =head1 CONSTRUCTORS AND BUILDERS
 
 =cut
 
-method _build_trusted_gnupg_homedir     {
-    my $trusted_gnupg_homedir = '/usr/share/tails-iuk/trusted_gnupg_homedir';
+method _build_trusted_gnupg_homedir () {
+    my $trusted_gnupg_homedir = path('/usr/share/tails-iuk/trusted_gnupg_homedir');
     assert(-d $trusted_gnupg_homedir);
     return $trusted_gnupg_homedir;
 }
 
-method _build_running_system {
+method _build_running_system () {
     my @args;
-    for (qw{baseurl build_target os_release_file}) {
+    for (qw{baseurl build_target os_release_file initial_install_os_release_file}) {
         my $attribute = "override_$_";
         my $predicate = "has_$attribute";
         if ($self->$predicate) {
@@ -79,16 +88,18 @@ method _build_running_system {
 
 =cut
 
-method matches_running_system ($description_str) {
-    assert(defined $description_str);
+method matches_running_system (Str $description_str) {
     my $description = YAML::Any::Load($description_str);
     assert_hashref($description);
-    foreach (qw{product_name product_version build_target channel}) {
+    foreach (qw{product_name initial_install_version build_target channel}) {
         my $accessor = my $field = $_;
         $field =~ s{_}{-}gxms;
         exists  $description->{$field}             or return;
         defined $description->{$field}             or return;
-        $description->{$field} eq $self->$accessor or return;
+        if ($description->{$field} ne $self->$accessor) {
+            warn "Expected for field $field: ", $self->$accessor, ", got: ", $description->{$field};
+            return;
+        }
     }
     return 1;
 }
@@ -105,5 +116,5 @@ method run () {
     return;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm
index d4be264..207e7db 100644
--- a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm
+++ b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm
@@ -6,18 +6,11 @@ Tails::IUK::UpgradeDescriptionFile::Generate - create and update upgrade-descrip
 
 package Tails::IUK::UpgradeDescriptionFile::Generate;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class qw{Dir File};
-use MooseX::Has::Sugar::Saccharin;
-
-with 'MooseX::Getopt::Dashes';
+no Moo::sification;
+use Moo;
 
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -25,37 +18,73 @@ use Carp::Assert;
 use Carp::Assert::More;
 use Digest::SHA;
 use English qw{-no_match_vars};
-use Path::Class;
+use Function::Parameters;
+use Path::Tiny;
 use Tails::IUK::UpgradeDescriptionFile;
+use Types::Path::Tiny qw{AbsDir AbsFile};
+use Types::Standard qw{ArrayRef Bool Str};
 
+use namespace::clean;
 
-=head1 ATTRIBUTES
+use MooX::Options;
 
-=cut
 
-has previous_versions => required ro ArrayRef;
-has version           => required ro Str;
-has next_versions     => required ro ArrayRef;
-has major_release     => required ro Bool;
+=head1 ATTRIBUTES
 
-has iso               => required coerce ro File;
-has iuks              => required coerce ro Dir;
-has release_checkout  => required coerce ro Dir;
+=cut
 
-has build_target      => lazy_build ro Str;
-has channel           => lazy_build ro Str;
-has product_name      => lazy_build ro Str;
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => ArrayRef,
+    format   => 's@',
+) for (qw{previous_versions next_versions});
+
+option version => (
+    required => 1,
+    is       => 'ro',
+    isa      => Str,
+    format   => 's',
+);
+
+option major_release => (
+    required => 1,
+    is       => 'ro',
+    isa      => Bool,
+);
+
+option iso => (
+    required => 1,
+    is       => 'ro',
+    isa      => AbsFile,
+    coerce   => AbsFile->coercion,
+    format   => 's',
+);
+
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => AbsDir,
+    coerce   => AbsDir->coercion,
+    format   => 's',
+) for (qw{iuks release_checkout});
+
+option "$_" => (
+    is     => 'lazy',
+    isa    => Str,
+    format => 's',
+) for (qw{build_target channel product_name});
 
 
 =head1 CONSTRUCTORS AND BUILDERS
 
 =cut
 
-method _build_build_target  { 'amd64'   }
-method _build_channel       { 'stable' }
-method _build_product_name  { 'Tails'  }
+method _build_build_target () { 'amd64'   }
+method _build_channel      () { 'stable' }
+method _build_product_name () { 'Tails'  }
 
-method BUILD {
+method BUILD (@args) {
     assert(-f $self->iso);
     assert(-d $self->release_checkout);
 }
@@ -65,7 +94,7 @@ method BUILD {
 
 =cut
 
-method run {
+method run () {
     for my $channel (qw{alpha stable}) {
         say STDERR q{* Creating upgrade-description files for new release },
             '(', $self->version, "), ", $channel, " channel: \n  ",
@@ -95,10 +124,10 @@ method run {
 
 method create_udf_for_new_release ($channel) {
     my $description = Tails::IUK::UpgradeDescriptionFile->new(
-        product_name    => $self->product_name,
-        product_version => $self->version,
-        build_target    => $self->build_target,
-        channel         => $channel,
+        product_name            => $self->product_name,
+        initial_install_version => $self->version,
+        build_target            => $self->build_target,
+        channel                 => $channel,
     );
     $self->udf_for_new_release($channel)->parent->mkpath;
     $self->udf_for_new_release($channel)->spew(
@@ -110,10 +139,10 @@ method create_udf_for_next_release ($version, $channel) {
     my $udf = $self->udf_for($version, channel => $channel);
 
     my $description = Tails::IUK::UpgradeDescriptionFile->new(
-        product_name    => $self->product_name,
-        product_version => $version,
-        build_target    => $self->build_target,
-        channel         => $channel,
+        product_name            => $self->product_name,
+        initial_install_version => $version,
+        build_target            => $self->build_target,
+        channel                 => $channel,
     );
     $udf->parent->mkpath;
     $udf->spew($description->stringify);
@@ -128,10 +157,10 @@ method update_udf_for_previous_release ($previous_version) {
     }
     else {
         $description = Tails::IUK::UpgradeDescriptionFile->new(
-            product_name    => $self->product_name,
-            product_version => $previous_version,
-            build_target    => $self->build_target,
-            channel         => $self->channel,
+            product_name            => $self->product_name,
+            initial_install_version => $previous_version,
+            build_target            => $self->build_target,
+            channel                 => $self->channel,
         );
         $udf->parent->mkpath;
     }
@@ -182,10 +211,9 @@ method upgrade_paths_from_previous_release ($previous_version) {
     return @paths;
 }
 
-method udf_for ($version, :$channel?) {
-    defined($channel) or $channel = $self->channel;
-    file(
-        $self->release_checkout, qw{wiki src upgrade v1}, $self->product_name,
+method udf_for ($version, :$channel = $self->channel) {
+    path(
+        $self->release_checkout, qw{wiki src upgrade v2}, $self->product_name,
         $version, $self->build_target, $channel, 'upgrades.yml'
     );
 }
@@ -194,7 +222,7 @@ method udf_for_new_release ($channel) {
     $self->udf_for($self->version, channel => $channel)
 }
 
-method iso_url {
+method iso_url () {
     'http://dl.amnesia.boum.org/tails/'
         . $self->channel
         . '/'
@@ -231,14 +259,14 @@ method iuk_url ($previous_version) {
 }
 
 method iuk_for ($previous_version) {
-    file($self->iuks, $self->iuk_filename($previous_version));
+    path($self->iuks, $self->iuk_filename($previous_version));
 }
 
 method has_iuk_for ($previous_version) {
     -f $self->iuk_for($previous_version);
 }
 
-method details_url {
+method details_url () {
     my $version = version_for_website($self->version);
     if ($self->channel eq 'stable') {
         return 'https://tails.boum.org/news/version_'.$version.'/';
@@ -257,8 +285,7 @@ method details_url {
 
 =cut
 
-sub sha256_file {
-    my $file = shift;
+fun sha256_file ($file) {
     assert(-f $file);
 
     my $sha = Digest::SHA->new(256);
@@ -266,8 +293,7 @@ sub sha256_file {
     return $sha->hexdigest;
 }
 
-sub version_for_website {
-    my $version = shift;
+fun version_for_website ($version) {
     assert_defined($version);
     assert(length($version));
 
@@ -276,5 +302,5 @@ sub version_for_website {
     return $version;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/Utils.pm b/usr/share/perl5/Tails/IUK/Utils.pm
index 1b3d030..40d7ef4 100644
--- a/usr/share/perl5/Tails/IUK/Utils.pm
+++ b/usr/share/perl5/Tails/IUK/Utils.pm
@@ -6,43 +6,38 @@ Tails::IUK::Utils - utilities for Tails IUK
 
 package Tails::IUK::Utils;
 
-use strict;
-use warnings;
+use strictures 2;
 use 5.10.1;
 
-
-
 use Exporter;
 our @ISA = qw{Exporter};
 our @EXPORT = (
+    qw{directory_size},
     qw{extract_file_from_iso extract_here_file_from_iso fatal},
-    qw{get_temp_dir make_archive_with_files_called make_iuk_with_files},
-    qw{run_as_root space_available stdout_as_root unpacked_size},
+    qw{run_as_root space_available_in stdout_as_root},
     qw{verify_signature}
 );
 
 use autodie qw(:all);
-use Archive::Tar;
 use Carp;
 use Carp::Assert;
 use Carp::Assert::More;
-use Cwd;
 use Data::Dumper;
 use English qw{-no_match_vars};
-use File::Temp qw{tempdir tempfile};
+use File::Temp qw{tempfile};
 use GnuPG::Interface;
 use Filesys::Df;
-use IPC::System::Simple qw{capturex};
-use List::Util qw{sum};
-use Method::Signatures::Simple;
-use Path::Class;
+use Function::Parameters;
+use IPC::System::Simple qw{capturex systemx};
+use Path::Tiny;
+use Types::Path::Tiny qw{AbsDir AbsFile Path};
 
 
 =head1 FUNCTIONS
 
 =cut
 
-func extract_file_from_iso($file, $iso) {
+fun extract_file_from_iso(Path $file, AbsFile $iso) {
     my @cmd = qw{bsdtar -x --no-same-permissions --to-stdout --fast-read};
     push @cmd, ('--file', $iso, $file);
     open(my $cmd, '-|', @cmd);
@@ -52,7 +47,7 @@ func extract_file_from_iso($file, $iso) {
     return $output;
 }
 
-func extract_here_file_from_iso($dir, $iso) {
+fun extract_here_file_from_iso($dir, $iso) {
     my @cmd = qw{bsdtar -x --no-same-permissions};
     push @cmd, ('--file', $iso, $dir);
     system(@cmd);
@@ -60,19 +55,15 @@ func extract_here_file_from_iso($dir, $iso) {
     return;
 }
 
-func run_as_root(@command) {
+fun run_as_root(@command) {
     system("sudo", "-n", @command);
 }
 
-func stdout_as_root(@command) {
+fun stdout_as_root(@command) {
     capturex(qw{sudo -n}, @command);
 }
 
-sub get_temp_dir {
-    dir(tempdir(CLEANUP => 0));
-}
-
-func fatal (%args) {
+fun fatal (%args) {
     assert(exists $args{msg});
     assert_isa($args{msg}, 'ARRAY');
 
@@ -86,7 +77,7 @@ func fatal (%args) {
         }
         else {
             foreach my $dir (@{$args{rmtree}}) {
-                dir($dir)->rmtree;
+                path($dir)->remove_tree;
             }
         }
     }
@@ -94,94 +85,27 @@ func fatal (%args) {
     croak(@{$args{msg}});
 }
 
-func unpacked_size ($archive_file) {
-    assert(-e $archive_file);
-
-    sum(0,
-        map {
-            my $ret = 0;
-            if (my ($size) = (m{
-                                   \A           # at the beginning of the string
-                                   [-a-z]+      # permissions
-                                   [[:space:]]+
-                                   [[:digit:]]+ # owner
-                                   /
-                                   \d+          # group
-                                   [[:space:]]+
-                                   (\d+)        # size
-                                   [[:space:]]+
-                           }xms)) {
-                $ret = $size;
-            }
-            $ret;
-        } split(/\n/, `tar tv --numeric-owner -f $archive_file`)
-    );
-}
-
-func make_archive_with_files_called ($archive_file, %args) {
-    assert(exists $args{filenames});
-    assert_isa($args{filenames}, 'ARRAY');
-    assert_is(scalar(grep { exists $args{$_} } qw{size content}), 1);
-
-    my $archive = Archive::Tar->new();
-    my $orig_cwd = getcwd;
-    chdir $archive_file->dir;
-    foreach (@{$args{filenames}}) {
-        file($_)->dir->mkpath;
-        if (exists $args{content}) {
-            my $fh = file($_)->openw;
-            print $fh $args{content};
-            close $fh;
-        }
-        elsif (exists $args{size}) {
-            system("dd", "if=/dev/zero", "of=$_", "bs=1M", "count=".$args{size});
-            ${^CHILD_ERROR_NATIVE} == 0 or croak("Failed to create ", $args{size}, "MB file '$_'.");
-        }
-        $archive->add_files($_);
-    }
-    $archive->write($archive_file)
-        or croak("Failed to write '$archive_file':\n", $archive->error);
-    chdir $orig_cwd;
-}
-
-func make_iuk_with_files ($iuk_filename, $tempdir, @files) {
-    my $orig_cwd = getcwd;
-
-    my $iuk = Archive::Tar->new();
-    chdir $tempdir;
-
-    my $fh = file('FORMAT')->openw; print $fh 1; close $fh;
-    $iuk->add_files('FORMAT');
-    unless (grep { $_ eq 'control.yml' } @files) {
-        file('control.yml')->touch;
-        $iuk->add_files('control.yml');
-    }
-    map { $iuk->add_files($_) or croak("Could not add file '$_'", $iuk->error) } @files;
-
-    my $res = $iuk->write($iuk_filename);
-    chdir $orig_cwd;
-    $res or croak("Could not write IUK '$iuk_filename':\n", $iuk->error);
+fun directory_size (AbsDir $dir) {
+    my @du = split(/\s/, capturex(qw{/bin/du --block-size=1 --summarize}, $dir));
+    return $du[0];
 }
 
-=head2 space_available
+=head2 space_available_in
 
 Returns the number of available bytes there are in directory $dir.
 
 =cut
-func space_available ($dir) {
-    assert_defined($dir);
-
-    my $df = df($dir, 1); # "1" means "please return the value in bytes"
+fun space_available_in (AbsDir $dir) {
+    my $df = df($dir->stringify, 1); # "1" means "please return the value in bytes"
 
     assert_defined($df);
     assert_exists($df, 'bavail');
     return $df->{bavail};
 }
 
-func verify_signature ($txt, $signature_txt, $trusted_gnupg_homedir) {
+fun verify_signature ($txt, $signature_txt, AbsDir $trusted_gnupg_homedir) {
     assert_defined($txt);
     assert_nonblank($signature_txt);
-    assert(-d $trusted_gnupg_homedir);
 
     my $gnupg = GnuPG::Interface->new();
     $gnupg->options->hash_init(
