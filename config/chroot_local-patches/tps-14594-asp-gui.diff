diff --git a/usr/share/perl5/Tails/Persistence.pm b/usr/share/perl5/Tails/Persistence.pm
index 8d1e412..c79ac9b 100644
--- a/usr/share/perl5/Tails/Persistence.pm
+++ b/usr/share/perl5/Tails/Persistence.pm
@@ -4,10 +4,7 @@ Tails::Persistence - main placeholder module
 
 =cut
 
-use strict;
-use warnings FATAL => 'all';
+use strictures 2;
 use 5.10.0;
 
-
-
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration.pm b/usr/share/perl5/Tails/Persistence/Configuration.pm
index 9719481..d7f8a3e 100644
--- a/usr/share/perl5/Tails/Persistence/Configuration.pm
+++ b/usr/share/perl5/Tails/Persistence/Configuration.pm
@@ -5,81 +5,116 @@ Tails::Persistence::Configuration - manage live-persistence.conf and presets
 =cut
 
 package Tails::Persistence::Configuration;
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-
+use Moo;
+use MooX::late;
+use MooX::HandlesVia;
 
+use strictures 2;
 use autodie qw(:all);
-use warnings FATAL => 'all';
 use Carp;
+use Carp::Assert::More;
 
 use Tails::Persistence::Configuration::Atom;
-use Tails::Persistence::Configuration::File;
+use Tails::Persistence::Configuration::ConfigFile;
 use Tails::Persistence::Configuration::Presets;
+use Types::Path::Tiny qw{AbsPath};
 
+use List::MoreUtils qw{none};
 use Locale::gettext;
 use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-persistence-setup");
 
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'config_file_path' => lazy_build rw 'Path::Class::File';
-has 'file' =>
-    lazy_build rw 'Tails::Persistence::Configuration::File';
-has 'presets' =>
-    lazy_build rw 'Tails::Persistence::Configuration::Presets';
-has 'atoms' =>
-    lazy_build rw 'ArrayRef[Tails::Persistence::Configuration::Atom]',
-    traits  => [ 'Array' ],
-    handles => {
+has 'config_file_path' => (
+    required  => 1,
+    isa       => AbsPath,
+    is        => 'rw',
+    coerce    => AbsPath->coercion,
+);
+
+has 'file' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Tails::Persistence::Configuration::ConfigFile',
+);
+has 'presets' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Tails::Persistence::Configuration::Presets',
+);
+has 'force_enable_presets' => (
+    is      => 'ro',
+    isa     => 'ArrayRef[Str]',
+    default => sub { [] },
+);
+has 'atoms' => (
+    lazy_build => 1,
+    is            => 'rw',
+    isa           => 'ArrayRef[Tails::Persistence::Configuration::Atom]',
+    handles_via   => 'Array',
+    handles       => {
         all_atoms => 'elements',
-        push_atom  => 'push',
-    };
+        push_atom => 'push',
+    },
+);
 
 
 =head1 CONSTRUCTORS
 
 =cut
 
-method _build_file {
-    Tails::Persistence::Configuration::File->new(
-        path => $self->config_file_path
+sub _build_file {
+    my $self = shift;
+    my $file = Tails::Persistence::Configuration::ConfigFile->new(
+        config_file_path => $self->config_file_path
     );
+    return $file;
 }
 
-method _build_presets {
+sub _build_presets {
+    my $self = shift;
     Tails::Persistence::Configuration::Presets->new();
 }
 
-method _build_atoms {
-    return $self->merge_file_with_presets($self->file, $self->presets);
+sub _build_atoms {
+    my $self = shift;
+    return $self->merge_file_with_presets();
 }
 
 =head1 METHODS
 
 =cut
 
-method lines_not_in_presets {
+sub lines_not_in_presets {
+    my $self = shift;
     grep {
         my $line = $_;
-        ! grep { $_->equals_line($line) } $self->presets->all
+        ! grep { $_->equals_line($line) } $self->presets->atoms
     } $self->file->all_lines;
 }
 
-method merge_file_with_presets {
-    # Modifying and returning clones of the presets atoms would be a bit cleaner.
+sub atoms_not_in_presets {
+    my $self = shift;
+    grep {
+        my $atom = $_;
+        none { $atom->equals_atom($_) } $self->presets->atoms
+    } $self->all_atoms;
+}
+
+sub merge_file_with_presets {
+    my $self = shift;
     $self->presets->set_state_from_lines($self->file->all_lines);
+    $self->presets->set_state_from_overrides($self->force_enable_presets);
 
     [
-        $self->presets->all,
+        $self->presets->atoms,
         map {
             Tails::Persistence::Configuration::Atom->new_from_line(
                 $_,
@@ -89,11 +124,13 @@ method merge_file_with_presets {
     ];
 }
 
-method all_enabled_atoms {
+sub all_enabled_atoms {
+    my $self = shift;
     grep { $_->enabled } $self->all_atoms;
 }
 
-method all_enabled_lines {
+sub all_enabled_lines {
+    my $self = shift;
     map {
         Tails::Persistence::Configuration::Line->new(
             destination => $_->destination,
@@ -102,10 +139,11 @@ method all_enabled_lines {
     } $self->all_enabled_atoms;
 }
 
-method save {
+sub save {
+    my $self = shift;
     $self->file->lines([ $self->all_enabled_lines ]);
     $self->file->save;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration/Atom.pm b/usr/share/perl5/Tails/Persistence/Configuration/Atom.pm
index 768b2c5..6f9b273 100644
--- a/usr/share/perl5/Tails/Persistence/Configuration/Atom.pm
+++ b/usr/share/perl5/Tails/Persistence/Configuration/Atom.pm
@@ -5,35 +5,35 @@ Tails::Persistence::Configuration::Atom - a GUI-friendly configuration line
 =cut
 
 package Tails::Persistence::Configuration::Atom;
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
-
+use strictures 2;
+use Moo;
+use MooX::late;
 
 with 'Tails::Persistence::Role::ConfigurationLine';
-with 'Tails::Role::HasEncoding';
 
 use autodie qw(:all);
 use warnings FATAL => 'all';
 
 use List::MoreUtils qw{all pairwise};
 
-use Locale::gettext;
-use POSIX;
-setlocale(LC_MESSAGES, "");
-textdomain("tails-persistence-setup");
+use namespace::clean;
 
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'enabled'     => required rw Bool;
-has 'name'        => lazy_build rw Str;
-has 'description' => lazy_build rw Str;
-has 'icon_name'     => lazy_build rw Str;
+has 'enabled' => (
+    required => 1,
+    is       => 'rw',
+    isa      => 'Bool',
+);
+
+has 'id' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Str',
+);
 
 
 =head1 CONSTRUCTORS
@@ -52,21 +52,27 @@ sub new_from_line {
     );
 }
 
-method _build_name { $self->encoding->decode(gettext('Custom')); }
-
-method _build_description {
-    $self->encoding->decode($self->destination);
+sub _build_id {
+    my $self = shift;
+    'Custom';
 }
 
-method _build_icon_name { 'dialog-question' }
-
 
 =head1 METHODS
 
 =cut
 
+sub equals_atom {
+    my $self       = shift;
+    my $other_atom = shift;
+    $self->destination eq $other_atom->destination
+        and
+    $self->options_are(@{$other_atom->options});
+}
 
-method equals_line ($line) {
+sub equals_line {
+    my $self = shift;
+    my $line = shift;
     $self->destination eq $line->destination
         and
     $self->options_are($line->all_options);
@@ -85,5 +91,5 @@ sub options_are {
     } @expected, @options;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration/Button.pm b/usr/share/perl5/Tails/Persistence/Configuration/Button.pm
deleted file mode 100644
index 3540544..0000000
--- a/usr/share/perl5/Tails/Persistence/Configuration/Button.pm
+++ /dev/null
@@ -1,163 +0,0 @@
-=head1 NAME
-
-Tails::Persistence::Configuration::Button - a configuration button in the GUI
-
-=cut
-
-package Tails::Persistence::Configuration::Button;
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
-
-
-use autodie qw(:all);
-use warnings FATAL => 'all';
-use Glib qw{TRUE FALSE};
-use Pango;
-
-
-=head1 ATTRIBUTES
-
-=cut
-
-has 'atom'         => lazy_build ro 'Tails::Persistence::Configuration::Atom',
-    handles => [
-        qw{source destination all_options enabled name description icon_name}
-    ];
-has 'icon'         => lazy_build ro 'Gtk3::Image';
-has 'checked_img'  => lazy_build ro 'Gtk3::Image';
-has 'main_widget'  => lazy_build ro 'Gtk3::ToggleButton',
-    handles => {
-        is_active  => 'get_active',
-        set_active => 'set_active',
-    };
-has 'icon_theme' => ro 'Gtk3::IconTheme', builder '_build_icon_theme';
-has 'title_label'  => lazy_build ro 'Gtk3::Label';
-has 'description_label' => lazy_build ro 'Gtk3::Label';
-
-
-=head1 CONSTRUCTORS
-
-=cut
-
-method _build_icon {
-    Gtk3::Image->new_from_pixbuf($self->icon_theme->load_icon(
-        $self->icon_name, 48, 'use-builtin'
-    ));
-}
-
-method _build_checked_img {
-    # FIXME: we want the GTK_ICON_SIZE_SMALL_TOOLBAR
-    # member of the GtkIconSize enum, not a magic "16" number here.
-    Gtk3::Image->new_from_stock('gtk-apply', 16);
-}
-
-method _build_main_widget {
-    my $line = shift;
-
-    my $vbox = Gtk3::VBox->new();
-    $vbox->set_border_width(5);
-    $vbox->pack_start($self->title_label, FALSE, FALSE, 0);
-    $vbox->pack_start($self->description_label, FALSE, FALSE, 0);
-
-    my $hbox = Gtk3::HBox->new();
-    $hbox->pack_start($self->icon, FALSE, FALSE, 0);
-    $hbox->pack_start($vbox, TRUE, TRUE, 0);
-    $hbox->pack_start($self->checked_img, FALSE, FALSE, 0);
-
-    my $button = Gtk3::ToggleButton->new();
-    $button->add($hbox);
-    $button->set_active($self->enabled);
-    $button->signal_connect('toggled' => sub { $self->toggled_cb });
-
-    $button->signal_connect('show' => sub { $self->refresh_display });
-
-    return $button;
-}
-
-method _build_icon_theme {
-    my $theme = Gtk3::IconTheme::get_default();
-
-    $theme->append_search_path('/usr/share/pixmaps/cryptui/48x48');
-    $theme->append_search_path('/usr/share/pixmaps/seahorse/48x48');
-    $theme->append_search_path('/usr/share/icons/gnome-colors-common/32x32/apps/');
-    $theme->append_search_path('/usr/share/app-install/icons/');
-
-    return $theme;
- }
-
-method _build_title_label {
-    my $title = Gtk3::Label->new($self->name);
-    $title->set_alignment(0.0, 0.5);
-    my $title_attrlist  = Pango::AttrList->new;
-    $title_attrlist->insert($_)
-        foreach ( Pango::AttrScale->new(1.1),Pango::AttrWeight->new('bold') );
-    $title->set_attributes($title_attrlist);
-
-    return $title;
-}
-
-method _build_description_label {
-    my $description = Gtk3::Label->new($self->description);
-    $description->set_alignment(0.0, 0.5);
-    my $description_attrlist = Pango::AttrList->new;
-    $description_attrlist->insert(
-        Pango::AttrForeground->new(30000, 30000, 30000)
-      );
-    $description->set_attributes($description_attrlist);
-    $description->set_line_wrap(TRUE);
-    $description->set_line_wrap_mode('word');
-    $description->set_single_line_mode(FALSE);
-
-    return $description;
-}
-
-
-=head1 METHODS
-
-=cut
-
-method toggled_cb {
-    $self->atom->enabled($self->is_active);
-    $self->refresh_display;
-}
-
-method refresh_display {
-    $self->refresh_checked_img;
-    $self->refresh_text_color;
-}
-
-method refresh_checked_img {
-    if ($self->enabled) {
-        $self->checked_img->show;
-    }
-    else {
-        $self->checked_img->hide;
-    }
-}
-
-method refresh_text_color {
-    my %color = $self->enabled ?
-        (
-            title       => 0,
-            description => 30000,
-    ) : (
-            title       => 30000,
-            description => 40000,
-    );
-    my $attrlist = $self->title_label->get_attributes;
-    $attrlist->change(
-        Pango::AttrForeground->new($color{title}, $color{title}, $color{title})
-    );
-    $self->title_label->set_attributes($attrlist);
-    $attrlist = $self->description_label->get_attributes;
-    $attrlist->change(
-        Pango::AttrForeground->new($color{description}, $color{description}, $color{description})
-    );
-    $self->description_label->set_attributes($attrlist);
-}
-
-no Moose;
-1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration/ConfigFile.pm b/usr/share/perl5/Tails/Persistence/Configuration/ConfigFile.pm
new file mode 100644
index 0000000..16e5dbd
--- /dev/null
+++ b/usr/share/perl5/Tails/Persistence/Configuration/ConfigFile.pm
@@ -0,0 +1,99 @@
+=head1 NAME
+
+Tails::Persistence::Configuration::ConfigFile - read, parse and write live-persistence.conf
+
+=cut
+
+package Tails::Persistence::Configuration::ConfigFile;
+use strictures 2;
+use Moo;
+use MooX::late;
+use MooX::HandlesVia;
+
+use autodie qw(:all);
+use warnings FATAL => 'all';
+use Carp;
+use Tails::Persistence::Configuration::Line;
+use Types::Path::Tiny qw{AbsPath};
+
+use namespace::clean;
+
+
+=head1 ATTRIBUTES
+
+=cut
+
+has 'config_file_path' => (
+    isa      => AbsPath,
+    is       => 'ro',
+    coerce   => AbsPath->coercion,
+    required => 1,
+);
+
+has 'lines' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'ArrayRef[Tails::Persistence::Configuration::Line]',
+    handles_via   => [ 'Array' ],
+    handles       => {
+        all_lines => 'elements',
+    },
+);
+
+
+=head1 CONSTRUCTORS
+
+=cut
+
+sub BUILD {
+    my $self = shift;
+
+    $self->config_file_path->touch;
+}
+
+sub _build_lines {
+    my $self = shift;
+    return [
+        grep { defined $_ } map {
+            Tails::Persistence::Configuration::Line->new_from_string($_)
+        } $self->config_file_path->lines({chomp => 1})
+    ];
+}
+
+
+=head1 METHODS
+
+=cut
+
+=head2 output
+
+Returns the in-memory configuration, as a string in the live-persistence.conf format.
+
+=cut
+sub output {
+    my $self = shift;
+    my $out = "";
+    foreach ($self->all_lines) {
+        $out .= $_->stringify . "\n";
+    }
+    return $out;
+}
+
+=head2 save
+
+Save the in-memory configuration to disk.
+Throw exception on error.
+
+=cut
+sub save {
+    my $self = shift;
+    my $output = $self->output;
+    my $fh = $self->config_file_path->openw();
+    print $fh $output;
+    $fh->sync;
+    close $fh;
+    $self->config_file_path->chmod(0600);
+}
+
+no Moo;
+1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration/File.pm b/usr/share/perl5/Tails/Persistence/Configuration/File.pm
deleted file mode 100644
index aa76c16..0000000
--- a/usr/share/perl5/Tails/Persistence/Configuration/File.pm
+++ /dev/null
@@ -1,94 +0,0 @@
-=head1 NAME
-
-Tails::Persistence::Configuration::File - read, parse and write live-persistence.conf
-
-=cut
-
-package Tails::Persistence::Configuration::File;
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-
-
-use autodie qw(:all);
-use warnings FATAL => 'all';
-use Carp;
-use Path::Class;
-use Tails::Persistence::Configuration::Line;
-
-
-=head1 ATTRIBUTES
-
-=cut
-
-has 'path' => (
-    isa        => 'Path::Class::File',
-    is         => 'ro',
-    coerce     => 1,
-    required   => 1,
-);
-
-has 'lines' =>
-    lazy_build rw 'ArrayRef[Tails::Persistence::Configuration::Line]',
-    traits  => [ 'Array' ],
-    handles => {
-        all_lines => 'elements',
-    };
-
-
-=head1 CONSTRUCTORS
-
-=cut
-
-sub BUILD {
-    my $self = shift;
-
-    $self->path->touch;
-}
-
-method _build_lines {
-    return [
-        grep { defined $_ } map {
-            Tails::Persistence::Configuration::Line->new_from_string($_)
-        } $self->path->slurp(chomp => 1)
-    ];
-}
-
-
-=head1 METHODS
-
-=cut
-
-=head2 output
-
-Returns the in-memory configuration, as a string in the live-persistence.conf format.
-
-=cut
-method output {
-    my $out = "";
-    foreach ($self->all_lines) {
-        $out .= $_->stringify . "\n";
-    }
-    return $out;
-}
-
-=head2 save
-
-Save the in-memory configuration to disk.
-Throw exception on error.
-
-=cut
-method save {
-    my $output = $self->output;
-    my $fh = $self->path->openw();
-    print $fh $output;
-    $fh->sync;
-    close $fh;
-    chmod 0600, $self->path;
-}
-
-no Moose;
-1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration/Line.pm b/usr/share/perl5/Tails/Persistence/Configuration/Line.pm
index f3fd304..e6bc85a 100644
--- a/usr/share/perl5/Tails/Persistence/Configuration/Line.pm
+++ b/usr/share/perl5/Tails/Persistence/Configuration/Line.pm
@@ -5,11 +5,11 @@ Tails::Persistence::Configuration::Line - read, parse and write live-persistence
 =cut
 
 package Tails::Persistence::Configuration::Line;
-
-use Moose;
+use strictures 2;
+use Moo;
 with 'Tails::Persistence::Role::ConfigurationLine';
 
+use namespace::clean;
 
-
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration/Presets.pm b/usr/share/perl5/Tails/Persistence/Configuration/Presets.pm
index 1a01326..5f1966f 100644
--- a/usr/share/perl5/Tails/Persistence/Configuration/Presets.pm
+++ b/usr/share/perl5/Tails/Persistence/Configuration/Presets.pm
@@ -5,18 +5,17 @@ Tails::Persistence::Configuration::Presets - available configuration snippets
 =cut
 
 package Tails::Persistence::Configuration::Presets;
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
-
+use strictures 2;
+use Moo;
+use MooX::HandlesVia;
+use MooX::late;
 
 with 'Tails::Role::HasEncoding';
 
 use autodie qw(:all);
 use warnings FATAL => 'all';
 use Carp;
+use List::MoreUtils qw{all};
 use Tails::Persistence::Configuration::Atom;
 
 use Locale::gettext;
@@ -24,161 +23,232 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-persistence-setup");
 
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has '_presets' =>
-    lazy_build ro 'ArrayRef[Tails::Persistence::Configuration::Atom]',
-    traits  => [ 'Array' ],
-    handles => {
-        count => 'count',
-        all   => 'elements',
-    };
+has '_presets' => (
+    lazy_build  => 1,
+    is          => 'rw',
+    isa         => 'ArrayRef',
+    handles_via => 'Array',
+    handles     => {
+        count   => 'count',
+        all     => 'elements',
+    },
+);
 
 
 =head1 CONSTRUCTORS
 
 =cut
 
-method _build__presets {
+sub _build__presets {
+    my $self = shift;
     my @presets = (
         {
+            id          => 'PersonalData',
             name        => $self->encoding->decode(gettext(q{Personal Data})),
             description => $self->encoding->decode(gettext(
                 q{Keep files stored in the `Persistent' directory}
             )),
-            destination => '/home/amnesia/Persistent',
-            enabled     => 1,
-            options     => [ 'source=Persistent' ],
             icon_name   => 'stock_folder',
+            enabled     => 1,
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia/Persistent',
+                    options     => [ 'source=Persistent' ],
+                },
+            ]
         },
         {
-            name        => $self->encoding->decode(gettext(q{GnuPG})),
-            description => $self->encoding->decode(gettext(
-                q{GnuPG keyrings and configuration}
-            )),
-            destination => '/home/amnesia/.gnupg',
-            options     => [ 'source=gnupg' ],
-            enabled     => 0,
-            icon_name   => 'seahorse-key',
-        },
-        {
-            name        => $self->encoding->decode(gettext(q{SSH Client})),
-            description => $self->encoding->decode(gettext(
-                q{SSH keys, configuration and known hosts}
-            )),
-            destination => '/home/amnesia/.ssh',
-            options     => [ 'source=openssh-client'],
-            enabled     => 0,
-            icon_name   => 'seahorse-key-ssh',
-        },
-        {
-            name        => $self->encoding->decode(gettext(q{Pidgin})),
+            id          => 'BrowserBookmarks',
+            name        => $self->encoding->decode(gettext(q{Browser bookmarks})),
             description => $self->encoding->decode(gettext(
-                q{Pidgin profiles and OTR keyring}
+                q{Bookmarks saved in the Tor Browser}
             )),
-            destination => '/home/amnesia/.purple',
-            options     => [ 'source=pidgin' ],
+            icon_name   => 'user-bookmarks',
             enabled     => 0,
-            icon_name   => 'pidgin',
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia/.mozilla/firefox/bookmarks',
+                    options     => [ 'source=bookmarks' ],
+                },
+            ],
         },
         {
-            name        => $self->encoding->decode(gettext(q{Thunderbird})),
+            id          => 'NetworkConnections',
+            name        => $self->encoding->decode(gettext(q{Network Connections})),
             description => $self->encoding->decode(gettext(
-                q{Thunderbird profiles and locally stored email}
+                q{Configuration of network devices and connections}
             )),
-            destination => '/home/amnesia/.thunderbird',
-            options     => [ 'source=thunderbird' ],
+            icon_name   => 'network-wired',
             enabled     => 0,
-            icon_name   => 'thunderbird',
+            atoms_args  => [
+                {
+                    destination => '/etc/NetworkManager/system-connections',
+                    options     => [ 'source=nm-system-connections' ],
+                },
+            ],
         },
         {
-            name        => $self->encoding->decode(gettext(q{GNOME Keyring})),
-            description => $self->encoding->decode(gettext(
-                q{Secrets stored by GNOME Keyring}
+            id               => 'AdditionalSoftware',
+            name             => $self->encoding->decode(gettext(q{Additional Software})),
+            description      => $self->encoding->decode(gettext(
+                q{Software installed every time you start Tails}
             )),
-            destination => '/home/amnesia/.gnome2/keyrings',
-            options     => [ 'source=gnome-keyrings' ],
-            enabled     => 0,
-            icon_name   => 'seahorse-key-personal',
+            icon_name        => 'package-x-generic',
+            enabled          => 0,
+            configuration_cb => sub {
+                # XXX
+                warn("Entering AdditionalSoftware's config_cb");
+            },
+            atoms_args       => [
+                {
+                    destination => '/var/cache/apt/archives',
+                    options     => [ 'source=apt/cache' ],
+                },
+                {
+                    destination => '/var/lib/apt/lists',
+                    options     => [ 'source=apt/lists' ],
+                },
+            ],
         },
         {
-            name        => $self->encoding->decode(gettext(q{Network Connections})),
+            id          => 'Printers',
+            name        => $self->encoding->decode(gettext(q{Printers})),
             description => $self->encoding->decode(gettext(
-                q{Configuration of network devices and connections}
+                q{Printers configuration}
             )),
-            destination => '/etc/NetworkManager/system-connections',
-            options     => [ 'source=nm-system-connections' ],
+            icon_name   => 'printer',
             enabled     => 0,
-            icon_name   => 'network-wired',
+            atoms_args  => [
+                {
+                    destination => '/etc/cups',
+                    options     => [ 'source=cups-configuration' ],
+                },
+            ],
         },
         {
-            name        => $self->encoding->decode(gettext(q{Browser bookmarks})),
+            id          => 'Thunderbird',
+            name        => $self->encoding->decode(gettext(q{Thunderbird})),
             description => $self->encoding->decode(gettext(
-                q{Bookmarks saved in the Tor Browser}
+                q{Thunderbird profiles and locally stored email}
             )),
-            destination => '/home/amnesia/.mozilla/firefox/bookmarks',
-            options     => [ 'source=bookmarks' ],
+            icon_name   => 'thunderbird',
             enabled     => 0,
-            icon_name   => 'user-bookmarks',
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia/.thunderbird',
+                    options     => [ 'source=thunderbird' ],
+                },
+            ],
         },
         {
-            name        => $self->encoding->decode(gettext(q{Printers})),
+            id          => 'GnuPG',
+            name        => $self->encoding->decode(gettext(q{GnuPG})),
             description => $self->encoding->decode(gettext(
-                q{Printers configuration}
+                q{GnuPG keyrings and configuration}
             )),
-            destination => '/etc/cups',
-            options     => [ 'source=cups-configuration' ],
+            icon_name   => 'seahorse-key',
             enabled     => 0,
-            icon_name   => 'printer',
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia/.gnupg',
+                    options     => [ 'source=gnupg' ],
+                },
+            ],
         },
         {
+            id          => 'BitcoinClient',
             name        => $self->encoding->decode(gettext(q{Bitcoin client})),
             description => $self->encoding->decode(gettext(
                 q{Electrum's bitcoin wallet and configuration}
             )),
-            destination => '/home/amnesia/.electrum',
-            options     => [ 'source=electrum' ],
-            enabled     => 0,
             icon_name   => 'electrum',
+            enabled     => 0,
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia/.electrum',
+                    options     => [ 'source=electrum' ],
+                },
+            ],
         },
         {
-            name        => $self->encoding->decode(gettext(q{APT Packages})),
+            id          => 'Pidgin',
+            name        => $self->encoding->decode(gettext(q{Pidgin})),
             description => $self->encoding->decode(gettext(
-                q{Packages downloaded by APT}
+                q{Pidgin profiles and OTR keyring}
             )),
-            destination => '/var/cache/apt/archives',
-            options     => [ 'source=apt/cache' ],
+            icon_name   => 'pidgin',
             enabled     => 0,
-            icon_name   => 'package-x-generic',
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia/.purple',
+                    options     => [ 'source=pidgin' ],
+                },
+            ],
         },
         {
-            name        => $self->encoding->decode(gettext(q{APT Lists})),
+            id          => 'SSHClient',
+            name        => $self->encoding->decode(gettext(q{SSH Client})),
             description => $self->encoding->decode(gettext(
-                q{Lists downloaded by APT}
+                q{SSH keys, configuration and known hosts}
             )),
-            destination => '/var/lib/apt/lists',
-            options     => [ 'source=apt/lists' ],
+            icon_name   => 'seahorse-key-ssh',
             enabled     => 0,
-            icon_name   => 'package-x-generic',
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia/.ssh',
+                    options     => [ 'source=openssh-client'],
+                },
+            ],
         },
         {
+            id          => 'Dotfiles',
             name        => $self->encoding->decode(gettext(q{Dotfiles})),
             description => $self->encoding->decode(gettext(
                 q{Symlink into $HOME every file or directory found in the `dotfiles' directory}
             )),
-            destination => '/home/amnesia',
-            options     => [ 'source=dotfiles', 'link' ],
-            enabled     => 0,
             icon_name   => 'preferences-desktop',
+            enabled     => 0,
+            atoms_args  => [
+                {
+                    destination => '/home/amnesia',
+                    options     => [ 'source=dotfiles', 'link' ],
+                },
+            ],
         },
     );
 
-    return [
-        map { Tails::Persistence::Configuration::Atom->new(%{$_}) } @presets
-    ];
+    foreach my $preset (@presets) {
+        my @atoms;
+        foreach my $atom_init_args (@{$preset->{atoms_args}}) {
+            push @atoms, Tails::Persistence::Configuration::Atom->new(
+                id          => $preset->{id},
+                name        => $preset->{name},
+                description => $preset->{description},
+                enabled     => $preset->{enabled},
+                %{$atom_init_args}
+            );
+        }
+        $preset->{atoms} = \@atoms;
+        delete $preset->{atom_args};
+    }
+
+    return \@presets;
+}
+
+sub atoms {
+    my $self = shift;
+    my @atoms;
+    foreach my $preset ($self->all) {
+        push @atoms, @{$preset->{atoms}};
+    }
+    return @atoms;
 }
 
 
@@ -190,10 +260,22 @@ sub set_state_from_lines {
     my $self = shift;
     my @lines = @_;
 
-    foreach my $atom ($self->all) {
+    foreach my $atom ($self->atoms) {
         $atom->enabled(1) if grep { $atom->equals_line($_) } @lines;
     }
+    foreach my $preset ($self->all) {
+        $self->{enabled} = all { $_->enabled } @{$preset->{atoms}};
+    }
+}
+
+sub set_state_from_overrides {
+    my $self = shift;
+    my $overrides = shift;
+
+    foreach my $atom ($self->atoms) {
+        $atom->enabled(1) if grep { $atom->id eq $_ } @$overrides;
+    }
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Configuration/Setting.pm b/usr/share/perl5/Tails/Persistence/Configuration/Setting.pm
new file mode 100644
index 0000000..032ffff
--- /dev/null
+++ b/usr/share/perl5/Tails/Persistence/Configuration/Setting.pm
@@ -0,0 +1,240 @@
+=head1 NAME
+
+Tails::Persistence::Configuration::Setting - a persistence feature displayed in the GUI
+
+=cut
+
+package Tails::Persistence::Configuration::Setting;
+
+use strictures 2;
+use autodie qw(:all);
+use Glib qw{TRUE FALSE};
+use List::MoreUtils qw{all};
+use Pango;
+use UUID::Tiny ':std';
+
+use Locale::gettext;
+use POSIX;
+setlocale(LC_MESSAGES, "");
+textdomain("tails-persistence-setup");
+
+use Moo;
+use MooX::late;
+with 'Tails::Role::HasEncoding';
+use namespace::clean;
+
+
+=head1 ATTRIBUTES
+
+=cut
+
+has 'atoms' => (
+    required    => 1,
+    is          => 'ro',
+    isa         => 'ArrayRef[Tails::Persistence::Configuration::Atom]',
+);
+
+foreach (qw{id name description icon_name}) {
+    has $_ => (
+        lazy_build => 1,
+        is         => 'rw',
+        isa        => 'Str',
+    );
+}
+
+has 'icon' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Gtk3::Image',
+);
+
+has 'main_widget' => (
+    lazy_build     => 1,
+    is             => 'ro',
+    isa            => 'Gtk3::HBox',
+);
+
+has 'switch' => (
+    lazy_build     => 1,
+    is             => 'ro',
+    isa            => 'Gtk3::Switch',
+    handles        => {
+        is_active  => 'get_active',
+        set_active => 'set_active',
+    },
+);
+
+has 'icon_theme' => (
+    is      => 'ro',
+    isa     => 'Gtk3::IconTheme',
+    builder => '_build_icon_theme',
+);
+
+has 'title_label' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Gtk3::Label',
+);
+
+has 'description_label' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Gtk3::Label',
+);
+
+has 'configuration_button' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Gtk3::Button',
+);
+
+has 'configuration_cb' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'CodeRef',
+    predicate  => 1,
+);
+
+
+=head1 CONSTRUCTORS
+
+=cut
+
+sub _build_name {
+    my $self = shift;
+    $self->encoding->decode(gettext('Custom'));
+}
+
+sub _build_id {
+    my $self = shift;
+    create_uuid();
+}
+
+sub _build_description {
+    my $self = shift;
+    join(', ', map { $self->encoding->decode($_->destination) } @{$self->atoms});
+}
+
+sub _build_icon_name {
+    my $self = shift;
+    'dialog-question'
+}
+
+sub _build_icon {
+    my $self = shift;
+    Gtk3::Image->new_from_pixbuf($self->icon_theme->load_icon(
+        $self->icon_name, 48, 'use-builtin'
+    ));
+}
+
+sub _build_switch {
+    my $self = shift;
+    my $switch = Gtk3::Switch->new();
+    $switch->set_active($self->enabled);
+    $switch->set_valign('GTK_ALIGN_CENTER');
+    $switch->set_vexpand(FALSE);
+    for (qw{start end top bottom}) {
+        my $method = "set_margin_${_}";
+        $switch->$method(12);
+    }
+    $switch->signal_connect('notify::active' => sub { $self->toggled_cb });
+    return $switch;
+}
+
+sub _build_configuration_button {
+    my $self = shift;
+
+    my $button = Gtk3::Button->new_from_icon_name(
+        'emblem-system-symbolic', 1,
+    );
+    $button->set_valign('GTK_ALIGN_CENTER');
+    $button->signal_connect('clicked' => sub { $self->configuration_cb->() } );
+
+    return $button;
+}
+
+sub _build_main_widget {
+    my $self = shift;
+    my $line = shift;
+
+    my $main_box = Gtk3::HBox->new();
+    $main_box->set_border_width(5);
+
+    my $text_box = Gtk3::VBox->new();
+    $text_box->set_border_width(5);
+    $text_box->pack_start($self->title_label, FALSE, FALSE, 0);
+    $text_box->pack_start($self->description_label, FALSE, FALSE, 0);
+    $text_box->set_margin_start(12);
+    $text_box->set_margin_end(12);
+    $text_box->set_margin_top(6);
+    $text_box->set_margin_bottom(6);
+
+    $main_box->pack_start($self->icon, FALSE, FALSE, 0);
+    $main_box->pack_start($text_box, TRUE, TRUE, 0);
+    if ($self->has_configuration_cb) {
+        $main_box->pack_start($self->configuration_button, FALSE, FALSE, 0);
+    }
+    $main_box->pack_start($self->switch, FALSE, FALSE, 0);
+
+    return $main_box;
+}
+
+sub _build_icon_theme {
+    my $self = shift;
+    my $theme = Gtk3::IconTheme::get_default();
+
+    $theme->append_search_path('/usr/share/pixmaps/cryptui/48x48');
+    $theme->append_search_path('/usr/share/pixmaps/seahorse/48x48');
+    $theme->append_search_path('/usr/share/icons/gnome-colors-common/32x32/apps/');
+    $theme->append_search_path('/usr/share/app-install/icons/');
+
+    return $theme;
+ }
+
+sub _build_title_label {
+    my $self = shift;
+    my $title = Gtk3::Label->new($self->name);
+    $title->set_alignment(0.0, 0.5);
+    my $title_attrlist = Pango::AttrList->new;
+    $title_attrlist->insert($_)
+        foreach ( Pango::AttrScale->new(1.1),Pango::AttrWeight->new('bold') );
+    $title->set_attributes($title_attrlist);
+
+    return $title;
+}
+
+sub _build_description_label {
+    my $self = shift;
+    my $description = Gtk3::Label->new($self->description);
+    $description->set_alignment(0.0, 0.5);
+    my $description_attrlist = Pango::AttrList->new;
+    $description_attrlist->insert(
+        Pango::AttrForeground->new(30000, 30000, 30000)
+      );
+    $description->set_attributes($description_attrlist);
+    $description->set_line_wrap(TRUE);
+    $description->set_line_wrap_mode('word');
+    $description->set_single_line_mode(FALSE);
+
+    return $description;
+}
+
+
+=head1 METHODS
+
+=cut
+
+sub enabled {
+    my $self = shift;
+    all { $_->enabled } @{$self->atoms};
+}
+
+sub toggled_cb {
+    my $self = shift;
+    foreach my $atom (@{$self->atoms}) {
+        $atom->enabled($self->is_active)
+    }
+}
+
+no Moo;
+1;
diff --git a/usr/share/perl5/Tails/Persistence/Constants.pm b/usr/share/perl5/Tails/Persistence/Constants.pm
index 8bdb541..90dad98 100644
--- a/usr/share/perl5/Tails/Persistence/Constants.pm
+++ b/usr/share/perl5/Tails/Persistence/Constants.pm
@@ -1,52 +1,82 @@
 package Tails::Persistence::Constants;
-use Moose;
-use MooseX::Has::Sugar::Saccharin;
-use MooseX::Types::Moose qw{:all};
-use MooseX::Types::Path::Class;
+use strictures 2;
+use Moo;
+use MooX::late;
+use Types::Path::Tiny qw{AbsPath};
 
 use autodie qw(:all);
-use English qw{-no_match_vars};
-use Method::Signatures::Simple;
+
+use namespace::clean;
 
 
 =head1 Attributes
 
 =cut
 for (qw{partition_label partition_guid filesystem_type filesystem_label}) {
-    has "persistence_$_" => lazy_build ro Str;
+    has "persistence_$_" => (
+        lazy_build => 1,
+        is         => 'ro',
+        isa        => 'Str',
+    );
 }
 
-has "persistence_minimum_size"       => lazy_build ro Int;
+has "persistence_minimum_size"       => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Int',
+);
 
-has 'persistence_filesystem_options' => lazy_build ro 'HashRef[Str]';
+has 'persistence_filesystem_options' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'HashRef[Str]',
+);
 
-has 'persistence_state_file'         =>
-    isa        => 'Path::Class::File',
+has 'persistence_state_file'         => (
+    isa        => AbsPath,
     is         => 'ro',
     lazy_build => 1,
-    coerce     => 1,
-    documentation => q{File where tails-greeter writes persistence state.};
+    coerce     => AbsPath->coercion,
+    documentation => q{File where tails-greeter writes persistence state.},
+);
 
 
 =head1 Constructors
 
 =cut
-method _build_persistence_partition_label  { 'TailsData'  }
-method _build_persistence_minimum_size     { 64 * 2 ** 20 }
-method _build_persistence_filesystem_type  { 'ext4'       }
-method _build_persistence_filesystem_label { 'TailsData'  }
+sub _build_persistence_partition_label {
+    my $self = shift;
+    'TailsData'
+}
+sub _build_persistence_minimum_size {
+    my $self = shift;
+    64 * 2 ** 20
+}
+sub _build_persistence_filesystem_type {
+    my $self = shift;
+    'ext4'
+}
+sub _build_persistence_filesystem_label {
+    my $self = shift;
+    'TailsData'
+}
 
-method _build_persistence_filesystem_options {
+sub _build_persistence_filesystem_options {
+    my $self = shift;
     {
         label => $self->persistence_filesystem_label,
     };
 }
 
-method _build_persistence_partition_guid  {
+sub _build_persistence_partition_guid  {
+    my $self = shift;
     '8DA63339-0007-60C0-C436-083AC8230908' # Linux reserved
 }
 
-method _build_persistence_state_file { '/var/lib/live/config/tails.persistence' }
+sub _build_persistence_state_file {
+    my $self = shift;
+    '/var/lib/live/config/tails.persistence'
+}
 
-no Moose;
+no Moo;
 1; # End of Tails::Persistence::Constants
diff --git a/usr/share/perl5/Tails/Persistence/Role/ConfigurationLine.pm b/usr/share/perl5/Tails/Persistence/Role/ConfigurationLine.pm
index 4222c8a..6148d9c 100644
--- a/usr/share/perl5/Tails/Persistence/Role/ConfigurationLine.pm
+++ b/usr/share/perl5/Tails/Persistence/Role/ConfigurationLine.pm
@@ -5,40 +5,49 @@ Tails::Persistence::Role::ConfigurationLine - live-persistence.conf data structu
 =cut
 
 package Tails::Persistence::Role::ConfigurationLine;
-use Moose::Role;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-
-
+use strictures 2;
 use autodie qw(:all);
-use warnings FATAL => 'all';
 use Carp;
 
+use Moo::Role; # Moo::Role exports all methods declared after it's "use"'d
+use MooX::late;
+use MooX::HandlesVia;
+
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'destination' => lazy_build ro Str;
-has 'options' =>
-    lazy_build ro 'ArrayRef[Str]',
-    traits    => [ 'Array' ],
-    handles   => {
+has 'destination' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Str',
+);
+
+has 'options' => (
+    lazy_build        => 1,
+    is                => 'ro',
+    isa               => 'ArrayRef[Str]',
+    handles_via       => 'Array',
+    handles           => {
         count_options => 'count',
         all_options   => 'elements',
         join_options  => 'join',
         grep_options  => 'grep',
-    };
+    }
+);
 
 
 =head1 CONSTRUCTORS
 
 =cut
 
-method _build_options     { return [] }
+sub _build_options {
+    my $self = shift;
+    return []
+}
 
 
 =head2 new_from_string
@@ -84,7 +93,8 @@ as a string in the live-persistence.conf format,
 with no trailing newline.
 
 =cut
-method stringify {
+sub stringify {
+    my $self = shift;
     my $out = $self->destination;
     if ($self->count_options) {
         $out .= "\t" . $self->join_options(',');
@@ -92,5 +102,5 @@ method stringify {
     return $out;
 }
 
-no Moose;
+no Moo::Role;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Role/HasStatusArea.pm b/usr/share/perl5/Tails/Persistence/Role/HasStatusArea.pm
index ff42a6f..24d92df 100644
--- a/usr/share/perl5/Tails/Persistence/Role/HasStatusArea.pm
+++ b/usr/share/perl5/Tails/Persistence/Role/HasStatusArea.pm
@@ -5,12 +5,13 @@ Tails::Persistence::Role::HasStatusArea - status area interface
 =cut
 
 package Tails::Persistence::Role::HasStatusArea;
-use Moose::Role;
-
-
+use strictures 2;
+use Moo::Role;
 
 requires 'status_area';
 requires 'working';
 
-no Moose 'Role';
+use namespace::clean;
+
+no Moo::Role;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Role/SetupStep.pm b/usr/share/perl5/Tails/Persistence/Role/SetupStep.pm
index adca738..de27a82 100644
--- a/usr/share/perl5/Tails/Persistence/Role/SetupStep.pm
+++ b/usr/share/perl5/Tails/Persistence/Role/SetupStep.pm
@@ -5,17 +5,9 @@ Tails::Persistence::Role::SetupStep - role for persistence setup steps
 =cut
 
 package Tails::Persistence::Role::SetupStep;
-use Moose::Role;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
-
-
-with 'Tails::Role::HasEncoding';
-with 'Tails::Persistence::Role::HasStatusArea';
 
 use 5.10.0;
-use namespace::autoclean;
+use strictures 2;
 use autodie qw(:all);
 
 use Glib qw{TRUE FALSE};
@@ -26,7 +18,14 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-persistence-setup");
 
-requires '_build_main_box';
+use Moo::Role;
+use MooX::late;
+use namespace::clean;
+
+with 'Tails::Role::HasEncoding';
+with 'Tails::Persistence::Role::HasStatusArea';
+
+requires '_build_main_widget';
 requires 'go_button_pressed';
 
 
@@ -34,21 +33,45 @@ requires 'go_button_pressed';
 
 =cut
 
-has 'name' => required ro Str;
+has 'name' => (
+    required => 1,
+    is       => 'ro',
+    isa      => 'Str',
+);
 
-has 'main_box' => lazy_build rw 'Gtk3::VBox';
+has 'main_widget' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::VBox',
+);
 
 foreach (qw{title subtitle description}) {
-    has $_ => lazy_build rw 'Gtk3::Label';
+    has $_ => (
+        lazy_build => 1,
+        is         => 'rw',
+        isa        => 'Gtk3::Label',
+    );
 }
 
-has 'go_button'   => lazy_build rw 'Gtk3::Button';
+has 'go_button'   => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::Button',
+);
 foreach (qw{go_callback success_callback}) {
-    has $_ => required ro CodeRef;
+    has $_ => (
+        required => 1,
+        is       => 'ro',
+        isa      => 'CodeRef',
+    );
 }
 
 foreach (qw{drive_vendor drive_model}) {
-    has $_ => required ro Str;
+    has $_ => (
+        required => 1,
+        is       => 'ro',
+        isa      => 'Str',
+    );
 }
 
 
@@ -111,5 +134,5 @@ sub _build_go_button {
     return $button;
 }
 
-no Moose::Role;
+no Moo::Role;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Role/StatusArea.pm b/usr/share/perl5/Tails/Persistence/Role/StatusArea.pm
index e0ad103..bd8fdb5 100644
--- a/usr/share/perl5/Tails/Persistence/Role/StatusArea.pm
+++ b/usr/share/perl5/Tails/Persistence/Role/StatusArea.pm
@@ -5,26 +5,37 @@ Tails::Persistence::Role::StatusArea - role to manage a status area
 =cut
 
 package Tails::Persistence::Role::StatusArea;
-use Moose::Role;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
-
-
+use strictures 2;
 use 5.10.0;
-use namespace::autoclean;
 use autodie qw(:all);
 use Glib qw{TRUE FALSE};
 use Gtk3;
 
+use Moo::Role;
+use MooX::late;
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'status_area' => lazy_build rw 'Gtk3::HBox';
-has 'spinner'     => lazy_build rw 'Gtk3::Spinner';
-has 'working'     => lazy_build rw Bool;
+has 'status_area' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::HBox',
+);
+has 'spinner'     => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::Spinner',
+);
+has 'working'     => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Bool',
+
+);
 
 
 =head1 CONSTRUCTORS
@@ -71,5 +82,5 @@ after 'working' => sub {
     }
 };
 
-no Moose 'Role';
+no Moo::Role;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Setup.pm b/usr/share/perl5/Tails/Persistence/Setup.pm
index d6c0ba2..7519904 100644
--- a/usr/share/perl5/Tails/Persistence/Setup.pm
+++ b/usr/share/perl5/Tails/Persistence/Setup.pm
@@ -5,41 +5,27 @@ Tails::Persistence::Setup - main application class
 =cut
 
 package Tails::Persistence::Setup;
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
 
-
-
-with 'Tails::Role::DisplayError::Gtk3';
-with 'Tails::Role::HasEncoding';
-with 'Tails::Role::HasDBus::System';
-with 'MooseX::Getopt::Dashes';
-
-use 5.10.0;
-use namespace::autoclean;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp::Assert::More;
-use Data::Dumper;
 use English qw{-no_match_vars};
 use Glib qw{TRUE FALSE};
 use Gtk3 qw{-init};
 use Net::DBus qw(:typing);
 use Net::DBus::Annotation qw(:call);
-use List::Util qw{first max};
+use List::Util qw{first min max};
 use Number::Format qw(:subs);
-use Path::Class;
+use Path::Tiny;
 use Try::Tiny;
+use Types::Path::Tiny qw{Dir};
 
 use Tails::RunningSystem;
 use Tails::UDisks;
-
 use Tails::Persistence::Configuration;
 use Tails::Persistence::Constants;
-
 use Tails::Persistence::Step::Bootstrap;
 use Tails::Persistence::Step::Configure;
 use Tails::Persistence::Step::Delete;
@@ -50,120 +36,189 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-persistence-setup");
 
+no Moo::sification;
+use Moo;
+use MooX::late;
+use MooX::HandlesVia;
+
+with 'Tails::Role::DisplayError::Gtk3';
+with 'Tails::Role::HasDBus::System';
+with 'Tails::Role::HasEncoding';
+
+use namespace::clean;
+
+use MooX::Options;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'verbose' =>
-    ro Bool,
+option 'verbose' => (
+    is            => 'ro',
+    isa           => 'Bool',
     documentation => q{Get more output.},
     default       => sub {
         exists $ENV{DEBUG} && defined $ENV{DEBUG} && $ENV{DEBUG}
-    };
+    },
+);
 
-has 'force' =>
-    lazy_build ro Bool,
-    documentation => q{Make some sanity checks non-fatal.};
+option 'force' => (
+    lazy_build    => 1,
+    is            => 'ro',
+    isa           => 'Bool',
+    documentation => q{Make some sanity checks non-fatal.},
+);
 
-has 'udisks' =>
-    lazy_build ro 'Tails::UDisks',
-    metaclass => 'NoGetopt',
-    handles   => [
+has 'udisks' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Tails::UDisks',
+    handles    => [
         qw{bytes_array_to_string device_has_partition_with_label
            drive_is_optical drive_is_connected_via_a_supported_interface
            device_partition_with_label get_block_device_property
            get_filesystem_property get_partition_property luks_holder
            mountpoints partitions udisks_service}
-    ];
+    ],
+);
 
-has 'running_system' =>
-    lazy_build ro 'Tails::RunningSystem',
-    metaclass => 'NoGetopt',
-    handles   => [
+has 'running_system' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Tails::RunningSystem',
+    handles    => [
         qw{boot_drive boot_block_device boot_device_file boot_drive_model boot_drive_vendor
            boot_drive_size
            started_from_device_installed_with_tails_installer}
-    ];
+    ],
+);
 
-has 'persistence_constants' =>
-    lazy_build ro 'Tails::Persistence::Constants',
-    metaclass => 'NoGetopt',
-    handles   => [
+has 'persistence_constants' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Tails::Persistence::Constants',
+    handles    => [
         map {
             "persistence_$_"
         } qw{partition_label partition_guid filesystem_type filesystem_label
              minimum_size filesystem_options state_file}
-    ];
+    ],
+);
 
-has 'main_window' =>
-    lazy_build ro 'Gtk3::Window',
-    metaclass  => 'NoGetopt';
+has 'main_window' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Gtk3::Window',
+);
 
-has "$_" => lazy_build ro Str
-    for (qw{override_liveos_mountpoint override_boot_drive
-            override_system_partition});
+option "$_" => (
+    is         => 'ro',
+    format     => 's',
+    isa        => 'Str',
+    predicate  => 1,
+) for (qw{override_liveos_mountpoint override_boot_drive
+          override_system_partition});
 
-has 'persistence_partition_device_file'=> lazy_build ro Str, metaclass => 'NoGetopt';
-has 'persistence_partition_size'     => lazy_build ro Int,  metaclass => 'NoGetopt';
-has 'persistence_is_enabled'         => lazy_build ro Bool, metaclass => 'NoGetopt';
-has 'persistence_is_read_write'      => lazy_build ro Bool, metaclass => 'NoGetopt';
+has 'persistence_partition_device_file' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Str',
+);
+has 'persistence_partition_size' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Int',
+);
+has 'persistence_is_enabled' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Bool',
+);
 
 has 'persistence_partition_mountpoint' => (
-    isa        => 'Path::Class::Dir',
+    isa        => Dir,
     is         => 'rw',
     lazy_build => 1,
-    coerce     => 1,
-    metaclass  => 'NoGetopt',
+    coerce     => Dir->coercion,
 );
 
 foreach (qw{beginning_of_free_space size_of_free_space}) {
-    has $_ => lazy_build ro Int, metaclass  => 'NoGetopt';
+    has $_ => (
+        lazy_build => 1,
+        is         => 'ro',
+        isa        => 'Int',
+    );
 }
 
-has 'current_step' =>
-    rw Object,
-    predicate 'has_current_step',
-    metaclass  => 'NoGetopt';
+has 'current_step' => (
+    is        => 'rw',
+    isa       => 'Object',
+    predicate => 'has_current_step',
+);
 
-has 'steps' =>
-    lazy_build required ro 'ArrayRef[Str]',
-    traits  => ['Array'],
-    handles => {
-        all_steps       => 'elements',
+option 'steps' => (
+    lazy_build    => 1,
+    required      => 1,
+    repeatable    => 1,
+    format        => 's@',
+    is            => 'rw',
+    isa           => 'ArrayRef[Str]',
+    handles_via   => ['Array'],
+    handles       => {
         number_of_steps => 'count',
-        append_to_steps => 'push',
         shift_steps     => 'shift',
         next_step       => 'first',
-        grep_steps      => 'grep',
     },
-    documentation => q{Specify once per wizard step to run. Supported steps are: bootstrap, configure, delete.};
+    documentation => q{Specify once per wizard step to run. Supported steps are: bootstrap, configure, delete.},
+);
 
-has 'orig_steps' =>
-    rw 'ArrayRef[Str]',
-    traits  => ['Array'],
-    handles => {
-        grep_orig_steps => 'grep',
-    };
+has 'configuration' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Tails::Persistence::Configuration',
+    handles    => { save_configuration => 'save' },
+);
 
-has 'passphrase' => rw Str, documentation => q{Unsupported. Developers only.};
+option 'force_enable_presets' => (
+    is            => 'ro',
+    repeatable    => 1,
+    format        => 's@',
+    isa           => 'ArrayRef[Str]',
+    handles_via   => ['Array'],
+    documentation => q{Specify once per additional preset to forcibly enable.},
+    default       => sub { [] },
+);
 
-has 'configuration' =>
-    lazy_build rw 'Tails::Persistence::Configuration',
-    handles    => { save_configuration => 'save' },
-    metaclass  => 'NoGetopt';
+option 'display_finished_message' => (
+    is            => 'ro',
+    isa           => 'Bool',
+    documentation => q{Display an explanatory message once done.},
+    default       => sub { 1 },
+    negativable   => 1,
+);
 
-has '+codeset'  => ( metaclass => 'NoGetopt' );
-has '+encoding' => ( metaclass => 'NoGetopt' );
+option 'gui' => (
+    is            => 'ro',
+    isa           => 'Bool',
+    documentation => q{Display the GUI. Only a few operations are available under --no-gui.},
+    default       => sub { 1 },
+    negativable   => 1,
+);
 
 
 =head1 CONSTRUCTORS AND BUILDERS
 
 =cut
 
-method BUILD {
-    my @orig_steps = $self->all_steps;
-    $self->orig_steps(\@orig_steps);
+sub BUILD {
+    my $self = shift;
+    if (! $self->gui) {
+        assert_is($self->number_of_steps, 1,
+                  "Exactly one step is enabled under --no-gui");
+        assert_is($self->steps->[0], 'configure',
+                  "The requested step is 'configure' under --no-gui");
+    }
 }
 
 sub _build_force {
@@ -201,18 +256,6 @@ sub _build_persistence_is_enabled {
     defined($value) && $value eq 'true';
 }
 
-sub _build_persistence_is_read_write {
-    my $self = shift;
-
-    -e $self->persistence_state_file || return 0;
-    -r $self->persistence_state_file || return 0;
-
-    my $value = $self->get_variable_from_persistence_state_file(
-        'TAILS_PERSISTENCE_READONLY'
-    );
-    ! (defined($value) && $value eq 'true');
-}
-
 sub _build_steps {
     my $self = shift;
 
@@ -231,7 +274,7 @@ sub _build_main_window {
 
     $win->set_border_width(10);
 
-    $win->add($self->current_step->main_box) if $self->has_current_step;
+    $win->add($self->current_step->main_widget) if $self->has_current_step;
     $win->signal_connect('destroy' => sub { Gtk3->main_quit; });
     $win->signal_connect('key-press-event' => sub {
         my $twin = shift;
@@ -248,7 +291,7 @@ sub _build_persistence_partition_mountpoint {
 
     first {
            $_ eq '/live/persistence/TailsData_unlocked'
-        or $_ eq '/media/tails-persistence-setup/TailsData'
+        or $_ eq '/media/'.getpwuid($UID).'/TailsData'
     } $self->mountpoints($self->persistence_partition);
 }
 
@@ -291,10 +334,18 @@ sub _build_persistence_partition_size {
 sub _build_configuration {
     my $self = shift;
 
-    my $config_file_path = file($self->persistence_partition_mountpoint, 'persistence.conf');
+    my $config_file_path = path($self->persistence_partition_mountpoint, 'persistence.conf');
     if (-e $config_file_path) {
-        my $expected_uid = getpwnam('tails-persistence-setup');
-        my $expected_gid = getgrnam('tails-persistence-setup');
+        # In Tails, tails-persistence-setup runs as the tails-persistence-setup
+        # user and the configuration file must be owned by
+        # tails-persistence-setup:tails-persistence-setup.
+        # When developing outside of Tails, the configuration file is also owned
+        # by the user:group that runs tails-persistence-setup.
+        # So in all cases, we effectively want the configuration file
+        # to be owned by the user:group that runs tails-persistence-setup.
+        my $expected_uid = getuid();
+        my $expected_gid = getgid();
+        $self->debug("Expected ownership: ${expected_uid}:${expected_gid}");
         try {
             check_config_file_permissions(
                 $config_file_path,
@@ -313,11 +364,13 @@ sub _build_configuration {
                 $self->encoding->decode(gettext(
                     $_,
                 )));
+            exit 4;
         };
     }
 
     Tails::Persistence::Configuration->new(
-        config_file_path => $config_file_path
+        config_file_path     => $config_file_path,
+        force_enable_presets => $self->force_enable_presets,
     );
 }
 
@@ -363,7 +416,7 @@ sub check_sanity {
             {
                 method  => 'persistence_is_enabled',
                 message => $self->encoding->decode(gettext(
-                    "Cannot delete the persistent volume while in use. You should restart Tails without persistence.")),
+                    "Cannot delete the persistent volume on %s while in use. You should restart Tails without persistence.")),
                 must_be_false => 1,
             },
         ],
@@ -374,33 +427,28 @@ sub check_sanity {
                     "Device %s has no persistent volume.")),
                 needs_device_arg => 1,
             },
-        ],
-    );
-
-    if (! $self->grep_orig_steps(sub { $_ eq 'bootstrap' })) {
-        push @{$step_checks{configure}}, (
             {
                 method  => 'persistence_partition_is_unlocked',
                 message => $self->encoding->decode(gettext(
-                    "Persistence volume is not unlocked.")),
+                    "Persistence volume on %s is not unlocked.")),
             },
             {
                 method  => 'persistence_filesystem_is_mounted',
                 message => $self->encoding->decode(gettext(
-                    "Persistence volume is not mounted.")),
+                    "Persistence volume on %s is not mounted.")),
             },
             {
                 method  => 'persistence_filesystem_is_readable',
                 message => $self->encoding->decode(gettext(
-                    "Persistence volume is not readable. Permissions or ownership problems?")),
+                    "Persistence volume on %s is not readable. Permissions or ownership problems?")),
             },
             {
                 method  => 'persistence_filesystem_is_writable',
                 message => $self->encoding->decode(gettext(
-                    "Persistence volume is not writable. Maybe it was mounted read-only?")),
+                    "Persistence volume on %s is not writable.")),
             },
-        );
-    }
+        ],
+    );
 
     my @checks = (
         {
@@ -431,7 +479,7 @@ sub check_sanity {
     }
 
     foreach my $check (@checks) {
-        my $check_method = $self->meta->get_method($check->{method});
+        my $check_method = $self->can($check->{method});
         assert_defined($check_method);
         my $res;
         my @args = ($self);
@@ -441,7 +489,7 @@ sub check_sanity {
         elsif (exists($check->{needs_drive_arg}) && $check->{needs_drive_arg}) {
             push @args, $self->boot_drive;
         }
-        $res = $check_method->execute(@args);
+        $res = $check_method->(@args);
         if (exists($check->{must_be_false}) && $check->{must_be_false}) {
             $res = ! $res;
         }
@@ -450,7 +498,7 @@ sub check_sanity {
                 gettext($check->{message}),
                 $self->boot_device_file));
             if ($self->force && exists($check->{can_be_forced}) && $check->{can_be_forced}) {
-                warn "$message",
+                say STDERR "$message",
                      "... but --force is enabled, ignoring results of this sanity check.";
             }
             else {
@@ -475,8 +523,10 @@ sub run {
 
     $self->main_window->set_visible(FALSE);
     $self->goto_next_step;
-    $self->debug("Entering main Gtk3 loop.");
-    Gtk3->main;
+    if ($self->gui) {
+        $self->debug("Entering main Gtk3 loop.");
+        Gtk3->main;
+    }
 }
 
 sub device_has_persistent_volume {
@@ -629,19 +679,31 @@ sub run_current_step {
 
     $self->debug("Running step " . $self->current_step->name);
 
-    $self->current_step->working(0);
-    $self->empty_main_window;
-    $self->main_window->add($self->current_step->main_box);
-    $self->main_window->set_default($self->current_step->go_button);
-    $self->main_window->show_all;
-    $self->current_step->working(0);
-    $self->main_window->set_visible(TRUE);
-
-    if($self->current_step->name eq 'configure') {
-        $self->main_window->resize($width, $self->main_window->get_screen()->get_height());
-    }
-    else {
-        $self->main_window->resize($width, $height);
+    if ($self->gui) {
+        $self->current_step->working(0);
+        $self->empty_main_window;
+        $self->main_window->add($self->current_step->main_widget);
+        $self->main_window->set_default($self->current_step->go_button);
+        $self->main_window->show_all;
+        $self->current_step->working(0);
+        $self->main_window->set_visible(TRUE);
+
+        if($self->current_step->name eq 'configure') {
+            $self->main_window->resize(
+                $width,
+                max(
+                    900,
+                    min(450, $self->main_window->get_screen()->get_height()),
+                )
+            );
+        }
+        else {
+            $self->main_window->resize($width, $height);
+        }
+    } else {
+        $self->debug("run_current_step: starting go_button_pressed...");
+        $self->current_step->go_button_pressed;
+        $self->debug("run_current_step: go_button_pressed exited.");
     }
 }
 
@@ -664,6 +726,13 @@ sub goto_next_step {
     }
     else {
         $self->debug("No more steps.");
+        if (! $self->display_finished_message) {
+            if ($self->gui) {
+                Gtk3->main_quit;
+            } else {
+                return;
+            }
+        }
         $self->current_step->title->set_text($self->encoding->decode(gettext(
             q{Persistence wizard - Finished}
         )));
@@ -692,11 +761,18 @@ sub step_object_from_name {
                 $self->create_persistence_partition({ @_ })
             },
             size_of_free_space          => $self->size_of_free_space,
-            should_mount_persistence_partition =>
-                0 < $self->grep_steps(sub { $_ eq 'configure' }),
             mount_persistence_partition_cb => sub {
                 $self->mount_persistence_partition({ @_ })
             },
+            create_configuration_cb        => sub {
+                $self->save_configuration({ @_ });
+                my $asp_config_file = path(
+                    $self->persistence_partition_mountpoint,
+                    'live-additional-software.conf'
+                );
+                $asp_config_file->touch;
+                chmod 0600, $asp_config_file;
+            },
         );
     }
     elsif ($name eq 'delete') {
@@ -732,21 +808,26 @@ sub step_object_from_name {
 
 }
 
-method get_variable_from_persistence_state_file (Str $variable) {
+sub get_variable_from_persistence_state_file {
+    my $self = shift;
+    my $variable = shift;
     get_variable_from_file($self->persistence_state_file, $variable);
 }
 
-method persistence_filesystem_is_mounted () {
+sub persistence_filesystem_is_mounted {
+    my $self = shift;
     return scalar($self->mountpoints($self->persistence_partition));
 }
 
-method persistence_partition_is_unlocked () {
+sub persistence_partition_is_unlocked {
+    my $self = shift;
     my $luks_holder = $self->luks_holder($self->persistence_partition) || return;
 
     return 1;
 }
 
-method persistence_filesystem_is_readable () {
+sub persistence_filesystem_is_readable {
+    my $self = shift;
     return unless my $mountpoint = $self->persistence_partition_mountpoint;
     my $ret;
     {
@@ -756,7 +837,8 @@ method persistence_filesystem_is_readable () {
     return $ret;
 }
 
-method persistence_filesystem_is_writable () {
+sub persistence_filesystem_is_writable {
+    my $self = shift;
     return unless my $mountpoint = $self->persistence_partition_mountpoint;
     my $ret;
     {
@@ -766,5 +848,5 @@ method persistence_filesystem_is_writable () {
     return $ret;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Step/Bootstrap.pm b/usr/share/perl5/Tails/Persistence/Step/Bootstrap.pm
index 7a456ee..cab8f37 100644
--- a/usr/share/perl5/Tails/Persistence/Step/Bootstrap.pm
+++ b/usr/share/perl5/Tails/Persistence/Step/Bootstrap.pm
@@ -5,11 +5,9 @@ Tails::Persistence::Step::Bootstrap - bootstrap persistent storage
 =cut
 
 package Tails::Persistence::Step::Bootstrap;
-use Moose;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
 
+use 5.10.1;
+use strictures 2;
 
 use Glib qw{TRUE FALSE};
 
@@ -21,26 +19,64 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-persistence-setup");
 
+use Moo;
+use MooX::late;
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
 foreach (qw{intro label verify_label warning_label}) {
-    has $_ => lazy_build rw 'Gtk3::Label';
+    has $_ => (
+        lazy_build => 1,
+        is         => 'rw',
+        isa        => 'Gtk3::Label',
+    );
 }
 
 foreach (qw{passphrase_entry verify_passphrase_entry}) {
-    has $_ => lazy_build rw 'Gtk3::Entry', builder '_build_passphrase_entry';
+    has $_ => (
+        lazy_build => 1,
+        is         => 'rw',
+        isa        => 'Gtk3::Entry',
+        builder    => '_build_passphrase_entry',
+    );
 }
 
-has 'table_alignment' => lazy_build rw 'Gtk3::Alignment';
-has 'table'           => lazy_build rw 'Gtk3::Table';
-has 'warning_area'    => lazy_build rw 'Gtk3::HBox';
-has 'warning_image'   => lazy_build rw 'Gtk3::Image';
-has 'size_of_free_space'      => required ro Int;
-has 'mount_persistence_partition_cb' => required ro CodeRef;
-has 'should_mount_persistence_partition' => required ro Bool;
+has 'table_alignment' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::Alignment',
+);
+has 'table' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::Table',
+);
+has 'warning_area' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::HBox',
+);
+has 'warning_image' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::Image',
+);
+has 'size_of_free_space' => (
+    required => 1,
+    is       => 'ro',
+    isa      => 'Int',
+);
+foreach (qw{mount_persistence_partition_cb create_configuration_cb}) {
+    has $_ => (
+        required => 1,
+        is       => 'ro',
+        isa      => 'CodeRef',
+    );
+}
 
 
 =head1 CONSTRUCTORS
@@ -66,10 +102,9 @@ sub BUILD {
     $self->go_button->set_label($self->encoding->decode(gettext(q{Create})));
 }
 
-sub _build_main_box {
+sub _build_main_widget {
     my $self = shift;
 
-
     my $box = Gtk3::VBox->new();
     $box->set_spacing(6);
     $box->pack_start($self->title, FALSE, FALSE, 0);
@@ -278,34 +313,39 @@ sub operation_finished {
         say STDERR "created ${created_device}.";
         $self->working(0);
 
-        if ($self->should_mount_persistence_partition) {
-            $self->subtitle->set_text($self->encoding->decode(gettext(
-                q{Mounting Tails persistence partition.}
-            )));
-            $self->description->set_text($self->encoding->decode(gettext(
-                q{The Tails persistence partition will be mounted.}
-            )));
-            $self->working(1);
-            systemx(qw{/sbin/udevadm settle});
-            my $mountpoint = $self->mount_persistence_partition_cb->();
-            $self->working(0);
-            say STDERR "mounted persistence partition on $mountpoint";
-
-            $self->subtitle->set_text($self->encoding->decode(gettext(
-                q{Correcting permissions of the persistent volume.}
-            )));
-            $self->description->set_text($self->encoding->decode(gettext(
-                q{The permissions of the persistent volume will be corrected.}
-            )));
-            $self->working(1);
-            systemx(qw{sudo -n /usr/bin/tails-fix-persistent-volume-permissions});
-            $self->working(0);
-            say STDERR "fixed permissions.";
-
-        }
-        else {
-            say STDERR "Should lock Luks device.";
-        }
+        $self->subtitle->set_text($self->encoding->decode(gettext(
+            q{Mounting Tails persistence partition.}
+        )));
+        $self->description->set_text($self->encoding->decode(gettext(
+            q{The Tails persistence partition will be mounted.}
+        )));
+        $self->working(1);
+        systemx(qw{/sbin/udevadm settle});
+        my $mountpoint = $self->mount_persistence_partition_cb->();
+        $self->working(0);
+        say STDERR "mounted persistence partition on $mountpoint";
+
+        $self->subtitle->set_text($self->encoding->decode(gettext(
+            q{Correcting permissions of the persistent volume.}
+        )));
+        $self->description->set_text($self->encoding->decode(gettext(
+            q{The permissions of the persistent volume will be corrected.}
+        )));
+        $self->working(1);
+        systemx(qw{sudo -n /usr/bin/tails-fix-persistent-volume-permissions});
+        $self->working(0);
+        say STDERR "fixed permissions.";
+
+        $self->subtitle->set_text($self->encoding->decode(gettext(
+            q{Creating default persistence configuration.}
+        )));
+        $self->description->set_text($self->encoding->decode(gettext(
+            q{The default persistence configuration will be created.}
+        )));
+        $self->working(1);
+        $self->create_configuration_cb->();
+        $self->working(0);
+        say STDERR "created default persistence configuration.";
 
         $self->success_callback->();
     }
@@ -332,5 +372,5 @@ sub go_button_pressed {
 with 'Tails::Persistence::Role::StatusArea';
 with 'Tails::Persistence::Role::SetupStep';
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Step/Configure.pm b/usr/share/perl5/Tails/Persistence/Step/Configure.pm
index 751d8e3..5aa19b7 100644
--- a/usr/share/perl5/Tails/Persistence/Step/Configure.pm
+++ b/usr/share/perl5/Tails/Persistence/Step/Configure.pm
@@ -5,18 +5,16 @@ Tails::Persistence::Step::Configure - configure which bits are persistent
 =cut
 
 package Tails::Persistence::Step::Configure;
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
 
+use 5.10.1;
+use strictures 2;
 
 use Glib qw{TRUE FALSE};
 
 use Carp::Assert::More;
 use Number::Format qw(:subs);
-use Tails::Persistence::Configuration::Button;
+use Tails::Persistence::Configuration;
+use Tails::Persistence::Configuration::Setting;
 use Try::Tiny;
 
 use Locale::gettext;
@@ -24,25 +22,49 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-persistence-setup");
 
+use Moo;
+use MooX::late;
+use MooX::HandlesVia;
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'configuration' => required ro 'Tails::Persistence::Configuration';
-
-has 'persistence_partition_device_file' => required ro Str;
-has 'persistence_partition_size' => required ro Int;
-
-has 'list_box' => lazy_build ro 'Gtk3::VBox';
-
-has 'buttons'  =>
-    lazy_build ro 'ArrayRef[Tails::Persistence::Configuration::Button]',
-    traits  => [ 'Array' ],
-    handles => {
-        all_buttons => 'elements',
-        push_button => 'push',
-    };
+has 'configuration' => (
+    required => 1,
+    is       => 'ro',
+    isa      => 'Tails::Persistence::Configuration',
+);
+
+has 'persistence_partition_device_file' => (
+    required => 1,
+    is       => 'ro',
+    isa      => 'Str',
+);
+has 'persistence_partition_size' => (
+    required => 1,
+    is       => 'ro',
+    isa      => 'Int',
+);
+
+has 'list_box' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Gtk3::ListBox',
+);
+
+has 'settings' => (
+    lazy_build  => 1,
+    is          => 'ro',
+    isa         => 'ArrayRef[Tails::Persistence::Configuration::Setting]',
+    handles_via => [ 'Array' ],
+    handles     => {
+        all_settings  => 'elements',
+        push_settings => 'push',
+    },
+);
 
 
 =head1 CONSTRUCTORS
@@ -54,7 +76,7 @@ sub BUILD {
 
     # Force initialization in the right order
     assert_defined($self->configuration);
-    assert_defined($self->buttons);
+    assert_defined($self->settings);
     assert_defined($self->list_box);
 
     $self->title->set_text($self->encoding->decode(gettext(
@@ -75,21 +97,23 @@ sub BUILD {
     $self->go_button->set_sensitive(TRUE);
 }
 
-method _build_main_box {
-    my $box = Gtk3::VBox->new();
-    $box->set_spacing(6);
-    $box->pack_start($self->title, FALSE, FALSE, 0);
-    $box->pack_start($self->subtitle, FALSE, FALSE, 0);
-    $box->pack_start($self->description, FALSE, FALSE, 0);
+sub _build_main_widget {
+    my $self = shift;
 
     my $viewport = Gtk3::Viewport->new;
     $viewport->set_shadow_type('GTK_SHADOW_NONE');
     $viewport->add($self->list_box);
+
     my $scrolled_win = Gtk3::ScrolledWindow->new;
     $scrolled_win->set_policy('automatic', 'automatic');
     $scrolled_win->add($viewport);
-    $box->pack_start($scrolled_win, TRUE, TRUE, 0);
 
+    my $box = Gtk3::VBox->new();
+    $box->set_spacing(6);
+    $box->pack_start($self->title, FALSE, FALSE, 0);
+    $box->pack_start($self->subtitle, FALSE, FALSE, 0);
+    $box->pack_start($self->description, FALSE, FALSE, 0);
+    $box->pack_start($scrolled_win, TRUE, TRUE, 0);
     $box->pack_start($self->status_area, FALSE, FALSE, 0);
 
     my $button_alignment = Gtk3::Alignment->new(1.0, 0, 0.2, 1.0);
@@ -100,21 +124,43 @@ method _build_main_box {
     return $box;
 }
 
-method _build_buttons {
-    [
-        map {
-            Tails::Persistence::Configuration::Button->new(atom => $_)
-        } $self->configuration->all_atoms
-    ]
+sub _build_settings {
+    my $self = shift;
+    my @settings;
+    foreach my $preset ($self->configuration->presets->all) {
+        my %init_args;
+        if (exists($preset->{configuration_cb}) && defined($preset->{configuration_cb})) {
+            $init_args{configuration_cb} = $preset->{configuration_cb};
+        }
+        push @settings,
+            Tails::Persistence::Configuration::Setting->new(
+                id          => $preset->{id},
+                atoms       => $preset->{atoms},
+                name        => $preset->{name},
+                description => $preset->{description},
+                icon_name   => $preset->{icon_name},
+                enabled     => $preset->{enabled},
+                %init_args,
+            );
+    }
+    foreach my $atom ($self->configuration->atoms_not_in_presets) {
+        push @settings,
+            Tails::Persistence::Configuration::Setting->new(atoms => [$atom]);
+    }
+    return \@settings;
 }
 
-method _build_list_box {
-    my $box = Gtk3::VBox->new();
-    $box->set_spacing(6);
-    $box->pack_start($_->main_widget, FALSE, FALSE, 0) foreach $self->all_buttons;
-    $self->refresh_buttons;
+sub _build_list_box {
+    my $self = shift;
 
-    return $box;
+    my $list_box = Gtk3::ListBox->new();
+    $list_box->set_selection_mode('GTK_SELECTION_NONE');
+    foreach my $setting ($self->all_settings) {
+        $list_box->insert($setting->main_widget, -1);
+        $list_box->insert(Gtk3::Separator->new('GTK_ORIENTATION_HORIZONTAL'), -1);
+    }
+
+    return $list_box;
 }
 
 
@@ -122,7 +168,9 @@ method _build_list_box {
 
 =cut
 
-method operation_finished ($error) {
+sub operation_finished {
+    my $self = shift;
+    my $error = shift;
     if ($error) {
         $self->working(0);
         say STDERR "$error";
@@ -136,7 +184,8 @@ method operation_finished ($error) {
     }
 }
 
-method go_button_pressed {
+sub go_button_pressed {
+    my $self = shift;
     $self->list_box->hide;
     $self->working(1);
     $self->subtitle->set_text(
@@ -155,12 +204,8 @@ method go_button_pressed {
     $self->operation_finished($error);
 }
 
-method refresh_buttons {
-    $_->refresh_display foreach $self->all_buttons;
-}
-
 with 'Tails::Persistence::Role::StatusArea';
 with 'Tails::Persistence::Role::SetupStep';
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Step/Delete.pm b/usr/share/perl5/Tails/Persistence/Step/Delete.pm
index 88916ff..253d68b 100644
--- a/usr/share/perl5/Tails/Persistence/Step/Delete.pm
+++ b/usr/share/perl5/Tails/Persistence/Step/Delete.pm
@@ -5,11 +5,9 @@ Tails::Persistence::Step::Delete - delete persistent storage
 =cut
 
 package Tails::Persistence::Step::Delete;
-use Moose;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
 
+use 5.10.1;
+use strictures 2;
 
 use Glib qw{TRUE FALSE};
 
@@ -20,14 +18,30 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-persistence-setup");
 
+use Moo;
+use MooX::late;
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'persistence_partition_device_file' => required ro Str;
-has 'persistence_partition_size' => required ro Int;
-has 'warning_icon'               => lazy_build rw 'Gtk3::Image';
+has 'persistence_partition_device_file' => (
+    required => 1,
+    is       => 'ro',
+    isa      => 'Str',
+);
+has 'persistence_partition_size' => (
+    required => 1,
+    is       => 'ro',
+    isa      => 'Int',
+);
+has 'warning_icon' => (
+    lazy_build => 1,
+    is         => 'rw',
+    isa        => 'Gtk3::Image',
+);
 
 
 =head1 CONSTRUCTORS
@@ -59,7 +73,7 @@ sub _build_warning_icon {
     Gtk3::Image->new_from_stock("gtk-dialog-warning", "GTK_ICON_SIZE_DIALOG");
 }
 
-sub _build_main_box {
+sub _build_main_widget {
     my $self = shift;
 
     my $box = Gtk3::VBox->new();
@@ -122,5 +136,5 @@ sub go_button_pressed {
 with 'Tails::Persistence::Role::StatusArea';
 with 'Tails::Persistence::Role::SetupStep';
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/Persistence/Utils.pm b/usr/share/perl5/Tails/Persistence/Utils.pm
index a58b02e..ac44cbe 100644
--- a/usr/share/perl5/Tails/Persistence/Utils.pm
+++ b/usr/share/perl5/Tails/Persistence/Utils.pm
@@ -6,21 +6,20 @@ Tails::Persistence::Utils - utilities for Tails persistent storage
 
 package Tails::Persistence::Utils;
 
-use strict;
-use warnings FATAL => 'all';
+use strictures 2;
 use 5.10.1;
 
+use Carp;
+use IPC::System::Simple qw{capturex};
+use List::MoreUtils qw{last_value};
+use Path::Tiny;
 
+use namespace::clean;
 
 use Exporter;
 our @ISA = qw{Exporter};
 our @EXPORT = qw{align_up_at_2MiB align_down_at_2MiB step_name_to_class_name get_variable_from_file check_config_file_permissions};
 
-use Carp;
-use IPC::System::Simple qw{capturex};
-use List::MoreUtils qw{last_value};
-use Path::Class;
-
 
 =head1 FUNCTIONS
 
@@ -64,7 +63,7 @@ sub get_variable_from_file {
     my $file     = shift;
     my $variable = shift;
 
-    foreach my $line (file($file)->slurp(chomp => 1)) {
+    foreach my $line (path($file)->lines({chomp => 1})) {
         if (my ($name, $value) =
                 ($line =~ m{\A [[:space:]]* ($variable)=(.*) \z}xms)) {
             return $value;
@@ -94,6 +93,8 @@ sub check_config_file_permissions {
     # ownership
     foreach my $field (qw{uid gid}) {
         my $actual_value = $st->$field;
+        croak("Expected value for '$field' is not defined")
+            unless defined $expected->{$field};
         $actual_value eq $expected->{$field}
             or croak("persistence.conf has unsafe $field: '$actual_value'");
     }
