diff --git a/usr/share/perl5/Tails.pm b/usr/share/perl5/Tails.pm
index 2d48039..ed03d12 100644
--- a/usr/share/perl5/Tails.pm
+++ b/usr/share/perl5/Tails.pm
@@ -11,11 +11,12 @@ Version
 package Tails;
 
 use 5.10.1;
-use namespace::autoclean;
 use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
+use namespace::clean;
+
 our $VERSION = '1.2';
 
 1;
diff --git a/usr/share/perl5/Tails/Constants.pm b/usr/share/perl5/Tails/Constants.pm
index 915601d..6063439 100644
--- a/usr/share/perl5/Tails/Constants.pm
+++ b/usr/share/perl5/Tails/Constants.pm
@@ -1,17 +1,24 @@
 package Tails::Constants;
-use Moose;
-use MooseX::Has::Sugar::Saccharin;
-use MooseX::Types::Moose qw{Str};
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
-use Method::Signatures::Simple;
+use Moo;
+use MooX::late;
+use namespace::clean;
 
-has 'system_partition_label' => lazy_build ro Str;
-method _build_system_partition_label { 'Tails' }
+has 'system_partition_label' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Str',
+);
 
-no Moose;
+sub _build_system_partition_label {
+    my $self = shift;
+    'Tails'
+}
+
+no Moo;
 1; # End of Tails::Constants
diff --git a/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm b/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm
index dfa6976..5261e62 100644
--- a/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm
+++ b/usr/share/perl5/Tails/Role/DisplayError/Gtk3.pm
@@ -1,13 +1,15 @@
 package Tails::Role::DisplayError::Gtk3;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
-
 use Carp::Assert::More;
 
+use Moo::Role;
+use MooX::late;
+use namespace::clean;
+
 sub display_error {
     my $self        = shift;
     my $main_window = shift;
@@ -28,5 +30,5 @@ sub display_error {
     $dialog->run;
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::Role::DisplayError::Gtk3
diff --git a/usr/share/perl5/Tails/Role/HasCodeset.pm b/usr/share/perl5/Tails/Role/HasCodeset.pm
index 08ed86c..14869be 100644
--- a/usr/share/perl5/Tails/Role/HasCodeset.pm
+++ b/usr/share/perl5/Tails/Role/HasCodeset.pm
@@ -5,15 +5,19 @@ Tails::Role::HasCodeset - role to get the codeset being used
 =cut
 
 package Tails::Role::HasCodeset;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
 use Try::Tiny;
 
+use Moo::Role; # Moo::Role exports all methods declared after it's "use"'d
+use MooX::late;
+
+use namespace::clean;
+
 has 'codeset'  => (
     isa        => 'Str',
     is         => 'ro',
@@ -32,5 +36,5 @@ sub _build_codeset {
     $codeset;
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::Role::HasCodeset
diff --git a/usr/share/perl5/Tails/Role/HasDBus/System.pm b/usr/share/perl5/Tails/Role/HasDBus/System.pm
index 34aefce..9e99d79 100644
--- a/usr/share/perl5/Tails/Role/HasDBus/System.pm
+++ b/usr/share/perl5/Tails/Role/HasDBus/System.pm
@@ -5,18 +5,20 @@ Tails::HasDBus::System - role providing a connection to the system DBus
 =cut
 
 package Tails::Role::HasDBus::System;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
-use Carp::Assert;
 use Carp::Assert::More;
 use Net::DBus qw(:typing);
 use Net::DBus::GLib;
 
+use Moo::Role;
+use MooX::late;
+use namespace::clean;
+
 has 'dbus'  => (
     isa        => 'Net::DBus',
     is         => 'ro',
@@ -30,5 +32,5 @@ sub _build_dbus {
     return $dbus;
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::HasDBus::System
diff --git a/usr/share/perl5/Tails/Role/HasEncoding.pm b/usr/share/perl5/Tails/Role/HasEncoding.pm
index fdc7ba7..1cba08c 100644
--- a/usr/share/perl5/Tails/Role/HasEncoding.pm
+++ b/usr/share/perl5/Tails/Role/HasEncoding.pm
@@ -4,32 +4,34 @@ Tails::Role::HasEncoding - role to provide an Encode::Encoding objet for the cod
 
 =head1 SYNOPSIS
 
-    use MooseX::Declare;
-    class Tails::Daemon with Tails::Role::HasEncoding {
-        method foo (Str $bytes) { $self->encoding-> }
+    package Tails::Daemon;
+    use Moo;
+    with 'Tails::Role::HasEncoding';
+    sub foo {
+       my $self = shift;
+       $self->encoding->decode('bla');
     }
 
-    See Tails::Daemon for a real-life usage example.
-
 =cut
 
 package Tails::Role::HasEncoding;
-use Moose::Role;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
-with 'Tails::Role::HasCodeset';
 use Encode qw{find_encoding};
-use Moose::Util::TypeConstraints;
 
-class_type('Encode::Encoding');
-class_type('Encode::XS');
+use Moo::Role; # Moo::Role exports all methods declared after it's "use"'d
+use MooX::late;
+
+with 'Tails::Role::HasCodeset';
+
+use namespace::clean;
 
 has 'encoding' => (
-    isa        => 'Encode::Encoding | Encode::XS',
+    isa        => 'Encode::Encoding|Encode::XS',
     is         => 'ro',
     lazy_build => 1,
 );
@@ -39,5 +41,5 @@ sub _build_encoding {
     find_encoding($self->codeset);
 }
 
-no Moose::Role;
+no Moo::Role;
 1; # End of Tails::Role::HasEncoding
diff --git a/usr/share/perl5/Tails/RunningSystem.pm b/usr/share/perl5/Tails/RunningSystem.pm
index 5a6ca52..f215500 100644
--- a/usr/share/perl5/Tails/RunningSystem.pm
+++ b/usr/share/perl5/Tails/RunningSystem.pm
@@ -6,123 +6,185 @@ Tails::RunningSystem - class that represents the running Tails system
 
 package Tails::RunningSystem;
 
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-with 'Tails::Role::HasEncoding';
-with 'Tails::Role::DisplayError::Gtk3';
-
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
 use Carp;
 use Carp::Assert::More;
 use Data::Dumper;
-use Path::Class;
+use Path::Tiny;
 use Sys::Statistics::Linux::MemStats;
 use Tails::Constants;
 use Tails::UDisks;
 use Try::Tiny;
+use Types::Path::Tiny qw{Dir};
 
 use Locale::gettext;
 use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-perl5lib");
 
+use Moo;
+use MooX::late;
+
+with 'Tails::Role::HasEncoding';
+with 'Tails::Role::DisplayError::Gtk3';
+
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'upgrade_description_url_schema_version' => lazy_build ro Int;
+has 'upgrade_description_url_schema_version' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Int',
+);
 
-has "$_" => lazy_build ro Str
-    for (
+has "$_" => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Str',
+) for (
         qw{baseurl product_name product_version build_target channel},
         qw{upgrade_description_file_url upgrade_description_sig_url},
         qw{dev_dir os_release_file proc_dir run_dir},
     );
 
-has 'udisks' =>
-    lazy_build ro 'Tails::UDisks',
-    handles => [ qw{bytes_array_to_string device_installed_with_tails_installer
-                    get_block_device_property get_drive_property
-                    get_partition_property
-                    underlying_block_device underlying_drive} ];
+has 'udisks' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Tails::UDisks',
+    handles    => [ qw{bytes_array_to_string device_installed_with_tails_installer
+                       get_block_device_property get_drive_property
+                       get_partition_property
+                       underlying_block_device underlying_drive} ],
+);
 
 has 'liveos_mountpoint' => (
-    isa        => 'Path::Class::Dir',
+    isa        => Dir,
     is         => 'rw',
     lazy_build => 1,
-    coerce     => 1,
+    coerce     => Dir->coercion,
     documentation => q{Mountpoint of the Tails system image.},
 );
 
-has 'boot_drive' =>
-    lazy_build rw Str,
-    documentation => q{The UDI of the physical drive where Tails is installed, e.g. /org/freedesktop/UDisks2/drives/Verbatim_ABC_2786.};
+has 'boot_drive' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The UDI of the physical drive where Tails is installed, e.g. /org/freedesktop/UDisks2/drives/Verbatim_ABC_2786.},
+);
 
-has 'boot_block_device' =>
-    lazy_build rw Str,
-    documentation => q{The UDI of the block device where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb.};
+has 'boot_block_device' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The UDI of the block device where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb.}
+);
 
-has 'boot_device_file' =>
-    lazy_build rw Str,
-    documentation => q{The path of the physical drive where Tails is installed, e.g. /dev/sdb.};
+has 'boot_device_file' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The path of the physical drive where Tails is installed, e.g. /dev/sdb.},
+);
 
-has 'system_partition' =>
-    lazy_build rw Str,
-    documentation => q{The UDI of the partition where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb1.};
+has 'system_partition' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The UDI of the partition where Tails is installed, e.g. /org/freedesktop/UDisks2/block_devices/sdb1.},
+);
 
-has 'system_partition_file' =>
-    lazy_build rw Str,
-    documentation => q{The path of the partition where Tails is installed, e.g. /dev/sdb1.};
+has 'system_partition_file' => (
+    lazy_build    => 1,
+    is            => 'rw',
+    isa           => 'Str',
+    documentation => q{The path of the partition where Tails is installed, e.g. /dev/sdb1.},
+);
 
-has 'constants' =>
-    lazy_build ro 'Tails::Constants',
-    metaclass => 'NoGetopt',
-    handles   => [ qw{system_partition_label}];
+has 'constants' => (
+    lazy_build => 1,
+    is         => 'ro',
+    isa        => 'Tails::Constants',
+    handles    => [ qw{system_partition_label}],
+);
 
-has 'main_window' => ro 'Gtk3::Window';
+has 'main_window' => (
+    is  => 'ro',
+    isa => 'Gtk3::Window',
+);
 
-foreach (qw{boot_drive_vendor boot_drive_model}) {
-    has $_ => lazy_build ro Str;
+foreach (qw{boot_drive_vendor boot_drive_model
+            override_started_from_device_installed_with_tails_installer}) {
+    has $_ => (
+        lazy_build => 1,
+        is         => 'ro',
+        isa        => 'Str',
+    );
 }
 
-has 'override_started_from_device_installed_with_tails_installer' =>
-    lazy_build ro Str;
-
 
 =head1 CONSTRUCTORS AND BUILDERS
 
 =cut
 
-method _build_upgrade_description_url_schema_version { 1 }
-method _build_dev_dir         { '/dev' }
-method _build_os_release_file { '/etc/os-release' }
-method _build_proc_dir        { '/proc' }
-method _build_run_dir         { '/var/run' }
-method _build_product_name    { $self->os_release_get('TAILS_PRODUCT_NAME') }
-method _build_product_version { $self->os_release_get('TAILS_VERSION_ID')   }
-method _build_baseurl         { 'https://tails.boum.org' }
-method _build_udisks          { Tails::UDisks->new(); }
-
-method _build_build_target {
+sub _build_upgrade_description_url_schema_version {
+    my $self = shift;
+    1
+}
+sub _build_dev_dir {
+    my $self = shift;
+    '/dev'
+}
+sub _build_os_release_file {
+    my $self = shift;
+    '/etc/os-release'
+}
+sub _build_proc_dir {
+    my $self = shift;
+    '/proc'
+}
+sub _build_run_dir {
+    my $self = shift;
+    '/var/run'
+}
+sub _build_product_name {
+    my $self = shift;
+    $self->os_release_get('TAILS_PRODUCT_NAME')
+}
+sub _build_product_version {
+    my $self = shift;
+    $self->os_release_get('TAILS_VERSION_ID')
+}
+sub _build_baseurl {
+    my $self = shift;
+    'https://tails.boum.org'
+}
+sub _build_udisks {
+    my $self = shift;
+    Tails::UDisks->new();
+}
+
+sub _build_build_target {
+    my $self = shift;
     my $arch = `dpkg --print-architecture`; chomp $arch; return $arch;
 }
 
-method _build_channel {
+sub _build_channel {
+    my $self = shift;
     my $channel;
     try { $channel = $self->os_release_get('TAILS_CHANNEL') };
     defined $channel ? $channel : 'stable';
 }
 
-method _build_upgrade_description_file_url {
+sub _build_upgrade_description_file_url {
+    my $self = shift;
     sprintf(
         "%s/upgrade/v%d/%s/%s/%s/%s/upgrades.yml",
         $self->baseurl,
@@ -134,17 +196,19 @@ method _build_upgrade_description_file_url {
     );
 }
 
-method _build_upgrade_description_sig_url {
+sub _build_upgrade_description_sig_url {
+    my $self = shift;
     $self->upgrade_description_file_url . '.pgp';
 }
 
-method _build_constants {
+sub _build_constants {
+    my $self = shift;
     Tails::Constants->new();
 }
 
 sub _build_liveos_mountpoint {
     my $self = shift;
-    dir('/lib/live/mount/medium');
+    path('/lib/live/mount/medium');
 }
 
 sub _build_boot_block_device {
@@ -251,11 +315,13 @@ http://www.freedesktop.org/software/systemd/man/os-release.html
 Throws an exception if not found.
 
 =cut
-method os_release_get ($key) {
+sub os_release_get {
+    my $self = shift;
+    my $key = shift;
     assert(-e $self->os_release_file);
     assert_like($key, qr{[_A-Z]+});
 
-    my $fh = file($self->os_release_file)->openr;
+    my $fh = path($self->os_release_file)->openr;
 
     while (<$fh>) {
         chomp;
@@ -270,16 +336,18 @@ method os_release_get ($key) {
     ));
 }
 
-method started_from_device_installed_with_tails_installer () {
+sub started_from_device_installed_with_tails_installer {
+    my $self = shift;
     return $self->override_started_from_device_installed_with_tails_installer
         if $self->has_override_started_from_device_installed_with_tails_installer;
     $self->device_installed_with_tails_installer($self->boot_block_device);
 }
 
-method started_from_writable_device () {
+sub started_from_writable_device {
+    my $self = shift;
     assert(-d $self->dev_dir);
 
-    -e file($self->dev_dir, 'bilibop');
+    -e path($self->dev_dir, 'bilibop');
 }
 
 =head2 free_memory
@@ -287,14 +355,15 @@ method started_from_writable_device () {
 Returns MemFree + Buffers + Cached, in bytes.
 
 =cut
-method free_memory () {
+sub free_memory {
+    my $self = shift;
     assert(-d $self->proc_dir);
-    assert(-e file($self->proc_dir, 'meminfo'));
+    assert(-e path($self->proc_dir, 'meminfo'));
 
     Sys::Statistics::Linux::MemStats->new(
         files => { path => $self->proc_dir }
     )->get->{realfree} * 1024;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/UDisks.pm b/usr/share/perl5/Tails/UDisks.pm
index 7216782..c0ae00b 100644
--- a/usr/share/perl5/Tails/UDisks.pm
+++ b/usr/share/perl5/Tails/UDisks.pm
@@ -5,10 +5,9 @@ Tails::UDisks - role providing a connection to UDisks via DBus
 =cut
 
 package Tails::UDisks;
-use Moose;
 
 use 5.10.1;
-use namespace::autoclean;
+use strict;
 use warnings FATAL => 'all';
 use autodie qw(:all);
 
@@ -17,7 +16,6 @@ use File::stat;
 use IPC::System::Simple qw{capturex};
 use Syntax::Keyword::Junction qw{any};
 use List::Util qw{first};
-use Method::Signatures::Simple;
 use Tails::Constants;
 use Unix::Mknod qw(:all);
 
@@ -26,24 +24,30 @@ use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-perl-lib");
 
+use Moo;
+use MooX::late;
+use namespace::clean;
+
 with 'Tails::Role::HasDBus::System';
 
-has 'constants' =>
+has 'constants' => (
     is         => 'ro',
     isa        => 'Tails::Constants',
     lazy_build => 1,
-    metaclass  => 'NoGetopt',
-    handles    => [ qw{system_partition_label}];
+    handles    => [ qw{system_partition_label}],
+);
 
-has 'udisks_service' =>
+has 'udisks_service' => (
     is         => 'ro',
     lazy_build => 1, # Let's decide the right initialization order in BUILD
-    isa        => 'Net::DBus::RemoteService';
+    isa        => 'Net::DBus::RemoteService',
+);
 
-has 'udisks_object' =>
+has 'udisks_object' => (
     is         => 'ro',
     lazy_build => 1, # Let's decide the right initialization order in BUILD
-    isa        => 'Net::DBus::RemoteObject';
+    isa        => 'Net::DBus::RemoteObject',
+);
 
 sub BUILD {
     my $self = shift;
@@ -54,26 +58,34 @@ sub BUILD {
     assert_defined($self->udisks_object);
 }
 
-method _build_constants {
+sub _build_constants {
+    my $self = shift;
     Tails::Constants->new();
 }
 
-method _build_udisks_service {
+sub _build_udisks_service {
+    my $self = shift;
     $self->dbus->get_service("org.freedesktop.UDisks2");
 }
 
-method _build_udisks_object {
+sub _build_udisks_object {
+    my $self = shift;
     $self->udisks_service->get_object(
         "/org/freedesktop/UDisks2",
         "org.freedesktop.DBus.ObjectManager"
     );
 }
 
-method debug {
+sub debug {
+    my $self = shift;
     say STDERR @_ if $ENV{DEBUG};
 }
 
-method get_udisks_property ($type, $object, $property) {
+sub get_udisks_property {
+    my $self     = shift;
+    my $type     = shift;
+    my $object   = shift;
+    my $property = shift;
     assert_defined($type);
     assert_defined($object);
     assert_defined($property);
@@ -85,27 +97,44 @@ method get_udisks_property ($type, $object, $property) {
          ->Get("org.freedesktop.UDisks2.$type", $property);
 }
 
-method get_block_device_property ($device, $property) {
+sub get_block_device_property {
+    my $self     = shift;
+    my $device   = shift;
+    my $property = shift;
     $self->get_udisks_property('Block', $device, $property);
 }
 
-method get_drive_property ($drive, $property) {
+sub get_drive_property {
+    my $self     = shift;
+    my $drive    = shift;
+    my $property = shift;
     $self->get_udisks_property('Drive', $drive, $property);
 }
 
-method get_partition_table_property ($device, $property) {
+sub get_partition_table_property {
+    my $self     = shift;
+    my $device   = shift;
+    my $property = shift;
     $self->get_udisks_property('PartitionTable', $device, $property);
 }
 
-method get_partition_property ($device, $property) {
+sub get_partition_property {
+    my $self     = shift;
+    my $device   = shift;
+    my $property = shift;
     $self->get_udisks_property('Partition', $device, $property);
 }
 
-method get_filesystem_property ($device, $property) {
+sub get_filesystem_property {
+    my $self     = shift;
+    my $device   = shift;
+    my $property = shift;
     $self->get_udisks_property('Filesystem', $device, $property);
 }
 
-method drive_is_connected_via_a_supported_interface ($drive) {
+sub drive_is_connected_via_a_supported_interface {
+    my $self  = shift;
+    my $drive = shift;
     assert_defined($drive);
 
     $self->debug("Entering drive_is_connected_via_a_supported_interface, $drive");
@@ -115,12 +144,16 @@ method drive_is_connected_via_a_supported_interface ($drive) {
     any(qw{sdio usb}) eq $iface;
 }
 
-method drive_is_optical ($drive) {
+sub drive_is_optical {
+    my $self  = shift;
+    my $drive = shift;
     assert_defined($drive);
     $self->get_drive_property($drive, 'Optical');
 }
 
-method partitions ($device) {
+sub partitions {
+    my $self   = shift;
+    my $device = shift;
     assert_defined($device);
 
     my $partition_re;
@@ -136,7 +169,9 @@ method partitions ($device) {
     } keys %{$self->udisks_object->GetManagedObjects()};
 }
 
-method luks_holder ($device) {
+sub luks_holder {
+    my $self   = shift;
+    my $device = shift;
     assert_defined($device);
 
     my %objects = %{$self->udisks_object->GetManagedObjects()};
@@ -152,7 +187,9 @@ method luks_holder ($device) {
     } keys %objects;
 }
 
-method bytes_array_to_string ($bytes_array) {
+sub bytes_array_to_string {
+    my $self        = shift;
+    my $bytes_array = shift;
     assert_listref($bytes_array);
 
     my @bytes_array = @{$bytes_array};
@@ -160,7 +197,9 @@ method bytes_array_to_string ($bytes_array) {
     return substr($null_terminated_str, 0, length($null_terminated_str) - 2);
 }
 
-method mountpoints ($device) {
+sub mountpoints {
+    my $self   = shift;
+    my $device = shift;
     assert_defined($device);
 
     my $luks_holder = $self->luks_holder($device);
@@ -171,7 +210,10 @@ method mountpoints ($device) {
     } @{$self->get_filesystem_property($real_device, 'MountPoints')};
 }
 
-method device_partition_with_label ($device, $label) {
+sub device_partition_with_label {
+    my $self   = shift;
+    my $device = shift;
+    my $label  = shift;
     assert_defined($device);
     assert_defined($label);
 
@@ -181,14 +223,19 @@ method device_partition_with_label ($device, $label) {
     } $self->partitions($device)
 }
 
-method device_has_partition_with_label ($device, $label) {
+sub device_has_partition_with_label {
+    my $self   = shift;
+    my $device = shift;
+    my $label  = shift;
     assert_defined($device);
     assert_defined($label);
 
     defined $self->device_partition_with_label($device, $label);
 }
 
-method device_installed_with_tails_installer ($device) {
+sub device_installed_with_tails_installer {
+    my $self   = shift;
+    my $device = shift;
     assert_defined($device);
 
     $self->debug("Entering device_installed_with_tails_installer: $device");
@@ -209,7 +256,9 @@ Returns the physical block device UDI (e.g.
 is stored.
 
 =cut
-method underlying_block_device ($path) {
+sub underlying_block_device {
+    my $self = shift;
+    my $path = shift;
     assert_defined($path);
 
     $self->debug("Entering underlying_block_device");
@@ -234,7 +283,9 @@ Returns the physical drive UDI (e.g.
 is stored.
 
 =cut
-method underlying_drive ($path) {
+sub underlying_drive {
+    my $self = shift;
+    my $path = shift;
     assert_defined($path);
 
     $self->debug("Entering underlying_drive");
@@ -246,5 +297,5 @@ method underlying_drive ($path) {
     return $drive;
 }
 
-no Moose;
+no Moo;
 1; # End of Tails::UDisks
