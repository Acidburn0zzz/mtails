diff --git a/usr/share/perl5/Tails/IUK.pm b/usr/share/perl5/Tails/IUK.pm
index aa94d16..d30a579 100644
--- a/usr/share/perl5/Tails/IUK.pm
+++ b/usr/share/perl5/Tails/IUK.pm
@@ -6,19 +6,12 @@ Tails::IUK - Incremental Upgrade Kit class
 
 package Tails::IUK;
 
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-
-
-with 'MooseX::Getopt::Dashes';
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
 use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -30,46 +23,86 @@ use Device::Cdio::ISO9660;
 use Device::Cdio::ISO9660::IFS;
 use English qw{-no_match_vars};
 use File::Basename;
-use File::Copy;
 use File::Spec::Functions;
-use File::Temp qw{tempdir tempfile};
-use Path::Class;
+use Function::Parameters;
+use Path::Tiny;
 use Tails::IUK::Utils qw{extract_file_from_iso extract_here_file_from_iso run_as_root};
+use Types::Path::Tiny qw{AbsDir AbsFile AbsPath File};
+use Types::Standard qw(ArrayRef Str);
 use Try::Tiny;
 use YAML::Any;
 
+use namespace::clean;
+
+use MooX::Options;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-foreach (qw{old_iso new_iso}) {
-    has $_ => required ro Str;
-}
-has 'squashfs_diff_name' =>
-    required ro Str,
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => File,
+    coerce   => File->coercion,
+    format   => 's',
+) for (qw{old_iso new_iso});
+
+option 'squashfs_diff_name' =>
+    required      => 1,
+    is            => 'ro',
+    isa           => Str,
+    format        => 's',
     documentation => q{Name of the SquashFS diff file that will be installed into the system partition};
-has 'outfile' =>
-    required coerce lazy_build ro 'Path::Class::File',
+
+option 'outfile' =>
+    required      => 1,
+    is            => 'lazy',
+    isa           => AbsPath,
+    coerce        => AbsPath->coercion,
+    format        => 's',
     documentation => q{Location of the created IUK};
-has 'format_version' => lazy_build ro Str, metaclass => 'NoGetopt';
-has 'squashfs_diff'  =>
-    coerce lazy_build ro 'Path::Class::File',
+
+has 'format_version' =>
+    is  => 'lazy',
+    isa => Str;
+
+option 'squashfs_diff' =>
+    is            => 'lazy',
+    isa           => AbsPath,
+    coerce        => AbsPath->coercion,
+    format        => 's',
     documentation => q{Internal, for test suite only};
-has 'delete_files'   => lazy_build ro 'ArrayRef[Str]', metaclass => 'NoGetopt';
-has 'new_kernels' => lazy_build ro 'ArrayRef[Str]', metaclass => 'NoGetopt';
-has 'tarballs' => lazy_build ro 'ArrayRef[Str]', documentation => q{Internal, for test suite only};
-has 'tempdir' => lazy_build ro 'Path::Class::Dir', metaclass => 'NoGetopt';
+
+has "$_" =>
+    is  => 'lazy',
+    isa => ArrayRef
+for (qw{delete_files new_kernels});
+
+option 'tarballs' =>
+    is            => 'lazy',
+    isa           => ArrayRef,
+    format        => 's@',
+    documentation => q{Internal, for test suite only};
+
+has 'tempdir' =>
+    is  => 'lazy',
+    isa => AbsDir;
+
 has 'tar_options' =>
-    lazy_build ro 'ArrayRef[Str]',
-    traits => ['Array'],
-    metaclass => 'NoGetopt',
-    handles => {
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         list_tar_options => 'elements',
     };
-has 'ignore_if_same_content' =>
-    lazy_build ro 'ArrayRef[Str]',
-    traits => ['Array'],
+
+option 'ignore_if_same_content' =>
+    is            => 'lazy',
+    isa           => ArrayRef,
+    handles_via   => 'Array',
+    format        => 's@',
     documentation => q{Do not include this file in the SquashFS if its content}.
                      q{has not changed. Globs are supported.};
 
@@ -90,15 +123,9 @@ Some was adapted from File::DirCompare:
     under the same terms as Perl itself.
 
 =cut
-sub missing_files_in_isos {
-    my $iso1 = shift;
-    my $iso2 = shift;
-    my $dir  = shift;
-
-    my $read_iso_dir = sub {
-        my $iso = shift;
-        my $dir = shift;
-        my $iso_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso);
+fun missing_files_in_isos ($iso1, $iso2, $dir) {
+    my $read_iso_dir = fun ($iso, $dir) {
+        my $iso_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso->stringify);
         map {
             Device::Cdio::ISO9660::name_translate($_->{filename});
         } $iso_obj->readdir($dir);
@@ -139,22 +166,12 @@ Some was adapted from File::DirCompare:
     under the same terms as Perl itself.
 
 =cut
-sub upgraded_or_new_files_in_isos {
-    my $iso1 = shift;
-    my $iso2 = shift;
-    my $dir  = shift;
-    my $whitelist_patterns = shift;
-
-    assert(-e $iso1);
-    assert(-e $iso2);
-
-    my $iso1_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso1);
-    my $iso2_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso2);
-
-    my $read_iso_dir = sub {
-        my $iso_obj = shift;
-        my $dir = shift;
+fun upgraded_or_new_files_in_isos (
+    AbsFile $iso1, AbsFile $iso2, $dir, $whitelist_patterns) {
+    my $iso1_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso1->stringify);
+    my $iso2_obj = Device::Cdio::ISO9660::IFS->new(-source => $iso2->stringify);
 
+    my $read_iso_dir = fun ($iso_obj, $dir) {
         assert(defined($iso_obj));
         my @wanted_files;
         my @files_in_dir;
@@ -205,12 +222,12 @@ sub upgraded_or_new_files_in_isos {
         croak "File $f in $iso2 is a directory." if $stat2->{is_dir};
 
         push @res, $f if
-            extract_file_from_iso(catfile($dir, $f), $iso1)
+            extract_file_from_iso(path($dir, $f), path($iso1))
                 ne
-            extract_file_from_iso(catfile($dir, $f), $iso2);
+            extract_file_from_iso(path($dir, $f), path($iso2));
     }
 
-    return map { file($dir, $_)->basename } @res;
+    return map { path($dir, $_)->basename } @res;
 }
 
 
@@ -218,34 +235,34 @@ sub upgraded_or_new_files_in_isos {
 
 =cut
 
-method _build_ignore_if_same_content { []; }
-method _build_tempdir { dir(tempdir()); }
-method _build_format_version { "1"; }
-method _build_tar_options { [
+method _build_ignore_if_same_content () { []; }
+method _build_tempdir () { Path::Tiny->tempdir; }
+method _build_format_version () { "1"; }
+method _build_tar_options () { [
     qw{--numeric-owner --owner=root --group=root},
     qw{--sort=name --clamp-mtime}, "--mtime=\@$ENV{SOURCE_DATE_EPOCH}",
 ]; }
-method _build_squashfs_diff  {
+method _build_squashfs_diff () {
     my $tempdir = $self->tempdir;
 
-    my $old_iso_mount      = dir($tempdir, 'old_iso');
-    my $new_iso_mount      = dir($tempdir, 'new_iso');
-    my $old_squashfs_mount = dir($tempdir, 'old_squashfs');
-    my $new_squashfs_mount = dir($tempdir, 'new_squashfs');
-    my $tmpfs              = dir($tempdir, 'tmpfs');
-    my $union              = dir($tempdir, 'union');
+    my $old_iso_mount      = $tempdir->child('old_iso');
+    my $new_iso_mount      = $tempdir->child('new_iso');
+    my $old_squashfs_mount = $tempdir->child('old_squashfs');
+    my $new_squashfs_mount = $tempdir->child('new_squashfs');
+    my $tmpfs              = $tempdir->child('tmpfs');
+    my $union              = $tempdir->child('union');
 
     for my $dir ($old_iso_mount, $new_iso_mount, $old_squashfs_mount, $new_squashfs_mount, $tmpfs, $union) {
-        mkdir $dir;
+        $dir->mkpath;
     }
 
     run_as_root("mount", "-o", "loop,ro", $self->old_iso, $old_iso_mount);
-    my $old_squashfs = file($old_iso_mount, 'live', 'filesystem.squashfs');
+    my $old_squashfs = path($old_iso_mount, 'live', 'filesystem.squashfs');
     croak "SquashFS '$old_squashfs' not found in '$old_iso_mount'" unless -e $old_squashfs;
     run_as_root(qw{mount -t squashfs -o loop}, $old_squashfs, $old_squashfs_mount);
 
     run_as_root("mount", "-o", "loop,ro", $self->new_iso, $new_iso_mount);
-    my $new_squashfs = file($new_iso_mount, 'live', 'filesystem.squashfs');
+    my $new_squashfs = path($new_iso_mount, 'live', 'filesystem.squashfs');
     croak "SquashFS '$new_squashfs' not found in '$new_iso_mount'" unless -e $new_squashfs;
     run_as_root(qw{mount -t squashfs -o loop}, $new_squashfs, $new_squashfs_mount);
 
@@ -260,13 +277,13 @@ method _build_squashfs_diff  {
     run_as_root(
         "rsync", "--archive", "--quiet", "--delete-after", "--acls",
         "--checksum",
-        sprintf("%s/", dir($new_squashfs_mount)),
-        sprintf("%s/", dir($union)),
+        sprintf("%s/", $new_squashfs_mount),
+        sprintf("%s/", $union),
     );
 
     for my $glob (@{$self->ignore_if_same_content}) {
         my @candidates_for_removal = map {
-            file($_)
+            path($_)
         } grep { -e } glob("$tmpfs/$glob");
 
         map {
@@ -275,20 +292,20 @@ method _build_squashfs_diff  {
             my $candidate     = $_;
             my $candidate_rel = "$candidate";
             $candidate_rel    =~ s{^$tmpfs/}{}xms;
-            my $candidate_old = $old_squashfs_mount->file($candidate_rel);
+            my $candidate_old = $old_squashfs_mount->child($candidate_rel);
             -e $candidate_old && $candidate_old->slurp eq $candidate->slurp;
         } @candidates_for_removal;
     }
 
     run_as_root('auplink', $union, 'flush');
 
-    my ($squashfs_diff_fh, $squashfs_diff_filename) = tempfile(DIR => $tempdir);
+    my $squashfs_diff_file = Path::Tiny->tempfile(DIR => $tempdir);
 
     run_as_root(
         "SOURCE_DATE_EPOCH=$ENV{SOURCE_DATE_EPOCH}",
         qw{mksquashfs},
         $tmpfs,
-        $squashfs_diff_filename,
+        $squashfs_diff_file,
         qw{-no-progress -noappend -comp xz -Xbcj x86 -b 1024K -Xdict-size 1024K}
     );
 
@@ -297,12 +314,12 @@ method _build_squashfs_diff  {
         run_as_root("umount", $_);
     }
 
-    return file($squashfs_diff_filename);
+    return $squashfs_diff_file;
 }
 
-method _build_delete_files {
-    my $old_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->old_iso);
-    my $new_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->new_iso);
+method _build_delete_files () {
+    my $old_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->old_iso->stringify);
+    my $new_iso_obj = Device::Cdio::ISO9660::IFS->new(-source=>$self->new_iso->stringify);
     my @delete_files;
     for (qw{EFI isolinux live syslinux tails utils}) {
         push @delete_files,
@@ -311,7 +328,7 @@ method _build_delete_files {
     return \@delete_files;
 }
 
-method _build_new_kernels {
+method _build_new_kernels () {
     my @new_kernels =
         upgraded_or_new_files_in_isos(
             $self->old_iso,
@@ -325,9 +342,9 @@ method _build_new_kernels {
     return \@new_kernels;
 }
 
-method write_boot_tarball {
+method write_boot_tarball () {
     my $orig_cwd = getcwd;
-    my $boot_files_tempdir = tempdir(CLEANUP => 1);
+    my $boot_files_tempdir = Path::Tiny->tempdir(CLEANUP => 1);
 
     chdir $boot_files_tempdir;
     extract_here_file_from_iso('EFI',      $self->new_iso);
@@ -341,17 +358,12 @@ method write_boot_tarball {
     rename 'syslinux/isolinux.cfg', 'syslinux/syslinux.cfg';
 
     foreach my $file (glob('syslinux/*')) {
-        my $content = file($file)->slurp;
-        $content =~ s{/isolinux/}{/syslinux/}gxms;
-        my ($temp_fh, $temp_filename) = tempfile;
-        print $temp_fh $content;
-        close $temp_fh;
-        rename $temp_filename, $file;
+        path($file)->edit_lines(sub { s{/isolinux/}{/syslinux/}gxms });
     }
 
     system(
         qw{tar -cj}, $self->list_tar_options,
-        '-f', file($self->tempdir, 'boot.tar.bz2'), 'EFI', 'syslinux', 'utils',
+        '-f', path($self->tempdir, 'boot.tar.bz2'), 'EFI', 'syslinux', 'utils',
     );
 
     chdir $orig_cwd;
@@ -359,30 +371,29 @@ method write_boot_tarball {
     return;
 }
 
-method write_system_tarball {
-    my $tarball = file($self->tempdir, 'system.tar');
+method write_system_tarball () {
+    my $tarball = path($self->tempdir, 'system.tar');
 
-    chdir $self->squashfs_diff->dir;
-    my $destname = file('live', $self->squashfs_diff_name);
-    my $destdir  = file($destname)->dir;
-    $destdir->mkpath;
-    -d $destdir or croak(sprintf("Could not make directory '%s': $!"), $destdir);
-    copy($self->squashfs_diff->basename, $destname)
+    chdir $self->squashfs_diff->parent;
+    my $destpath = path('live', $self->squashfs_diff_name);
+    $destpath->parent->mkpath;
+    $destpath->parent->is_dir or croak(sprintf("Could not make directory '%s': $!"), $destpath->parent);
+    $destpath = $self->squashfs_diff->copy($destpath)
         or croak(
             sprintf(
                 "Could not copy '%s' to '%s': $!",
-                $self->squashfs_diff->basename, $destname
+                $self->squashfs_diff->basename, $destpath
             )
         );
-    system(qw{tar --create}, $self->list_tar_options, '-f', $tarball, $destname);
-    unlink $destname;
+    system(qw{tar --create}, $self->list_tar_options, '-f', $tarball, $destpath);
+    $destpath->remove;
 
-    my $new_kernels_tempdir = tempdir(CLEANUP => 1);
+    my $new_kernels_tempdir = Path::Tiny->tempdir(CLEANUP => 1);
     chdir $new_kernels_tempdir;
     for my $new_kernel (@{$self->new_kernels}) {
-        my $new_kernel_rel = file('live', $new_kernel);
-        my $new_kernel_abs = file($new_kernels_tempdir, $new_kernel_rel);
-        $new_kernel_abs->dir->mkpath;
+        my $new_kernel_rel = path('live', $new_kernel);
+        my $new_kernel_abs = $new_kernels_tempdir->child($new_kernel_rel);
+        $new_kernel_abs->parent->mkpath;
         extract_here_file_from_iso($new_kernel_rel, $self->new_iso);
         system(
             qw{tar --append}, $self->list_tar_options, '-f', $tarball,
@@ -395,7 +406,7 @@ method write_system_tarball {
     return;
 }
 
-method _build_tarballs {
+method _build_tarballs () {
     $self->write_boot_tarball;
     $self->write_system_tarball;
     return [ qw{boot.tar.bz2 system.tar} ];
@@ -403,18 +414,13 @@ method _build_tarballs {
 
 method saveas ($outfile_name) {
     my $orig_cwd = getcwd;
-    my $fh;
     chdir $self->tempdir;
 
-    $fh = file('FORMAT')->openw;
-    print $fh $self->format_version;
-    close $fh;
+    path('FORMAT')->spew($self->format_version);
 
-    $fh = file('control.yml')->openw;
-    print $fh YAML::Any::Dump({
+    path('control.yml')->spew(YAML::Any::Dump({
         delete_files => $self->delete_files,
-    });
-    close $fh;
+    }));
 
     chdir $self->tempdir;
     system(
@@ -423,10 +429,10 @@ method saveas ($outfile_name) {
     );
 
     for (@{$self->tarballs}) {
-        chdir file($_)->dir;
+        chdir path($_)->parent;
         system(
             qw{tar --append}, $self->list_tar_options, '-f', $outfile_name,
-            file($_)->basename
+            path($_)->basename
         );
     }
 
@@ -449,5 +455,5 @@ method run () {
     $self->save;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/Archive/Tar.pm b/usr/share/perl5/Tails/IUK/Archive/Tar.pm
index 9c0f880..68be062 100644
--- a/usr/share/perl5/Tails/IUK/Archive/Tar.pm
+++ b/usr/share/perl5/Tails/IUK/Archive/Tar.pm
@@ -6,33 +6,24 @@ Tails::IUK::Archive::Tar - wrap, and add to Archive::Tar::Wrapper for Incrementa
 
 package Tails::IUK::Archive::Tar;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class qw{Dir File};
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
 
-
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Tails::IUK::Archive::Tar::Wrapper;
 use Carp;
-use File::Temp qw{tempdir};
+use File::Temp;
 use File::Which;
-use Path::Class qw{dir file};
+use Function::Parameters;
+use Path::Tiny;
 use Tails::IUK::Utils qw{run_as_root};
+use Types::Path::Tiny qw{AbsDir AbsFile};
+use Types::Standard qw{Bool InstanceOf Str};
 
-
-=head1 TYPES
-
-=cut
-
-class_type('Tails::IUK::Archive::Tar::Wrapper');
+use namespace::clean;
 
 
 =head1 ATTRIBUTES
@@ -41,16 +32,29 @@ class_type('Tails::IUK::Archive::Tar::Wrapper');
 
 has 'filename' => (
     is       => 'ro',
-    isa      => File,
+    isa      => AbsFile,
     required => 1,
-    coerce   => 1,
+    coerce   => AbsFile->coercion,
 );
 
-has 'sudo'        => lazy_build ro Bool;
-has 'tar_exe'     => coerce lazy_build ro File;
-has 'tempdir'     => coerce lazy_build ro Dir, predicate 'has_tempdir';
+has 'sudo' =>
+    is  => 'lazy',
+    isa => Bool;
+
+has 'tar_exe' =>
+    is     => 'lazy',
+    isa    => AbsFile,
+    coerce => AbsFile->coercion;
+
+has 'tempdir' =>
+    is     => 'lazy',
+    isa    => AbsDir,
+    coerce => AbsDir->coercion,
+    predicate => 1;
 
-has 'tar_wrapper' => lazy_build ro 'Tails::IUK::Archive::Tar::Wrapper',
+has 'tar_wrapper' =>
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::IUK::Archive::Tar::Wrapper'],
     handles => [ qw{list_all locate} ];
 
 
@@ -58,46 +62,46 @@ has 'tar_wrapper' => lazy_build ro 'Tails::IUK::Archive::Tar::Wrapper',
 
 =cut
 
-method BUILD {
+method BUILD (@arg) {
     $self->read_from($self->filename);
 }
 
-method _build_sudo    { 0 }
-method _build_tar_exe { $self->sudo ? which('sudo-tar') : which('tar') }
-method _build_tempdir { dir(tempdir(CLEANUP => 1), 'tar') }
+method _build_sudo ()    { 0 }
+method _build_tar_exe () { $self->sudo ? which('sudo-tar') : which('tar') }
+method _build_tempdir () { path(File::Temp::tempdir(CLEANUP => 1), 'tar') }
 
-method _build_tar_wrapper {
+method _build_tar_wrapper () {
     my $tar_wrapper = Tails::IUK::Archive::Tar::Wrapper->new(
         tar                  => $self->tar_exe->stringify,
         tar_gnu_read_options => [ qw{--no-same-permissions --no-same-owner} ],
-        tmpdir               => $self->tempdir,
+        tmpdir               => $self->tempdir->stringify,
         tmpdir_is_complete   => 1,
     );
     return $tar_wrapper;
 }
 
-method read_from ($file) {
+method read_from (AbsFile $file) {
     my $filename = $file->stringify;
     $self->tar_wrapper->read($filename) or confess("Error reading $filename");
     run_as_root(qw{chmod -R go+rX}, $self->tempdir);
 }
 
-method files {
+method files () {
     sort map { $_->[0] } @{$self->list_all()};
 }
 
-method get_content ($filename) {
-    scalar(file($self->locate($filename))->slurp);
+method get_content (Str $filename) {
+    scalar(path($self->locate($filename))->slurp);
 }
 
-method clean {
+method clean () {
     run_as_root(qw{rm --recursive --force --preserve-root}, $self->tempdir)
         if $self->has_tempdir;
 }
 
-method DEMOLISH {
+method DEMOLISH (@args) {
     $self->clean;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/Archive/Tar/Wrapper.pm b/usr/share/perl5/Tails/IUK/Archive/Tar/Wrapper.pm
index 27d525e..688271c 100644
--- a/usr/share/perl5/Tails/IUK/Archive/Tar/Wrapper.pm
+++ b/usr/share/perl5/Tails/IUK/Archive/Tar/Wrapper.pm
@@ -6,8 +6,7 @@ Tails::IUK::Archive::Tar::Wrapper - custom subclass of Archive::Tar::Wrapper for
 
 package Tails::IUK::Archive::Tar::Wrapper;
 
-use strict;
-use warnings;
+use strictures 2;
 
 use parent 'Archive::Tar::Wrapper';
 
@@ -35,6 +34,8 @@ sub new {
         dirs                  => 0,
         max_cmd_line_args     => 512,
         ramdisk               => undef,
+        _os_names             => { openbsd => 'openbsd', mswin => 'MSWin32' },
+        osname                => 'Linux',
         gzip_regex            => qr/\.t? # an optional t for matching tgz
                                     gz$ # ending with gz, which means compressed by gzip
                                     /ix,
diff --git a/usr/share/perl5/Tails/IUK/Frontend.pm b/usr/share/perl5/Tails/IUK/Frontend.pm
index 62a2ac4..6bb482f 100644
--- a/usr/share/perl5/Tails/IUK/Frontend.pm
+++ b/usr/share/perl5/Tails/IUK/Frontend.pm
@@ -6,79 +6,100 @@ Tails::IUK::Frontend - lead Tails user through the process of upgrading the syst
 
 package Tails::IUK::Frontend;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
-
-with 'Tails::Role::HasEncoding';
-with 'MooseX::Getopt::Dashes';
-
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Carp::Assert::More;
-use Data::Dumper;
 use English qw{-no_match_vars};
 use Env;
-use IPC::Run qw{run start};
+use Function::Parameters;
+use IPC::Run;
 use Number::Format qw(:subs);
-use Path::Class;
+use Path::Tiny;
 use String::Errf qw{errf};
 use Tails::RunningSystem;
 use Tails::IUK::UpgradeDescriptionFile;
-use Tails::IUK::Utils;
+use Tails::IUK::Utils qw{space_available_in};
 use Tails::MirrorPool;
 use Try::Tiny;
+use Types::Path::Tiny qw{AbsDir AbsFile};
+use Types::Standard qw(ArrayRef Bool CodeRef Defined HashRef InstanceOf Int Maybe Str);
 
 use Locale::gettext;
 use POSIX;
 setlocale(LC_MESSAGES, "");
 textdomain("tails-iuk");
 
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
-=head1 TYPES
+with 'Tails::Role::HasEncoding';
 
-=cut
+use namespace::clean;
 
-class_type 'Tails::RunningSystem';
+use MooX::Options;
 
 
 =head1 ATTRIBUTES
 
 =cut
 
-has "override_$_" => lazy_build ro Str
-    for (qw{baseurl build_target dev_dir os_release_file proc_dir run_dir},
-         qw{trusted_gnupg_homedir});
-
-has batch => lazy_build ro Bool;
-
-has 'override_liveos_mountpoint' => coerce lazy_build ro 'Path::Class::Dir';
-
-has 'override_started_from_device_installed_with_tails_installer' =>
-    lazy_build ro Str, documentation => q{Internal, for test suite only};
+option "override_$_" => (
+    is        => 'lazy',
+    isa       => Str,
+    format    => 's',
+    predicate => 1,
+) for (qw{baseurl build_target trusted_gnupg_homedir});
+
+option override_os_release_file =>
+    is        => 'lazy',
+    isa       => AbsFile,
+    coerce    => AbsFile->coercion,
+    format    => 's',
+    predicate => 1;
+
+option "override_$_" => (
+    isa        => AbsDir,
+    is         => 'ro',
+    lazy_build => 1,
+    coerce     => AbsDir->coercion,
+    format     => 's',
+    predicate  => 1,
+) for (qw{dev_dir liveos_mountpoint proc_dir run_dir});
+
+option batch =>
+    is  => 'lazy',
+    isa => Bool;
+
+option 'override_started_from_device_installed_with_tails_installer' =>
+    is            => 'lazy',
+    isa           => Str,
+    format        => 's',
+    predicate     => 1,
+    documentation => q{Internal, for test suite only};
 
 has 'running_system' =>
-    lazy_build ro 'Tails::RunningSystem',
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::RunningSystem'],
     handles => [
         qw{upgrade_description_file_url upgrade_description_sig_url},
         qw{product_name product_version build_target channel}
     ];
 
 has 'free_space' =>
-    lazy_build ro Int,
-    metaclass     => 'NoGetopt',
+    is            => 'lazy',
+    isa           => Int,
     documentation => q{Free space (in bytes) on the system partition};
 
-has 'override_free_space' =>
-    lazy_build ro Str,
+option 'override_free_space' =>
+    is            => 'lazy',
+    isa           => Int,
+    format        => 'i',
+    predicate     => 1,
     documentation => q{Internal, for test suite only};
 
 
@@ -86,9 +107,9 @@ has 'override_free_space' =>
 
 =cut
 
-method _build_batch { 0; }
+method _build_batch () { 0; }
 
-method _build_running_system {
+method _build_running_system () {
     my @args;
     for (qw{baseurl build_target dev_dir liveos_mountpoint os_release_file},
          qw{proc_dir run_dir}) {
@@ -107,10 +128,10 @@ method _build_running_system {
     Tails::RunningSystem->new(@args);
 }
 
-method _build_free_space {
+method _build_free_space () {
     $self->has_override_free_space
         ? $self->override_free_space
-        : space_available($self->running_system->liveos_mountpoint->stringify);
+        : space_available_in($self->running_system->liveos_mountpoint);
 }
 
 
@@ -127,7 +148,7 @@ method info (Str $msg) {
     say $self->encoding->encode($msg);
 }
 
-method fatal_run_cmd (Str :$error_msg!, ArrayRef :$cmd!, Str :$as?, Str :$error_title) {
+method fatal_run_cmd (Str :$error_msg, ArrayRef :$cmd, Maybe[Str] :$as = undef, Str :$error_title) {
     my @cmd       = @{$cmd};
 
     if (defined $as && ! $ENV{HARNESS_ACTIVE}) {
@@ -137,7 +158,7 @@ method fatal_run_cmd (Str :$error_msg!, ArrayRef :$cmd!, Str :$as?, Str :$error_
     my ($stdout, $stderr);
     my $success = 1;
     my $exit_code;
-    run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
+    IPC::Run::run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
     $exit_code = $?;
     $success or $self->fatal(
         errf("<b>%{error_msg}s</b>\n\n%{details}s",
@@ -160,9 +181,8 @@ method fatal_run_cmd (Str :$error_msg!, ArrayRef :$cmd!, Str :$as?, Str :$error_
     return ($stdout, $stderr, $success, $exit_code);
 }
 
-method dialog (Str $question,
-               Str :$type = 'question', Str :$ok_label, Str :$cancel_label,
-               Str :$title) {
+method dialog (Str $question, Str :$type = 'question', Str :$title,
+               Maybe[Str] :$ok_label = undef, Maybe[Str] :$cancel_label = undef) {
     if ($type ne 'question' && $type ne 'info') {
         assert_undefined($ok_label);
     }
@@ -190,11 +210,11 @@ method dialog (Str $question,
 }
 
 method upgrader_run_dir () {
-    dir($self->running_system->run_dir)->subdir('tails-upgrader');
+    $self->running_system->run_dir->child('tails-upgrader');
 }
 
 method checked_upgrades_file () {
-    $self->upgrader_run_dir->file('checked_upgrades');
+    $self->upgrader_run_dir->child('checked_upgrades');
 }
 
 method get_upgrade_description () {
@@ -203,13 +223,13 @@ method get_upgrade_description () {
         my $attribute = "override_$_";
         my $predicate = "has_$attribute";
         if ($self->$predicate) {
-            my $arg = "--$attribute"; $arg =~ s{_}{-}xmsg;
+            my $arg = "--$attribute";
             push @args, ($arg, $self->$attribute);
         }
     }
     if ($self->has_override_trusted_gnupg_homedir) {
         push @args, (
-            '--trusted-gnupg-homedir', $self->override_trusted_gnupg_homedir
+            '--trusted_gnupg_homedir', $self->override_trusted_gnupg_homedir
         );
     }
     my ($stdout, $stderr, $success, $exit_code) = $self->fatal_run_cmd(
@@ -416,17 +436,11 @@ method run () {
     }
 }
 
-sub target_files {
-    my $upgrade_path = shift;
-    my $destdir     = shift;
-
-    assert_defined($upgrade_path);
-    assert_defined($destdir);
-
+fun target_files (HashRef $upgrade_path, AbsDir $destdir) {
     my @target_files;
     foreach my $target_file (@{$upgrade_path->{'target-files'}}) {
-        my $basename    = file($target_file->{url})->basename;
-        my $output_file = file($destdir, $basename);
+        my $basename    = path($target_file->{url})->basename;
+        my $output_file = path($destdir, $basename);
         push @target_files,
             {
                 %{$target_file},
@@ -444,9 +458,7 @@ the incremental upgrade described in the upgrade path passed
 as argument.
 
 =cut
-sub memory_needed {
-    my $upgrade_path = shift;
-    assert_defined($upgrade_path);
+fun memory_needed (HashRef $upgrade_path) {
     my $mem_factor = 2;
     $mem_factor * $upgrade_path->{'total-size'};
 }
@@ -458,22 +470,20 @@ partition to download and install the incremental upgrade described in
 the upgrade path passed as argument.
 
 =cut
-sub space_needed {
-    my $upgrade_path = shift;
-    assert_defined($upgrade_path);
+fun space_needed (HashRef $upgrade_path) {
     my $space_factor = 3.0;
     $space_factor * $upgrade_path->{'total-size'};
 }
 
-method get_target_files ($upgrade_path, $url_transform, $destdir) {
+method get_target_files (HashRef $upgrade_path, CodeRef $url_transform, AbsDir $destdir) {
     my $title = $self->encoding->decode(gettext("Downloading upgrade"));
     my $info = $self->encoding->decode(errf(
         gettext(
             "Downloading the upgrade to %{name}s %{version}s..."
         ),
         {
-            name        => $self->product_name,
-            version     => $upgrade_path->{version},
+            name    => $self->product_name,
+            version => $upgrade_path->{version},
         }
     ));
     $self->info($info);
@@ -482,10 +492,10 @@ method get_target_files ($upgrade_path, $url_transform, $destdir) {
         my @cmd = (
             'tails-iuk-get-target-file',
             '--uri',         $url_transform->($target_file->{url}),
-            '--hash-type',   'sha256',
-            '--hash-value',  $target_file->{sha256},
+            '--hash_type',   'sha256',
+            '--hash_value',  $target_file->{sha256},
             '--size',        $target_file->{size},
-            '--output-file', $target_file->{output_file},
+            '--output_file', $target_file->{output_file},
         );
         if (! $ENV{HARNESS_ACTIVE}) {
             @cmd = ('sudo', '-n', '-u', 'tails-iuk-get-target-file', @cmd);
@@ -494,11 +504,11 @@ method get_target_files ($upgrade_path, $url_transform, $destdir) {
         my $success = 1;
 
         if ($self->batch) {
-            run \@cmd, '2>', \$stderr or $success = 0;
+            IPC::Run::run \@cmd, '2>', \$stderr or $success = 0;
             $exit_code = $?;
         }
         else {
-            run \@cmd, '2>', \$stderr,
+            IPC::Run::run \@cmd, '2>', \$stderr,
                 '|', [qw{zenity --progress --percentage=0 --auto-close
                          --no-cancel}, '--title', $title, '--text', $info]
                 or $success = 0;
@@ -551,7 +561,7 @@ method get_target_files ($upgrade_path, $url_transform, $destdir) {
     }
 }
 
-method do_incremental_upgrade ($upgrade_path) {
+method do_incremental_upgrade (HashRef $upgrade_path) {
     my ($stdout, $stderr, $success, $exit_code);
 
     my ($target_files_tempdir) = $self->fatal_run_cmd(
@@ -598,7 +608,7 @@ method do_incremental_upgrade ($upgrade_path) {
     };
 
     $self->get_target_files(
-        $upgrade_path, $url_transform, $target_files_tempdir
+        $upgrade_path, $url_transform, path($target_files_tempdir)
     );
 
     $self->dialog(
@@ -614,7 +624,7 @@ method do_incremental_upgrade ($upgrade_path) {
         ok_label => $self->encoding->decode(gettext(q{Apply upgrade})),
     );
 
-    $self->install_iuk($upgrade_path, $target_files_tempdir);
+    $self->install_iuk($upgrade_path, path($target_files_tempdir));
 
     $self->dialog(
         $self->encoding->decode(gettext(
@@ -631,7 +641,7 @@ method do_incremental_upgrade ($upgrade_path) {
     exit(0);
 }
 
-method restart_system {
+method restart_system () {
     $self->info("Restarting the system");
     $self->fatal_run_cmd(
         cmd       => ['/sbin/reboot'],
@@ -645,11 +655,11 @@ method restart_system {
     ) unless $ENV{HARNESS_ACTIVE};
 }
 
-method do_full_upgrade ($upgrade_path) {
+method do_full_upgrade (HashRef $upgrade_path) {
     exit(0);
 }
 
-method shutdown_network {
+method shutdown_network () {
     $self->info("Shutting down network connection");
     $self->fatal_run_cmd(
         cmd       => ['tails-shutdown-network'],
@@ -663,10 +673,7 @@ method shutdown_network {
     ) unless $ENV{HARNESS_ACTIVE};
 }
 
-method install_iuk ($upgrade_path, $target_files_tempdir) {
-    assert_defined($upgrade_path);
-    assert_defined($target_files_tempdir);
-
+method install_iuk (HashRef $upgrade_path, AbsDir $target_files_tempdir) {
     my $title = $self->encoding->decode(gettext("Upgrading the system"));
     my $info = $self->encoding->decode(gettext(
         "<b>Your Tails device is being upgraded...</b>\n\n".
@@ -681,7 +688,7 @@ method install_iuk ($upgrade_path, $target_files_tempdir) {
 
     my @args;
     push @args, (
-        '--override-liveos-mountpoint', $self->override_liveos_mountpoint
+        '--override_liveos_mountpoint', $self->override_liveos_mountpoint
     ) if $self->has_override_liveos_mountpoint;
 
     my @cmd = ('tails-install-iuk', @args, $target_files[0]->{output_file});
@@ -692,9 +699,9 @@ method install_iuk ($upgrade_path, $target_files_tempdir) {
     my ($exit_code, $stdout, $stderr, $zenity_h);
     my $success = 1;
 
-    $zenity_h = start [qw{zenity --progress --pulsate --no-cancel},
+    $zenity_h = IPC::Run::start [qw{zenity --progress --pulsate --no-cancel},
                        '--title', $title, '--text', $info] unless $self->batch;
-    run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
+    IPC::Run::run \@cmd, '>', \$stdout, '2>', \$stderr or $success = 0;
     $exit_code = $?;
     $zenity_h->kill_kill unless $self->batch;
 
@@ -723,5 +730,5 @@ method install_iuk ($upgrade_path, $target_files_tempdir) {
     );
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/Install.pm b/usr/share/perl5/Tails/IUK/Install.pm
index 4976530..050bd3b 100644
--- a/usr/share/perl5/Tails/IUK/Install.pm
+++ b/usr/share/perl5/Tails/IUK/Install.pm
@@ -6,20 +6,12 @@ Tails::IUK::Install - install an Incremental Upgrade Kit
 
 package Tails::IUK::Install;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
-
-
-with 'MooseX::Getopt::Dashes';
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -27,21 +19,19 @@ use Carp::Assert::More;
 use Cwd;
 use Data::Dumper;
 use File::Copy;
-use Path::Class;
 use File::Temp qw{tempdir tempfile};
+use Function::Parameters;
+use Path::Tiny;
 use Try::Tiny;
-
 use Tails::IUK::Read;
-use Tails::IUK::Utils qw{run_as_root space_available};
+use Tails::IUK::Utils qw{run_as_root space_available_in};
 use Tails::RunningSystem;
+use Types::Path::Tiny qw{AbsDir AbsFile AbsPath};
+use Types::Standard qw{ArrayRef InstanceOf Str};
 
+use namespace::clean;
 
-=head1 TYPES
-
-=cut
-
-class_type('Tails::IUK::Read');
-class_type('Tails::RunningSystem');
+use MooX::Options;
 
 
 =head1 ATTRIBUTES
@@ -49,27 +39,60 @@ class_type('Tails::RunningSystem');
 =cut
 
 has 'reader' =>
-    lazy_build ro 'Tails::IUK::Read',
-    handles => [ qw{list_archives file delete_files delete_files_count locate space_needed squashfs_in_archive} ];
-
-has 'override_liveos_mountpoint'     => coerce lazy_build ro 'Path::Class::Dir';
-has 'override_system_partition_file' => lazy_build ro 'Str';
-has 'override_boot_device_file'      => lazy_build ro 'Str';
-
-has 'tempdir'       => lazy_build ro 'Path::Class::Dir', predicate 'has_tempdir';
-has 'modules_file'  => lazy_build ro 'Path::Class::File';
-has 'from_file'     => required ro 'Str';
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::IUK::Read'],
+    handles => [
+        qw{list_archives file delete_files delete_files_count locate},
+        qw{space_needed squashfs_in_archive} ];
+
+option 'override_liveos_mountpoint' =>
+    is        => 'lazy',
+    isa       => AbsDir,
+    coerce    => AbsDir->coercion,
+    format    => 's',
+    predicate => 1;
+
+option 'override_system_partition_file' =>
+    is        => 'lazy',
+    isa       => AbsPath,
+    coerce    => AbsPath->coercion,
+    format    => 's',
+    predicate => 1;
+
+option 'override_boot_device_file' =>
+    is        => 'lazy',
+    isa       => AbsPath,
+    coerce    => AbsPath->coercion,
+    format    => 's',
+    predicate => 1;
+
+has 'tempdir' =>
+    is        => 'lazy',
+    isa       => AbsDir,
+    predicate => 1;
+
+has 'modules_file' =>
+    is  => 'lazy',
+    isa => AbsFile;
+
+has 'from_file' =>
+    required => 1,
+    is       => 'ro',
+    isa      => AbsFile,
+    coerce   => AbsFile->coercion;
 
 has 'installed_squashfs' =>
-    lazy_build ro 'ArrayRef[Str]',
-    traits => [ 'Array' ],
-    handles => {
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         record_installed_squashfs => 'push',
         all_installed_squashfs    => 'elements',
     };
 
 has 'running_system' =>
-    lazy_build ro 'Tails::RunningSystem',
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::RunningSystem'],
     handles => [ qw{boot_device_file system_partition_file liveos_mountpoint} ];
 
 
@@ -77,7 +100,7 @@ has 'running_system' =>
 
 =cut
 
-method _build_tempdir {
+method _build_tempdir () {
     $self->remount_liveos_rw;
 
     my $base_live_tmp_dir = $self->liveos_mountpoint->child('tmp')->stringify;
@@ -93,28 +116,28 @@ method _build_tempdir {
     # This is useless in Tails, but useful for testing.
     run_as_root(qw{chmod -R go+rX}, $base_live_tmp_dir);
 
-    dir($tempdir);
+    path($tempdir);
 }
 
-method _build_installed_squashfs { [] }
+method _build_installed_squashfs () { [] }
 
-method _build_modules_file {
-    file($self->liveos_mountpoint, 'live', 'Tails.module');
+method _build_modules_file () {
+    path($self->liveos_mountpoint, 'live', 'Tails.module');
 }
 
-method _build_reader {
+method _build_reader () {
     Tails::IUK::Read->new_from_file(
         $self->from_file,
         tempdir => $self->tempdir,
     );
 }
 
-method clean {
+method clean () {
     run_as_root(qw{rm --recursive --force --preserve-root}, $self->tempdir)
         if $self->has_tempdir;
 }
 
-method _build_running_system {
+method _build_running_system () {
     my @args;
     for (qw{boot_device_file system_partition_file liveos_mountpoint}) {
         my $attribute = "override_$_";
@@ -126,7 +149,7 @@ method _build_running_system {
     Tails::RunningSystem->new(@args);
 }
 
-method DEMOLISH {
+method DEMOLISH (@args) {
     $self->clean;
 }
 
@@ -143,14 +166,14 @@ method fatal (@msg) {
     );
 }
 
-method space_available {
-    space_available($self->liveos_mountpoint->stringify);
+method space_available () {
+    space_available_in($self->liveos_mountpoint);
 }
 
-method upgrade_modules_file {
+method upgrade_modules_file () {
     my @installed_squashfs = $self->all_installed_squashfs;
 
-    my $append_str = join("\n", map { file($_)->basename } @installed_squashfs);
+    my $append_str = join("\n", map { path($_)->basename } @installed_squashfs);
     if (length($append_str)) {
         my ($temp_fh, $temp_file) = tempfile;
         copy($self->modules_file->stringify, $temp_fh)
@@ -160,7 +183,7 @@ method upgrade_modules_file {
             ));
         close $temp_fh;
 
-        $temp_fh = file($temp_file)->open('a');
+        $temp_fh = path($temp_file)->opena;
         say $temp_fh $append_str;
         close $temp_fh;
         system('sync');
@@ -169,15 +192,15 @@ method upgrade_modules_file {
     }
 }
 
-method remount_liveos_rw {
+method remount_liveos_rw () {
     run_as_root(qw{mount -o}, "remount,rw", $self->liveos_mountpoint);
 }
 
-method remount_liveos_sync {
+method remount_liveos_sync () {
     run_as_root(qw{mount -o}, "remount,sync", $self->liveos_mountpoint);
 }
 
-method run {
+method run () {
     unless ($self->space_available > $self->space_needed) {
         $self->fatal(
             "There is too little available space on Tails system partition, aborting"
@@ -196,7 +219,7 @@ method run {
                     '-f', $self->locate($archive_filename));
 
         $self->record_installed_squashfs($self->squashfs_in_archive(
-            $self->locate($archive_filename)
+            path($self->locate($archive_filename))
         ));
     }
     chdir $orig_cwd;
@@ -204,7 +227,7 @@ method run {
     if ($self->delete_files_count) {
         run_as_root(
             'rm', '--recursive', '--force',
-            map { file($self->liveos_mountpoint, $_) } @{$self->delete_files}
+            map { path($self->liveos_mountpoint, $_) } @{$self->delete_files}
         );
     }
 
@@ -213,14 +236,14 @@ method run {
     $self->upgrade_modules_file;
 
     # upgrade syslinux' ldlinux.sys
-    my $syslinux = file($self->liveos_mountpoint, qw{utils linux syslinux});
+    my $syslinux = path($self->liveos_mountpoint, qw{utils linux syslinux});
     run_as_root($syslinux, qw{-d syslinux}, $self->system_partition_file)
         if -e $syslinux;
 
     # upgrade the MBR
-    my $mbr = file($self->liveos_mountpoint, qw{utils mbr mbr.bin});
+    my $mbr = path($self->liveos_mountpoint, qw{utils mbr mbr.bin});
     run_as_root(
-        'dd', "if=$mbr", 'of='.$self->boot_device_file, 'bs=1', 'count=440',
+        'dd', 'status=none', "if=$mbr", 'of='.$self->boot_device_file, 'bs=1', 'count=440',
     ) if -e $mbr;
 
     system('sync');
@@ -228,5 +251,5 @@ method run {
     $self->clean;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm b/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm
index d6e598a..4da3ddd 100644
--- a/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm
+++ b/usr/share/perl5/Tails/IUK/LWP/UserAgent/WithProgress.pm
@@ -7,8 +7,7 @@ Tails::IUK::LWP::UserAgent::WithProgress - LWP::UserAgent subclass that displays
 package Tails::IUK::LWP::UserAgent::WithProgress;
 
 use 5.10.1;
-use strict;
-use warnings;
+use strictures 2;
 use autodie qw(:all);
 
 use parent 'LWP::UserAgent';
diff --git a/usr/share/perl5/Tails/IUK/Read.pm b/usr/share/perl5/Tails/IUK/Read.pm
index e52e0a8..2aee127 100644
--- a/usr/share/perl5/Tails/IUK/Read.pm
+++ b/usr/share/perl5/Tails/IUK/Read.pm
@@ -6,38 +6,30 @@ Tails::IUK::Read - read Incremental Upgrade Kit files
 
 package Tails::IUK::Read;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
-
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Cwd;
 use Data::Dumper;
-use File::Temp qw{tempdir tempfile};
+use File::Temp;
+use Function::Parameters;
 use List::Util qw{sum};
-use Path::Class;
+use Path::Tiny;
 use Try::Tiny;
 use YAML::Any;
-
 use Tails::IUK::Archive::Tar;
 use Tails::IUK::Utils qw{run_as_root unpacked_size};
+use Types::Path::Tiny qw{AbsDir AbsFile};
+use Types::Standard qw{ArrayRef ClassName HashRef InstanceOf Str};
 
-=head1 TYPES
-
-=cut
-
-class_type('Tails::IUK::Archive::Tar');
+use namespace::clean;
 
 
 =head1 ATTRIBUTES
@@ -45,36 +37,52 @@ class_type('Tails::IUK::Archive::Tar');
 =cut
 
 has 'file' => (
-    isa => 'Path::Class::File',
+    isa      => AbsFile,
     required => 1,
-    is => 'ro',
+    is       => 'ro',
 );
 
-has 'format_version' => lazy_build ro Str;
-has 'control'        => lazy_build ro 'HashRef';
-has 'delete_files'   => lazy_build ro 'ArrayRef[Str]',
-    traits => [ 'Array' ],
-    handles => {
+has 'format_version' =>
+    is  => 'lazy',
+    isa => Str;
+
+has 'control' =>
+    is  => 'lazy',
+    isa => HashRef;
+
+has 'delete_files'   =>
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         delete_files_count => "count",
     };
 
 has 'archive' => (
-    isa => 'Tails::IUK::Archive::Tar',
-    is => 'ro',
-    lazy_build => 1,
+    isa     => InstanceOf['Tails::IUK::Archive::Tar'],
+    is      => 'lazy',
     handles => [ qw{get_content locate} ],
 );
 
-has 'files' => lazy_build ro 'ArrayRef[Str]';
-has 'archives' => lazy_build ro 'ArrayRef[Path::Class::File]';
-has 'tempdir'  => lazy_build ro 'Path::Class::Dir', predicate 'has_tempdir';
+has 'files' =>
+    is  => 'lazy',
+    isa => ArrayRef;
+
+has 'archives' =>
+    is  => 'lazy',
+    isa => ArrayRef;
+
+has 'tempdir' =>
+    is        => 'lazy',
+    isa       => AbsDir,
+    predicate => 1;
 
 
 =head1 METHODS
 
 =cut
 
-method _build_format_version {
+method _build_format_version () {
     my $format_version;
     try {
         $format_version = $self->get_content('FORMAT');
@@ -84,7 +92,7 @@ method _build_format_version {
     return $format_version;
 }
 
-method _build_archive {
+method _build_archive () {
     Tails::IUK::Archive::Tar->new(
         filename => $self->file->stringify,
         sudo     => 1,
@@ -92,22 +100,22 @@ method _build_archive {
     );
 }
 
-method _build_delete_files {
+method _build_delete_files () {
     my $delete_files = $self->control->{delete_files};
     $delete_files ||= [];
     return $delete_files;
 }
 
-method _build_control {
+method _build_control () {
     my $control = YAML::Any::Load($self->get_content('control.yml'));
     $control = {} unless defined $control;
     return $control;
 }
 
-method _build_files { [ $self->archive->files ] }
+method _build_files () { [ $self->archive->files ] }
 
-method _build_archives {
-    return [ map { file($_) } grep {
+method _build_archives () {
+    return [ map { path($_) } grep {
         $_ =~ m{
                    [.] tar       # literal .tar
                    (?: [.] bz2 )? # possibly followed by literal .bz2
@@ -116,9 +124,9 @@ method _build_archives {
     } $self->list_files ];
 }
 
-method _build_tempdir { dir(tempdir(CLEANUP => 0)) };
+method _build_tempdir () { path(File::Temp::tempdir(CLEANUP => 0)) };
 
-method BUILD {
+method BUILD (@args) {
     my $format_version;
     try {
         $format_version = $self->format_version();
@@ -129,38 +137,35 @@ method BUILD {
         or croak(sprintf("Unsupported format: %s", $format_version));
 }
 
-sub new_from_file {
-    my $class = shift;
-    my $filename = shift;
-
+fun new_from_file (ClassName $class, AbsFile $filename, @rest) {
     return $class->new(
-        file => file($filename),
-        @_,
+        file => path($filename),
+        @rest,
     );
 }
 
-method clean {
+method clean () {
     run_as_root(qw{rm --recursive --force --preserve-root}, $self->tempdir)
         if $self->has_tempdir;
 }
 
-method DEMOLISH {
+method DEMOLISH (@args) {
     $self->clean;
 }
 
-method list_files { @{$self->files} }
+method list_files () { @{$self->files} }
 
-method space_needed {
-    sum(0, map { unpacked_size($self->locate($_)) } $self->list_archives);
+method space_needed () {
+    sum(0, map { unpacked_size(path($self->locate($_))) } $self->list_archives);
 }
 
-method contains_file ($filename) {
+method contains_file (Str $filename) {
     1 == grep { $_ eq $filename } $self->list_files;
 }
 
-method squashfs_in_archive ($archive_filename) {
-    my $tempdir = $self->tempdir->subdir(
-        file($archive_filename)->basename . "_tempdir"
+method squashfs_in_archive (AbsFile $archive_filename) {
+    my $tempdir = $self->tempdir->child(
+        path($archive_filename)->basename . "_tempdir"
     );
     run_as_root('mkdir', '--parents', '--mode=0755', $tempdir);
     -d $tempdir or croak "Could not make '$tempdir' directory: $!";
@@ -176,5 +181,5 @@ method squashfs_in_archive ($archive_filename) {
 
 method list_archives () { @{$self->archives} }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/TargetFile/Download.pm b/usr/share/perl5/Tails/IUK/TargetFile/Download.pm
index c0068aa..cb00438 100644
--- a/usr/share/perl5/Tails/IUK/TargetFile/Download.pm
+++ b/usr/share/perl5/Tails/IUK/TargetFile/Download.pm
@@ -6,56 +6,64 @@ Tails::IUK::TargetFile::Download - download and verify a target file
 
 package Tails::IUK::TargetFile::Download;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{enum};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
 
-
-
-with 'MooseX::Getopt::Dashes';
-
-use 5.10.0;
-use namespace::autoclean;
-use warnings;
+use 5.10.1;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Cwd;
-use Data::Dumper;
 use Digest::SHA;
 use File::Temp qw{tempfile};
+use Function::Parameters;
 use HTTP::Request;
-use Path::Class;
+use Path::Tiny;
 use String::Errf qw{errf};
 use Tails::IUK::LWP::UserAgent::WithProgress;
-use Tails::IUK::Utils qw{space_available};
-
-
-=head1 TYPES
+use Tails::IUK::Utils qw{space_available_in};
+use Types::Path::Tiny qw{AbsPath};
+use Types::Standard qw{Enum Int Str};
 
-=cut
+use namespace::clean;
 
-enum 'Tails::IUK::TargetFile::HashType', ['sha256'];
+use MooX::Options;
 
 
 =head1 ATTRIBUTES
 
 =cut
 
-has 'uri'         => required ro Str;
-has 'hash_type'   => required ro 'Tails::IUK::TargetFile::HashType';
-has 'hash_value'  => required ro Str;
-has 'output_file' => coerce required ro 'Path::Class::File';
-has 'size'        => required ro Int;
-
-
-=head1 CONSTRUCTORS AND BUILDERS
-
-=cut
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => Str,
+    format   => 's',
+) for (qw{uri hash_value});
+
+option 'hash_type' => (
+    required => 1,
+    is       => 'ro',
+    isa      => Enum[qw{sha256}],
+    format   => 's',
+);
+
+option 'output_file' => (
+    required => 1,
+    is       => 'ro',
+    isa      => AbsPath,
+    coerce   => AbsPath->coercion,
+    format   => 's',
+);
+
+option 'size' => (
+    required => 1,
+    is       => 'ro',
+    isa      => Int,
+    format   => 's',
+);
 
 
 =head1 METHODS
@@ -67,9 +75,9 @@ method fatal (@msg) {
 }
 
 method check_available_space () {
-    my $target_dir      = $self->output_file->parent->stringify;
+    my $target_dir      = $self->output_file->parent;
     my $space_needed    = $self->size;
-    my $space_available = space_available($target_dir);
+    my $space_available = space_available_in($target_dir);
     $space_available >= $space_needed or $self->fatal(errf(
         "Downloading this incremental upgrade requires %{space_needed}s ".
         "of free space in %{target_dir}s, but only %{space_available}s is available.",
@@ -147,5 +155,5 @@ method run () {
     return 1;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm
index 0139fc1..040f478 100644
--- a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm
+++ b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile.pm
@@ -6,15 +6,12 @@ Tails::IUK::UpgradeDescriptionFile - describe and manipulate a Tails upgrade-des
 
 package Tails::IUK::UpgradeDescriptionFile;
 
-use Moose;
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class;
-use MooseX::Has::Sugar::Saccharin;
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -23,33 +20,44 @@ use Carp::Assert::More;
 use Data::Dumper;
 use Dpkg::Version qw{version_compare};
 use English qw{-no_match_vars};
+use Function::Parameters;
 use List::MoreUtils qw{any};
 use List::Util qw{sum};
-use Path::Class;
+use Path::Tiny;
+use Types::Standard qw{ArrayRef Str};
 use YAML::Any;
 
+use namespace::clean;
+
 
 =head1 ATTRIBUTES
 
 =cut
 
-has "$_"    => required ro Str, predicate => "has_$_"
-    for (qw{product_name product_version build_target channel});
+has "$_" => (
+    required  => 1,
+    is        => 'ro',
+    isa       => Str,
+    predicate => 1,
+) for (qw{product_name product_version build_target channel});
 
 has upgrades =>
-    lazy_build ro ArrayRef,
-    traits => [ 'Array' ],
-    handles => {
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         count_upgrades => 'count',
         all_upgrades   => 'elements',
         add_upgrade    => 'push',
         empty_upgrades => 'clear',
-    };
+    },
+    predicate   => 1;
 
 has upgrade_paths =>
-    lazy_build ro ArrayRef,
-    traits => [ 'Array' ],
-    handles => {
+    is          => 'lazy',
+    isa         => ArrayRef,
+    handles_via => 'Array',
+    handles     => {
         count_upgrade_paths => 'count',
         all_upgrade_paths   => 'elements',
     };
@@ -59,9 +67,9 @@ has upgrade_paths =>
 
 =cut
 
-method _build_upgrades { return [] }
+method _build_upgrades () { return [] }
 
-method _build_upgrade_paths {
+method _build_upgrade_paths () {
     my @upgrade_paths;
     foreach my $upgrade ($self->all_upgrades) {
         exists $upgrade->{'upgrade-paths'} or $upgrade->{'upgrade-paths'} = [];
@@ -100,7 +108,7 @@ sub new_from_file {
     my $class    = shift;
     my $filename = shift;
 
-    my $content = file($filename)->slurp;
+    my $content = path($filename)->slurp;
     assert_nonblank($content);
 
     $class->new_from_text($content);
@@ -157,8 +165,7 @@ method stringify () {
 
 =cut
 
-sub path_to_newest_version {
-    my @paths = @_;
+fun path_to_newest_version (@paths) {
     assert(@paths);
 
     my $current_best_path = { version => '0' };
@@ -171,5 +178,5 @@ sub path_to_newest_version {
     return $current_best_path;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm
index 2459f6a..8ad2d2e 100644
--- a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm
+++ b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Download.pm
@@ -6,17 +6,12 @@ Tails::IUK::UpgradeDescriptionFile::Download - download and verify an upgrade de
 
 package Tails::IUK::UpgradeDescriptionFile::Download;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Has::Sugar::Saccharin;
-
-with 'MooseX::Getopt::Dashes';
+no Moo::sification;
+use Moo;
+use MooX::HandlesVia;
 
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 extends 'Tails::Download::HTTPS';
 
@@ -24,45 +19,58 @@ use autodie qw(:all);
 use Carp;
 use Carp::Assert;
 use Carp::Assert::More;
-use English qw{-no_match_vars};
+use Function::Parameters;
+use Path::Tiny;
 use Tails::RunningSystem;
 use Tails::IUK::Utils;
+use Types::Standard qw{InstanceOf Str};
+use Types::Path::Tiny qw{AbsDir};
 use YAML::Any;
 
+use namespace::clean;
 
-=head1 TYPES
-
-=cut
-
-class_type 'Tails::RunningSystem';
-
+use MooX::Options;
 
 =head1 ATTRIBUTES
 
 =cut
 
-has "$_" => lazy_build ro Str
-    for (qw{override_baseurl override_build_target override_os_release_file
-            trusted_gnupg_homedir});
-has 'running_system' =>
-    lazy_build ro 'Tails::RunningSystem',
+option "$_" => (
+    is         => 'ro',
+    format     => 's',
+    isa        => Str,
+    predicate  => 1,
+) for (qw{override_baseurl override_build_target override_os_release_file});
+
+option trusted_gnupg_homedir => (
+    is         => 'lazy',
+    format     => 's',
+    isa        => AbsDir,
+    coerce     => AbsDir->coercion,
+    predicate  => 1,
+);
+
+has 'running_system' => (
+    is      => 'lazy',
+    isa     => InstanceOf['Tails::RunningSystem'],
     handles => [
         qw{upgrade_description_file_url upgrade_description_sig_url},
         qw{product_name product_version build_target channel}
-    ];
+    ],
+);
 
 
 =head1 CONSTRUCTORS AND BUILDERS
 
 =cut
 
-method _build_trusted_gnupg_homedir     {
-    my $trusted_gnupg_homedir = '/usr/share/tails-iuk/trusted_gnupg_homedir';
+method _build_trusted_gnupg_homedir () {
+    my $trusted_gnupg_homedir = path('/usr/share/tails-iuk/trusted_gnupg_homedir');
     assert(-d $trusted_gnupg_homedir);
     return $trusted_gnupg_homedir;
 }
 
-method _build_running_system {
+method _build_running_system () {
     my @args;
     for (qw{baseurl build_target os_release_file}) {
         my $attribute = "override_$_";
@@ -79,8 +87,7 @@ method _build_running_system {
 
 =cut
 
-method matches_running_system ($description_str) {
-    assert(defined $description_str);
+method matches_running_system (Str $description_str) {
     my $description = YAML::Any::Load($description_str);
     assert_hashref($description);
     foreach (qw{product_name product_version build_target channel}) {
@@ -105,5 +112,5 @@ method run () {
     return;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm
index d4be264..f6b814e 100644
--- a/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm
+++ b/usr/share/perl5/Tails/IUK/UpgradeDescriptionFile/Generate.pm
@@ -6,18 +6,11 @@ Tails::IUK::UpgradeDescriptionFile::Generate - create and update upgrade-descrip
 
 package Tails::IUK::UpgradeDescriptionFile::Generate;
 
-use Moose;
-use Moose::Util::TypeConstraints qw{class_type};
-use MooseX::Method::Signatures;
-use MooseX::Types::Moose qw( :all );
-use MooseX::Types::Path::Class qw{Dir File};
-use MooseX::Has::Sugar::Saccharin;
-
-with 'MooseX::Getopt::Dashes';
+no Moo::sification;
+use Moo;
 
 use 5.10.1;
-use namespace::autoclean;
-use warnings;
+use strictures 2;
 
 use autodie qw(:all);
 use Carp;
@@ -25,37 +18,73 @@ use Carp::Assert;
 use Carp::Assert::More;
 use Digest::SHA;
 use English qw{-no_match_vars};
-use Path::Class;
+use Function::Parameters;
+use Path::Tiny;
 use Tails::IUK::UpgradeDescriptionFile;
+use Types::Path::Tiny qw{AbsDir AbsFile};
+use Types::Standard qw{ArrayRef Bool Str};
 
+use namespace::clean;
 
-=head1 ATTRIBUTES
+use MooX::Options;
 
-=cut
 
-has previous_versions => required ro ArrayRef;
-has version           => required ro Str;
-has next_versions     => required ro ArrayRef;
-has major_release     => required ro Bool;
+=head1 ATTRIBUTES
 
-has iso               => required coerce ro File;
-has iuks              => required coerce ro Dir;
-has release_checkout  => required coerce ro Dir;
+=cut
 
-has build_target      => lazy_build ro Str;
-has channel           => lazy_build ro Str;
-has product_name      => lazy_build ro Str;
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => ArrayRef,
+    format   => 's@',
+) for (qw{previous_versions next_versions});
+
+option version => (
+    required => 1,
+    is       => 'ro',
+    isa      => Str,
+    format   => 's',
+);
+
+option major_release => (
+    required => 1,
+    is       => 'ro',
+    isa      => Bool,
+);
+
+option iso => (
+    required => 1,
+    is       => 'ro',
+    isa      => AbsFile,
+    coerce   => AbsFile->coercion,
+    format   => 's',
+);
+
+option "$_" => (
+    required => 1,
+    is       => 'ro',
+    isa      => AbsDir,
+    coerce   => AbsDir->coercion,
+    format   => 's',
+) for (qw{iuks release_checkout});
+
+option "$_" => (
+    is     => 'lazy',
+    isa    => Str,
+    format => 's',
+) for (qw{build_target channel product_name});
 
 
 =head1 CONSTRUCTORS AND BUILDERS
 
 =cut
 
-method _build_build_target  { 'amd64'   }
-method _build_channel       { 'stable' }
-method _build_product_name  { 'Tails'  }
+method _build_build_target () { 'amd64'   }
+method _build_channel      () { 'stable' }
+method _build_product_name () { 'Tails'  }
 
-method BUILD {
+method BUILD (@args) {
     assert(-f $self->iso);
     assert(-d $self->release_checkout);
 }
@@ -65,7 +94,7 @@ method BUILD {
 
 =cut
 
-method run {
+method run () {
     for my $channel (qw{alpha stable}) {
         say STDERR q{* Creating upgrade-description files for new release },
             '(', $self->version, "), ", $channel, " channel: \n  ",
@@ -182,9 +211,8 @@ method upgrade_paths_from_previous_release ($previous_version) {
     return @paths;
 }
 
-method udf_for ($version, :$channel?) {
-    defined($channel) or $channel = $self->channel;
-    file(
+method udf_for ($version, :$channel = $self->channel) {
+    path(
         $self->release_checkout, qw{wiki src upgrade v1}, $self->product_name,
         $version, $self->build_target, $channel, 'upgrades.yml'
     );
@@ -194,7 +222,7 @@ method udf_for_new_release ($channel) {
     $self->udf_for($self->version, channel => $channel)
 }
 
-method iso_url {
+method iso_url () {
     'http://dl.amnesia.boum.org/tails/'
         . $self->channel
         . '/'
@@ -231,14 +259,14 @@ method iuk_url ($previous_version) {
 }
 
 method iuk_for ($previous_version) {
-    file($self->iuks, $self->iuk_filename($previous_version));
+    path($self->iuks, $self->iuk_filename($previous_version));
 }
 
 method has_iuk_for ($previous_version) {
     -f $self->iuk_for($previous_version);
 }
 
-method details_url {
+method details_url () {
     my $version = version_for_website($self->version);
     if ($self->channel eq 'stable') {
         return 'https://tails.boum.org/news/version_'.$version.'/';
@@ -257,8 +285,7 @@ method details_url {
 
 =cut
 
-sub sha256_file {
-    my $file = shift;
+fun sha256_file ($file) {
     assert(-f $file);
 
     my $sha = Digest::SHA->new(256);
@@ -266,8 +293,7 @@ sub sha256_file {
     return $sha->hexdigest;
 }
 
-sub version_for_website {
-    my $version = shift;
+fun version_for_website ($version) {
     assert_defined($version);
     assert(length($version));
 
@@ -276,5 +302,5 @@ sub version_for_website {
     return $version;
 }
 
-no Moose;
+no Moo;
 1;
diff --git a/usr/share/perl5/Tails/IUK/Utils.pm b/usr/share/perl5/Tails/IUK/Utils.pm
index 1b3d030..5116081 100644
--- a/usr/share/perl5/Tails/IUK/Utils.pm
+++ b/usr/share/perl5/Tails/IUK/Utils.pm
@@ -6,8 +6,7 @@ Tails::IUK::Utils - utilities for Tails IUK
 
 package Tails::IUK::Utils;
 
-use strict;
-use warnings;
+use strictures 2;
 use 5.10.1;
 
 
@@ -17,7 +16,7 @@ our @ISA = qw{Exporter};
 our @EXPORT = (
     qw{extract_file_from_iso extract_here_file_from_iso fatal},
     qw{get_temp_dir make_archive_with_files_called make_iuk_with_files},
-    qw{run_as_root space_available stdout_as_root unpacked_size},
+    qw{run_as_root space_available_in stdout_as_root unpacked_size},
     qw{verify_signature}
 );
 
@@ -32,17 +31,18 @@ use English qw{-no_match_vars};
 use File::Temp qw{tempdir tempfile};
 use GnuPG::Interface;
 use Filesys::Df;
+use Function::Parameters;
 use IPC::System::Simple qw{capturex};
 use List::Util qw{sum};
-use Method::Signatures::Simple;
-use Path::Class;
+use Path::Tiny;
+use Types::Path::Tiny qw{AbsDir AbsFile AbsPath Path};
 
 
 =head1 FUNCTIONS
 
 =cut
 
-func extract_file_from_iso($file, $iso) {
+fun extract_file_from_iso(Path $file, AbsFile $iso) {
     my @cmd = qw{bsdtar -x --no-same-permissions --to-stdout --fast-read};
     push @cmd, ('--file', $iso, $file);
     open(my $cmd, '-|', @cmd);
@@ -52,7 +52,7 @@ func extract_file_from_iso($file, $iso) {
     return $output;
 }
 
-func extract_here_file_from_iso($dir, $iso) {
+fun extract_here_file_from_iso($dir, $iso) {
     my @cmd = qw{bsdtar -x --no-same-permissions};
     push @cmd, ('--file', $iso, $dir);
     system(@cmd);
@@ -60,19 +60,19 @@ func extract_here_file_from_iso($dir, $iso) {
     return;
 }
 
-func run_as_root(@command) {
+fun run_as_root(@command) {
     system("sudo", "-n", @command);
 }
 
-func stdout_as_root(@command) {
+fun stdout_as_root(@command) {
     capturex(qw{sudo -n}, @command);
 }
 
-sub get_temp_dir {
-    dir(tempdir(CLEANUP => 0));
+fun get_temp_dir () {
+    path(tempdir(CLEANUP => 0));
 }
 
-func fatal (%args) {
+fun fatal (%args) {
     assert(exists $args{msg});
     assert_isa($args{msg}, 'ARRAY');
 
@@ -86,7 +86,7 @@ func fatal (%args) {
         }
         else {
             foreach my $dir (@{$args{rmtree}}) {
-                dir($dir)->rmtree;
+                path($dir)->remove_tree;
             }
         }
     }
@@ -94,9 +94,7 @@ func fatal (%args) {
     croak(@{$args{msg}});
 }
 
-func unpacked_size ($archive_file) {
-    assert(-e $archive_file);
-
+fun unpacked_size (AbsFile $archive_file) {
     sum(0,
         map {
             my $ret = 0;
@@ -118,23 +116,23 @@ func unpacked_size ($archive_file) {
     );
 }
 
-func make_archive_with_files_called ($archive_file, %args) {
+fun make_archive_with_files_called (AbsPath $archive_file, %args) {
     assert(exists $args{filenames});
     assert_isa($args{filenames}, 'ARRAY');
     assert_is(scalar(grep { exists $args{$_} } qw{size content}), 1);
 
     my $archive = Archive::Tar->new();
     my $orig_cwd = getcwd;
-    chdir $archive_file->dir;
+    chdir $archive_file->parent;
     foreach (@{$args{filenames}}) {
-        file($_)->dir->mkpath;
+        path($_)->parent->mkpath;
         if (exists $args{content}) {
-            my $fh = file($_)->openw;
+            my $fh = path($_)->openw;
             print $fh $args{content};
             close $fh;
         }
         elsif (exists $args{size}) {
-            system("dd", "if=/dev/zero", "of=$_", "bs=1M", "count=".$args{size});
+            system("dd", 'status=none', "if=/dev/zero", "of=$_", "bs=1M", "count=".$args{size});
             ${^CHILD_ERROR_NATIVE} == 0 or croak("Failed to create ", $args{size}, "MB file '$_'.");
         }
         $archive->add_files($_);
@@ -144,16 +142,16 @@ func make_archive_with_files_called ($archive_file, %args) {
     chdir $orig_cwd;
 }
 
-func make_iuk_with_files ($iuk_filename, $tempdir, @files) {
+fun make_iuk_with_files (AbsPath $iuk_filename, AbsDir $tempdir, @files) {
     my $orig_cwd = getcwd;
 
     my $iuk = Archive::Tar->new();
     chdir $tempdir;
 
-    my $fh = file('FORMAT')->openw; print $fh 1; close $fh;
+    path('FORMAT')->spew(1);
     $iuk->add_files('FORMAT');
     unless (grep { $_ eq 'control.yml' } @files) {
-        file('control.yml')->touch;
+        path('control.yml')->touch;
         $iuk->add_files('control.yml');
     }
     map { $iuk->add_files($_) or croak("Could not add file '$_'", $iuk->error) } @files;
@@ -163,25 +161,22 @@ func make_iuk_with_files ($iuk_filename, $tempdir, @files) {
     $res or croak("Could not write IUK '$iuk_filename':\n", $iuk->error);
 }
 
-=head2 space_available
+=head2 space_available_in
 
 Returns the number of available bytes there are in directory $dir.
 
 =cut
-func space_available ($dir) {
-    assert_defined($dir);
-
-    my $df = df($dir, 1); # "1" means "please return the value in bytes"
+fun space_available_in (AbsDir $dir) {
+    my $df = df($dir->stringify, 1); # "1" means "please return the value in bytes"
 
     assert_defined($df);
     assert_exists($df, 'bavail');
     return $df->{bavail};
 }
 
-func verify_signature ($txt, $signature_txt, $trusted_gnupg_homedir) {
+fun verify_signature ($txt, $signature_txt, AbsDir $trusted_gnupg_homedir) {
     assert_defined($txt);
     assert_nonblank($signature_txt);
-    assert(-d $trusted_gnupg_homedir);
 
     my $gnupg = GnuPG::Interface->new();
     $gnupg->options->hash_init(
